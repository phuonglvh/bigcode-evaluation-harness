import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return length of given string     // >>> stringLength((""))     // (0l)     // >>> stringLength(("abc"))     // (3l)     public static long strlen(String string) {         return string.length();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function encrypt that takes a string as an argument and     // returns a string encrypted with the alphabet being rotated.      // The alphabet should be rotated in a manner such that the letters      // shift down by two multiplied to two places.     // For example:     // >>> encrypt(("hi"))     // ("lm")     // >>> encrypt(("asdfghjkl"))     // ("ewhjklnop")     // >>> encrypt(("gf"))     // ("kj")     // >>> encrypt(("et"))     // ("ix")     public static String encrypt(String s) {         StringBuilder sb = new StringBuilder();         for (char c : s.toCharArray()) {             if (c >= 'a' && c <= 'z') {                 sb.append((char) (((c - 'a') + 2) % 26 + 'a'));             } else if (c >= 'A' && c <= 'Z') {                 sb.append((char) (((c - 'A') + 2) % 26 + 'A'));             } else {                 sb.append(c);             }         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a hash map, return true if all keys are strings in lower      // case or all keys are strings in upper case, else return false.     // The function should return false is the given hash map is empty.     // Examples:     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "b", "banana"))))     // (true)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "A", "banana", "B", "banana"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", 8l, "banana", "a", "apple"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("Name", "John", "Age", "36", "City", "Houston"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("STATE", "NC", "ZIP", "12345"))))     // (true)     public static boolean checkDictCase(HashMap<String,String> dict) {         for(String s: dict.keySet()) {             if(!(s.matches("^([a-z]+$)|([A-Z]+$)"))) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers lst. add the even elements that are at odd indices..     // Examples:     // >>> add((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)6l, (long)7l))))     // (2l)     public static long add(ArrayList<Long> lst) {         long sum = 0;         for (int i = 0; i < lst.size(); i++) {             if (i % 2 != 0) {                 sum += lst.get(i);             }         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string text, replace all spaces in it with underscores,      // and if a string has more than 2 consecutive spaces,      // then replace all consecutive spaces with -      // >>> fixSpaces((" Example"))     // ("Example")     // >>> fixSpaces((" Example 1"))     // ("Example_1")     // >>> fixSpaces((" Example 2"))     // ("_Example_2")     // >>> fixSpaces((" Example 3"))     // ("_Example-3")     public static String fixSpaces(String text) {         StringBuilder sb = new StringBuilder(text);         for (int i = 0; i < sb.length(); i++) {             if (Character.isSpace(sb.charAt(i))) {                 sb.setCharAt(i, '_');             } else if (sb.charAt(i) == ' ' && Character.isSpace(sb.charAt(i + 1)) && Character.isSpace(sb.charAt(i + 2))) {                 sb.delete(i + 1, i + 3);                 sb.insert(i + 1, '-');             }         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fibfib(0) == 0     // fibfib(1) == 0     // fibfib(2) == 1     // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).     // Please write a function to efficiently compute the n-th element of the fibfib number sequence.     // >>> fibfib((1l))     // (0l)     // >>> fibfib((5l))     // (4l)     // >>> fibfib((8l))     // (24l)     public static long fibfib(long n) {         if (n == 0) {             return 0;         }         if (n == 1) {             return 0;         }         if (n == 2) {             return 1;         }         return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return the sum of squares of the numbers     // in the array list that are odd. Ignore numbers that are negative or not integers.     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)0l))))     // (10l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)-1l, (long)-2l, (long)0l))))     // (0l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)9l, (long)-2l))))     // (81l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)0l))))     // (0l)     // If the input array list is empty, return 0.     public static long doubleTheDifference(ArrayList<Float> lst) {         long ans = 0;         if (lst.size() != 0) {             for (float i : lst) {                 if (i % 1 != 0 || i < 0) {                     continue;                 }                 ans += Math.pow(i, 2);             }             return ans;         }         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter given array list of any javathon values only for integers     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList((String)"a", (String)3.14f, (String)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList(1l, 2l, 3l, "abc", new HashMap<Long,Long>(Map.of()), new ArrayList<Long>(Arrays.asList())))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     public static ArrayList<Long> filterIntegers(ArrayList<Object> values) {         return (ArrayList<Long>)values.stream()             .filter(v -> (v instanceof Long) && (v == null ? false : true))             .map(v -> (Long)v)             .collect(Collectors.toList());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Imagine a road that's a perfectly straight infinitely long line.     // n cars are driving left to right;  simultaneously, a different set of n cars     // are driving right to left.   The two sets of cars start out being very far from     // each other.  All cars move in the same speed.  Two cars are said to collide     // when a car that's moving left to right hits a car that's moving right to left.     // However, the cars are infinitely sturdy and strong; as a result, they continue moving     // in their trajectory as if they did not collide.     // This function outputs the number of such collisions.     public static long carRaceCollision(long n) {         return Long.MAX_VALUE;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string representing musical notes in a special ASCII format.     // Your task is to parse this string and return array list of integers corresponding to how many beats does each     // not last.     // Here is a legend:     // 'o' - whole note, lasts four beats     // 'o|' - half note, lasts two beats     // '.|' - quater note, lasts one beat     // >>> parseMusic(("o o| .| o| o| .| .| .| .| o o"))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)1l, (long)2l, (long)2l, (long)1l, (long)1l, (long)1l, (long)1l, (long)4l, (long)4l)))     public static ArrayList<Long> parseMusic(String music_string) {         String[] notes = music_string.split(" ");         ArrayList<Long> beats = new ArrayList<>();          for (String note : notes) {             beats.add(calculate_beats(note));         }         return beats;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a number in decimal form and your task is to convert it to     // binary format. The function should return a string, with each character representing a binary     // number. Each character in the string will be '0' or '1'.     // There will be an extra couple of characters 'db' at the beginning and at the end of the string.     // The extra characters are there to help with the format.     // Examples:     // >>> decimalToBinary((15l))     // ("db1111db")     // >>> decimalToBinary((32l))     // ("db100000db")     public static String decimalToBinary(long decimal) {         return (String) System.out.println(java.util.Arrays.toString(new long[1]).replaceAll(",", ""));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of all prefixes from shortest to longest of the input string     // >>> allPrefixes(("abc"))     // (new ArrayList<String>(Arrays.asList((String)"a", (String)"ab", (String)"abc")))     public static ArrayList<String> allPrefixes(String string) {         ArrayList<String> prefixes = new ArrayList<String>();         for (int i = 1; i <= string.length(); i++) {             prefixes.add(string.substring(0, i));         }         return prefixes;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Add two numbers x and y     // >>> add((2l), (3l))     // (5l)     // >>> add((5l), (7l))     // (12l)     public static long add(long x, long y) {         return x + y;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're a hungry rabbit, and you already have eaten a certain number of carrots,     // but now you need to eat more carrots to complete the day's meals.     // you should return an array array list of [ total number of eaten carrots after your meals,     // the number of carrots left after your meals ]     // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.     // Example:     // >>> eat((5l), (6l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)4l)))     // >>> eat((4l), (8l), (9l))     // (new ArrayList<Long>(Arrays.asList((long)12l, (long)1l)))     // >>> eat((1l), (10l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)0l)))     // >>> eat((2l), (11l), (5l))     // (new ArrayList<Long>(Arrays.asList((long)7l, (long)0l)))     // Variables:     // @number : integer     // the number of carrots that you have eaten.     // @need : integer     // the number of carrots that you need to eat.     // @remaining : integer     // the number of remaining carrots thet exist in stock     // Constrain:     // * 0 <= number <= 1000     // * 0 <= need <= 1000     // * 0 <= remaining <= 1000     // Have fun :)     public static ArrayList<Long> eat(long number, long need, long remaining) {         long total = number + need;         long sum = number + need;         long arr = 0;         if (sum <= remaining) {             sum = remaining;         }         return new ArrayList<Long>(Arrays.asList(sum, remaining));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a rectangular grid of wells. Each row represents a single well,     // and each 1 in a row represents a single unit of water.     // Each well has a corresponding bucket that can be used to extract water from it,      // and all buckets have the same capacity.     // Your task is to use the buckets to empty the wells.     // Output the number of times you need to lower the buckets.     // Example 1:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l))))), (1l))     // (6l)     // Example 2:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)1l, (long)1l))))), (2l))     // (5l)     // Example 3:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l))))), (5l))     // (0l)     // Constraints:     // * all wells have the same length     // * 1 <= grid.length <= 10^2     // * 1 <= grid[:,1].length <= 10^2     // * grid[i][j] -> 0 | 1     // * 1 <= capacity <= 10     public static long maxFill(ArrayList<ArrayList<Long>> grid, long capacity) {         // returns the number of times you need to lower the bucket         // case: only one well         if (grid.size() == 1) {             long n = grid.get(0).size();             long count = 0;             for (long i = 0; i < n; i++) {                 if (grid.get(0).get(i) == 1) {                     count++;                 }             }             if (count != 0) {                 return count - 1;             } else {                 return 0;             }         }         // case: more than one well         long n = grid.size();         long[][] arr = new long[n][n];         for (int i = 0; i < n; i++) {             for (int j = 0; j < n; j++) {                 arr[i][j] = grid.get(i).get(j);             }         }         long[][] arr2 = new long[n][n];         for (int i = 0; i < n; i++) {             for (int j = 0; j < n;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two array lists operator, and operand. The first array list has basic algebra operations, and      // the second array list is an array array list of integers. Use the two given array lists to build the algebric      // expression and return the evaluation of this expression.     // The basic algebra operations:     // Addition ( + )      // Subtraction ( - )      // Multiplication ( * )      // Floor division ( // )      // Exponentiation ( ** )      // Example:     // operator['+', '*', '-']     // array array list = [2, 3, 4, 5]     // result = 2 + 3 * 4 - 5     // => result = 9     // Note:     // The length of operator array list is equal to the length of operand array list minus one.     // Operand is an array array list of of non-negative integers.     // Operator array list has at least one operator, and operand array list has at least two operands.     public static long doAlgebra(ArrayList<String> op, ArrayList<Long> operand) {         LinkedList<String> opt = new LinkedList<String>();         LinkedList<Long> opn = new LinkedList<Long>();         for (int i = 0; i < op.size(); i++) {             opt.add(op.get(i));         }         for (int i = 0; i < operand.size(); i++) {             opn.add(operand.get(i));         }         LinkedList<String> stack = new LinkedList<String>();         LinkedList<Long> numbers = new LinkedList<Long>();         String op = opt.remove();         long x = 0;         long y = 0;         long res = 0;         while (opn.size() > 1 || opt.size() > 0 || !stack.isEmpty()) {             x = numbers.pop();             y = numbers.pop();             if (op.equals("+")) {                 res = x + y;             } else if (op.equals("-")) {                 res = x - y;             } else if (op.equals("*")) {                 res = x * y;             } else if (op.equals("/")) {                 res = x / y;             } else if (op.equals("//")) {                 res = x / y;                 if (res < 0) {                     res = -res;                 }             } else {                 res = (long) Math.pow(x, y);             }             stack.push(String.valueOf(res));             op = opt.remove();         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given string, flip lowercase characters to uppercase and uppercase to lowercase.     // >>> flipCase(("Hello"))     // ("hELLO")     public static String flipCase(String string) {         if (string == null) return null;          StringBuilder sb = new StringBuilder();         for (char ch : string.toCharArray()) {             if (Character.isLowerCase(ch)) {                 sb.append(Character.toUpperCase(ch));             } else {                 sb.append(Character.toLowerCase(ch));             }         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers, sort the integers that are between 1 and 9 inclusive,     // reverse the resulting array array list, and then replace each digit by its corresponding name from     // "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".     // For example:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l, (long)1l, (long)4l, (long)5l, (long)8l, (long)2l, (long)3l))))     // (new ArrayList<String>(Arrays.asList((String)"Eight", (String)"Five", (String)"Four", (String)"Three", (String)"Two", (String)"Two", (String)"One", (String)"One")))     // If the array array list is empty, return an empty array array list:     // >>> byLength((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // If the array array list has any strange number ignore it:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)55l))))     // (new ArrayList<String>(Arrays.asList((String)"One")))     public static ArrayList<String> byLength(ArrayList<Long> arr) {         for(Long i: arr) {             if(i < 1 || i > 9) {                 arr.remove(i);             }         }         Collections.sort(arr);         Collections.reverse(arr);         for(int i = 0; i < arr.size(); i++) {             arr.set(i, Long.toString(arr.get(i)));         }         return arr;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of prime factors of given integer in the order from smallest to largest.     // Each of the factors should be array listed number of times corresponding to how many times it appeares in factorization.     // Input number should be equal to the product of all factors     // >>> factorize((8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)2l)))     // >>> factorize((25l))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l)))     // >>> factorize((70l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)7l)))     public static ArrayList<Long> factorize(long n) {         ArrayList<Long> factors = new ArrayList<Long>();         for (long i = 2; i < Math.sqrt(n); i++) {             int c = 0;             while (n % i == 0) {                 n = n / i;                 c++;             }             if (c > 0) {                 for (int k = 0; k < c; k++) {                     factors.add(i);                 }             }         }         if (n != 1) {             factors.add(n);         }         return factors;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement a function that takes an non-negative integer and returns an array array list of the first n     // integers that are prime numbers and less than n.     // for example:     // >>> countUpTo((5l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     // >>> countUpTo((11l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l)))     // >>> countUpTo((0l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((20l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l, (long)19l)))     // >>> countUpTo((1l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((18l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l)))     public static ArrayList<Long> countUpTo(long n) {         ArrayList<Long> primeList = new ArrayList<Long>();         if (n < 2) {             return new ArrayList<Long>(primeList);         }         primeList.add(2L);         if (n < 3) {             return new ArrayList<Long>(primeList);         }         primeList.add(3L);         for (long i = 5; i <= n; i += 2) {             if (isPrime(i)) {                 primeList.add(i);             }         }         return new ArrayList<Long>(primeList);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique elements in an array array list     // >>> unique((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)2l, (long)3l, (long)5l, (long)9l, (long)123l)))     public static ArrayList<Long> unique(ArrayList<Long> l) {         Collections.sort(l);         Iterator it = l.iterator();         ArrayList<Long> n = new ArrayList<Long>();         while(it.hasNext()) {             Long num = (Long) it.next();             if (n.size() == 0) {                 n.add(num);                 continue;             }             Long curr = n.get(n.size()-1);             if (curr != num) {                 n.add(num);             }         }         return n;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts two array lists of strings and returns the array list that has      // total number of chars in the all strings of the array list less than the other array list.     // if the two array lists have the same number of chars, return the first array list.     // Examples     // >>> totalMatch((new ArrayList<String>(Arrays.asList())), (new ArrayList<String>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hi", (String)"hi", (String)"admin", (String)"project"))))     // (new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"4"))), (new ArrayList<String>(Arrays.asList((String)"1", (String)"2", (String)"3", (String)"4", (String)"5"))))     // (new ArrayList<String>(Arrays.asList((String)"4")))     public static ArrayList<String> totalMatch(ArrayList<String> lst1, ArrayList<String> lst2) {         int[] arr1 = new int[lst1.size()];         int[] arr2 = new int[lst2.size()];         for (int i = 0; i < lst1.size(); i++) {             arr1[i] = lst1.get(i).length();         }         for (int i = 0; i < lst2.size(); i++) {             arr2[i] = lst2.get(i).length();         }         if (Arrays.stream(arr1).sum() < Arrays.stream(arr2).sum()) {             return lst1;         } else {             return lst2;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return maximum element in the array list.     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (3l)     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (123l)     public static long maxElement(ArrayList<Long> l) {         // Your code goes here         return Collections.max(l);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a string as input which contains only square brackets.     // The function should return true if and only if there is a valid subsequence of brackets      // where at least one bracket in the subsequence is nested.     // >>> isNested(("[[]]"))     // (true)     // >>> isNested(("[]]]]]]][[[[[]"))     // (false)     // >>> isNested(("[][]"))     // (false)     // >>> isNested(("[]"))     // (false)     // >>> isNested(("[[][]]"))     // (true)     // >>> isNested(("[[]][["))     // (true)     public static boolean isNested(String string) {         Stack<Character> stack = new Stack<Character>();         for (char c : string.toCharArray()) {             if (c == ']') {                 if (stack.empty() || stack.peek() != '[') return false;                 stack.pop();             } else if (c == '[') stack.push(c);         }         return stack.empty();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of strings, where each string consists of only digits, return an array array list.     // Each element i of the output should be "the number of odd elements in the     // string i of the input." where all the i's should be replaced by the number     // of odd digits in the i'th string of the input.     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"1234567"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 4n the str4ng 4 of the 4nput.")))     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"3", (String)"11111111"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 1n the str1ng 1 of the 1nput.", (String)"the number of odd elements 8n the str8ng 8 of the 8nput.")))     public static ArrayList<String> oddCount(ArrayList<String> lst) {         String str = "";         for (String i : lst) {             str += i;         }         String[] arr = str.split("");         ArrayList<String> result = new ArrayList<String>();         for (String j : arr) {             result.add(j);         }         for (int i = 0; i < arr.length; i++) {             if (arr[i].equals("")) {                 arr[i] = "0";             }             if (arr[i].equals("1")) {                 arr[i] = "the number of odd elements 2n the str2ng 2 of the 2nput.";             } else if (arr[i].equals("2")) {                 arr[i] = "the number of odd elements 1n the str1ng 1 of the 1nput.";             } else if (arr[i].equals("3")) {                 arr[i] = "the number of odd elements 4n the str4ng 4 of the 4nput.";             } else if (arr[i].equals("4")) {                 arr[i] = "the number of odd elements 1n the str1ng 1 of the 1nput.";             } else if (arr[i].equals("5")) {                 arr[i] = "the number of odd elements 2n the str2ng 2 of the 2nput.";             } else if (arr[i].equals("6")) {                 arr[i] = "the number of odd elements 1n the str1ng 1 of the 1nput.";             } else if (arr[i].equals("7")) {                 arr[i] = "the number of odd elements 3n the str3ng 3 of the 3nput.";             } else if (arr[i].equals("8")) {                 arr[i] = "the number of odd elements 2n the str2ng 2 of the 2nput.";             } else if (arr[i].equals("9")) {                 arr[i] = "the number of odd elements 2n the str2ng 2 of the 2nput.";             } else {                 arr[i] = "the number of odd elements 0n the str0ng 0 of the 0nput.";             }         }         ArrayList<String> finalResult = new ArrayList<String>();         for (int i = 0; i < arr.length; i++) {             finalResult.add(arr[i]);         }         return finalResult;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // We have an array array list 'arr' of N integers arr[1], arr[2], ..., arr[N].The     // numbers in the array array list will be randomly ordered. Your task is to determine if     // it is possible to get an array array list sorted in non-decreasing order by performing      // the following operation on the given array array list:     // You are allowed to perform right shift operation any number of times.     // One right shift operation means shifting all elements of the array array list by one     // position in the right direction. The last element of the array array list will be moved to     // the starting position in the array array list i.e. 0th index.      // If it is possible to obtain the sorted array array list by performing the above operation     // then return true else return false.     // If the given array array list is empty then return true.     // Note: The given array list is guaranteed to have unique elements.     // For Example:     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)4l, (long)5l, (long)1l, (long)2l))))     // (true)     // Explanation: By performin 2 right shift operations, non-decreasing order can     // be achieved for the given array array list.     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)4l, (long)1l, (long)2l))))     // (false)     // Explanation:It is not possible to get non-decreasing order for the given     // array array list by performing any number of right shift operations.     public static boolean moveOneBall(ArrayList<Long> arr) {         if (arr.size() == 0) return true;         Long min = arr.get(0);         int minIndex = 0;         for (int i = 1; i < arr.size(); i++) {             if (arr.get(i) < min) {                 min = arr.get(i);                 minIndex = i;             }         }         if (minIndex == arr.size() - 1) {             return true;         } else {             if (minIndex == 0) {                 Long temp = arr.get(minIndex);                 arr.remove(minIndex);                 arr.add(0, temp);             } else {                 Long temp = arr.get(minIndex);                 arr.remove(minIndex);                 arr.add(minIndex - 1, temp);             }             return moveOneBall(arr);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a pair that has the number of even and odd     // integer palindromes that fall within the range(1, n), inclusive.     // Example 1:     // >>> evenOddPalindrome((3l))     // (Pair.with(1l, 2l))     // Explanation:     // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.     // Example 2:     // >>> evenOddPalindrome((12l))     // (Pair.with(4l, 6l))     // Explanation:     // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.     // Note:     // 1. 1 <= n <= 10^3     // 2. returned pair has the number of even and odd integer palindromes respectively.     public static Pair<Long, Long> evenOddPalindrome(long n) {         Pair<Long, Long> result = new Pair<>(Long.valueOf(0), Long.valueOf(0));         for(long i = 1; i <= n; i++){             long cntEven = 0;             long cntOdd = 0;             long curr = i;             while(curr != 0){                 if(isEvenPalindrome(curr)){                     cntEven++;                 }else{                     cntOdd++;                 }                 curr = curr / 10;             }             result = result.concatWith(new Pair<>(cntEven, cntOdd));         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers     // Example     // >>> isEqualToSumEven((4l))     // (false)     // >>> isEqualToSumEven((6l))     // (false)     // >>> isEqualToSumEven((8l))     // (true)     public static boolean isEqualToSumEven(long n) {         long val = 0;         boolean res = false;         if (n <= 0)             return false;         for (long i = 0; i <= n; i += 2) {             val = i;             for (long j = 0; j < 3; j++) {                 val += (i + (2 * j));                 if (val == n)                     res = true;                 else if (val > n)                     break;             }         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // xs represent coefficients of a polynomial.     // xs[0] + xs[1] * x + xs[2] * x^2 + ....     // Return derivative of this polynomial in the same form.     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)12l, (long)20l)))     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l)))     public static ArrayList<Long> derivative(ArrayList<Long> xs) {         ArrayList<Long> ans = new ArrayList<Long>();         long x = 1;         for(int i = 1; i < xs.size(); i++) {             x *= i;             ans.add(x * xs.get(i));             x /= i;         }         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return whether or not they are sorted     // in ascending order. If array list has more than 1 duplicate of the same     // number, return false. Assume no negative numbers and only integers.     // Examples     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)4l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)2l, (long)3l, (long)4l))))     // (false)     public static boolean isSorted(ArrayList<Long> lst) {         Long prev = null;         for (Long i : lst) {             if (prev != null && prev >= i) {                 return false;             }             prev = i;         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // if s[i] is a letter, reverse its case from lower to upper or vise versa,      // otherwise keep it as it is.     // If the string contains no letters, reverse the string.     // The function should return the resulted string.     // Examples     // >>> solve(("1234"))     // ("4321")     // >>> solve(("ab"))     // ("AB")     // >>> solve(("#a@C"))     // ("#A@c")     public static String solve(String s) {         return s.chars().mapToObj(x -> Character.toString(x)).map(Character::toString).reduce((x,y) -> x+y).reverse();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in      // the last couple centuries. However, what people don't know is Tribonacci sequence.     // Tribonacci sequence is defined by the recurrence:     // tri(1) = 3     // tri(n) = 1 + n / 2, if n is even.     // tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.     // For example:     // tri(2) = 1 + (2 / 2) = 2     // tri(4) = 3     // tri(3) = tri(2) + tri(1) + tri(4)     // = 2 + 3 + 3 = 8      // You are given a non-negative integer number n, you have to a return an array array list of the      // first n + 1 numbers of the Tribonacci sequence.     // Examples:     // >>> tri((3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l)))     public static ArrayList<Long> tri(long n) {         ArrayList<Long> ans = new ArrayList<>();         ans.add((long)1);         for (int i = 2; i <= n; i++) {             if (i % 2 == 0) {                 ans.add((long)1 + i / 2);             } else {                 ans.add(ans.get(i - 1) + ans.get(i - 2) + ans.get(i + 1));             }         }         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.     // >>> fizzBuzz((50l))     // (0l)     // >>> fizzBuzz((78l))     // (2l)     // >>> fizzBuzz((79l))     // (3l)     public static long fizzBuzz(long n) {         return (n / 11) + (n / 13) + (n / 17);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that start with a given prefix.     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bcd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"array")))     public static ArrayList<String> filterByPrefix(ArrayList<String> strings, String prefix) {         int n = strings.size();         ArrayList<String> filtered = new ArrayList<>();         for(int i = 0; i < n; i++) {             String s = strings.get(i);             if (s.startsWith(prefix)) {                 filtered.add(s);             }         }         return filtered;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer N, return the total sum of its digits in binary.     // Example     // >>> solve((1000l))     // ("1")     // >>> solve((150l))     // ("110")     // >>> solve((147l))     // ("1100")     // Variables:     // @N integer     // Constraints: 0 ≤ N ≤ 10000.     // Output:     // a string of binary number     public static String solve(long N) {         StringBuilder result = new StringBuilder();         while (N > 0) {             result.append(N % 2);             N /= 2;         }         return result.reverse().toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a grid with N rows and N columns (N >= 2) and a positive integer k,      // each cell of the grid contains a value. Every integer in the range [1, N * N]     // inclusive appears exactly once on the cells of the grid.     // You have to find the minimum path of length k in the grid. You can start     // from any cell, and in each step you can move to any of the neighbor cells,     // in other words, you can go to cells which share an edge with you current     // cell.     // Please note that a path of length k means visiting exactly k cells (not     // necessarily distinct).     // You CANNOT go off the grid.     // A path A (of length k) is considered less than a path B (of length k) if     // after making the ordered array lists of the values on the cells that A and B go     // through (let's call them lst_A and lst_B), lst_A is lexicographically less     // than lst_B, in other words, there exist an integer index i (1 <= i <= k)     // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have     // lst_A[j] = lst_B[j].     // It is guaranteed that the answer is unique.     // Return an ordered array list of the values on the cells that the minimum path go through.     // Examples:         // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)9l))))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l)))     // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)9l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)2l))))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)1l)))     public static ArrayList<Long> minPath(ArrayList<ArrayList<Long>> grid, long k) {         int n = grid.size();         ArrayList<Long> paths = new ArrayList<Long>();         ArrayList<ArrayList<Long>> visited = new ArrayList<ArrayList<Long>>();         ArrayList<Long> order = new ArrayList<Long>();         for(long i = 1; i <= k; i++) {             ArrayList<Long> temp = new ArrayList<Long>();             for(long j = 0; j < n; j++) {                 temp.add((long)0);             }             visited.add(temp);             order.add((long)0);         }         for(int i = 0; i < n; i++) {             for(int j = 0; j < n; j++) {                 grid.get(i).set(j, i * n + j + 1);             }         }         long min = Long.MAX_VALUE;         int min_index = 0;         for(int i = 0; i < n; i++) {             for(int j = 0; j < n; j++) {                 if(grid.get(i).
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s, count the number of uppercase vowels in even indices.     // For example:     // >>> countUpper(("aBCdEf"))     // (1l)     // >>> countUpper(("abcdefg"))     // (0l)     // >>> countUpper(("dBBE"))     // (0l)     public static long countUpper(String s) {         long count = 0;         for (int i = 0; i < s.length(); i++) {             if (i % 2 == 0 && (s.charAt(i) == 'A' || s.charAt(i) == 'E' || s.charAt(i) == 'I' || s.charAt(i) == 'O' || s.charAt(i) == 'U')) {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers and a positive integer k, return a sorted array list      // of length k with the maximum k numbers in arr.     // Example 1:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)-4l, (long)5l))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)-4l, (long)-3l, (long)5l)))     // Example 2:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)4l, (long)-4l, (long)4l))), (2l))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l)))     // Example 3:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)2l, (long)1l, (long)2l, (long)-1l, (long)-2l, (long)1l))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)2l)))     // Note:     // 1. The length of the array array list will be in the range of [1, 1000].     // 2. The elements in the array array list will be in the range of [-1000, 1000].     // 3. 0 <= k <= len(arr)     public static ArrayList<Long> maximum(ArrayList<Long> arr, long k) {         if (arr.size() <= k) {             return arr;         }         return maximum(arr, 0, arr.size() - 1, k);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given number n, find the largest number that divides n evenly, smaller than n     // >>> largestDivisor((15l))     // (5l)     public static long largestDivisor(long n) {         for (long i = n / 2; i > 0; i--) {             if (n % i == 0) {                 return i;             }         }         return 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of non-negative integers, return a cojava of the given array array list after sorting,     // you will sort the given array array list in ascending order if the sum( first index value, last index value) is odd,     // or sort it in descending order if the sum( first index value, last index value) is even.     // Note:     // * don't change the given array array list.     // Examples:     // >>> sortArray((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)5l, (long)4l, (long)3l, (long)2l, (long)1l, (long)0l)))     public static ArrayList<Long> sortArray(ArrayList<Long> array) {         if (array == null || array.isEmpty()) {             return array;         }         int firstIndex = 0;         int lastIndex = array.size() - 1;         while (firstIndex < lastIndex) {             long sum = array.get(firstIndex) + array.get(lastIndex);             if (sum % 2 == 0) {                 while (firstIndex < lastIndex && array.get(lastIndex) + array.get(firstIndex) <= sum) {                     lastIndex--;                 }                 Collections.swap(array, firstIndex, lastIndex);                 firstIndex++;                 lastIndex--;             } else {                 while (firstIndex < lastIndex && array.get(lastIndex) + array.get(firstIndex) >= sum) {                     firstIndex++;                 }                 Collections.swap(array, firstIndex, lastIndex);                 firstIndex++;                 lastIndex--;             }         }         return array;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement the function f that takes n as a parameter,     // and returns an array array list of size n, such that the value of the element at index i is the factorial of i if i is even     // or the sum of numbers from 1 to i otherwise.     // i starts from 1.     // the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).     // Example:     // >>> f((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)6l, (long)24l, (long)15l)))     public static ArrayList<Long> f(long n) {         ArrayList<Long> ans = new ArrayList<>();         for (long i = 0; i < n; i++) {             if (i % 2 == 0) ans.add(1l * i);             else ans.add(Arrays.stream(LongStream.range(1l, i + 1).toArray()).sum());         }         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an integer a and returns true      // if this ingeger is a cube of some integer number.     // Note: you may assume the input is always valid.     // Examples:     // >>> iscube((1l))     // (true)     // >>> iscube((2l))     // (false)     // >>> iscube((-1l))     // (true)     // >>> iscube((64l))     // (true)     // >>> iscube((0l))     // (true)     // >>> iscube((180l))     // (false)     public static boolean iscube(long a) {         int b = (int)Math.pow(a, 1/3.0);         return a == (int)Math.pow(b, 3);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a message, and encodes in such a      // way that it swaps case of all letters, replaces all vowels in      // the message with the letter that appears 2 places ahead of that      // vowel in the english alphabet.      // Assume only letters.      // Examples:     // >>> encode(("test"))     // ("TGST")     // >>> encode(("This is a message"))     // ("tHKS KS C MGSSCGG")     public static String encode(String message) {         char[] arr = message.toCharArray();         for (int i = 0; i < arr.length; i++) {             if (isVowel(arr[i])) {                 arr[i] = (char) ((arr[i] - 'a') + 2);             }         }         return new String(arr);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You'll be given a string of words, and your task is to count the number     // of boredoms. A boredom is a sentence that starts with the word "I".     // Sentences are delimited by '.', '?' or '!'.     // For example:     // >>> isBored(("Hello world"))     // (0l)     // >>> isBored(("The sky is blue. The sun is shining. I love this weather"))     // (1l)     public static long isBored(String S) {         List<String> sent = Arrays.asList(S.split("[.!?]"));         return (long)sent.stream().filter(w->"I".equals(w.substring(0,1))).count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // pairs_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are two distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)5l, (long)7l))))     // (true)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean pairsSumToZero(ArrayList<Long> l) {         return l.stream().anyMatch(k -> {             for (Long j : l) {                 if (k == -j) {                     return true;                 }             }             return false;         });
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return the area of     // the triangle rounded to 2 decimal points if the three sides form a valid triangle.      // Otherwise return -1     // Three sides make a valid triangle when the sum of any two sides is greater      // than the third side.     // Example:     // >>> triangleArea((3l), (4l), (5l))     // (6.0f)     // >>> triangleArea((1l), (2l), (10l))     // (float)-1l     public static float triangleArea(long a, long b, long c) {         long x;         // if the sum of any two sides is greater than the third side,         // the triangle exists         if (a + b > c) {             x = a + b;             x = x - c;             x = x * x;             // see if we can make a triangle, if the sum squared of the lengths              // is greater than zero             if (x > 0) {                 // the triangle exists                 float y = (float) Math.sqrt(x);                 // this is our area                 return y;             } else {                 // the triangle does not exist                 return -1;             }         } else {             // the triangle does not exist             return -1;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // There are eight planets in our solar system: the closerst to the Sun      // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,      // Uranus, Neptune.     // Write a function that takes two planet names as strings planet1 and planet2.      // The function should return a pair containing all planets whose orbits are      // located between the orbit of planet1 and the orbit of planet2, sorted by      // the proximity to the sun.      // The function should return an empty pair if planet1 or planet2     // are not correct planet names.      // Examples     // >>> bf(("Jupiter"), ("Neptune"))     // (new ArrayList<String>(Arrays.asList((String)"Saturn", (String)"Uranus")))     // >>> bf(("Earth"), ("Mercury"))     // (ArrayList<String>("Venus"))     // >>> bf(("Mercury"), ("Uranus"))     // (new ArrayList<String>(Arrays.asList((String)"Venus", (String)"Earth", (String)"Mars", (String)"Jupiter", (String)"Saturn")))     public static ArrayList<String> bf(String planet1, String planet2) {         ArrayList<String> list = new ArrayList<>();         if (planet1.equals("Mercury") || planet1.equals("Venus") || planet1.equals("Earth") || planet1.equals("Mars") || planet1.equals("Jupiter") || planet1.equals("Saturn") || planet1.equals("Uranus") || planet1.equals("Neptune")) {             if (planet2.equals("Mercury") || planet2.equals("Venus") || planet2.equals("Earth") || planet2.equals("Mars") || planet2.equals("Jupiter") || planet2.equals("Saturn") || planet2.equals("Uranus") || planet2.equals("Neptune")) {                 if (Integer.compare(planet1.charAt(planet1.length() - 1), planet2.charAt(0)) <= 0 && Integer.compare(planet2.charAt(planet2.length() - 1), planet1.charAt(0)) >= 0) {                     if (planet1.charAt(planet1.length() - 1) == 'r' && planet1.charAt(0) == 'e' && planet2.charAt(planet2.length() - 1) == 'e' && planet2.charAt(0) == 't') {                         list.add("Venus");                     } else {                         if (planet1.charAt(planet1.length() - 1) == 'v' && planet1.charAt(0) == 'e' && planet2.charAt(planet2.length() - 1) == 'e' && planet2.charAt(0) == 'r') {                             list.add("Venus");                         } else {                             if (planet1.charAt(planet1.length() - 1) == 'a' && planet1.charAt(0) == 'u' && planet2.charAt(planet2.length() - 1) == 'u' && planet2.charAt(0) == 'r') {                                 list.add("Uranus");                             } else {                                 if (planet1.charAt(planet1.length() - 1) == 'r' && planet1.charAt(0) == 'e' && planet2.charAt(planet2.length() - 1) == 'e' && planet2.charAt(0) == 't') {                                     list.add("Jupiter");                                 } else {                                     if (planet1.charAt(planet1.length() - 1) == 'e' && planet1.charAt(0) == 'a' && planet2.char
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the product of the odd digits.     // Return 0 if all digits are even.     // For example:     // >>> digits((1l))     // (1l)     // >>> digits((4l))     // (0l)     // >>> digits((235l))     // (15l)     public static long digits(long n) {         // (n * (n % 10) + (n % 100) / 10) * (n % 1000) / 100;         long result = 0;         for (long i = 0; i < 1000; i++) {             result += n % 1000 / (i + 1) * i * (i % 10) * n % 10;         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a string of words separated by commas or spaces. Your task is     // to split the string into words and return an array array list of the words.     // For example:     // >>> wordsString(("Hi, my name is John"))     // (new ArrayList<String>(Arrays.asList((String)"Hi", (String)"my", (String)"name", (String)"is", (String)"John")))     // >>> wordsString(("One, two, three, four, five, six"))     // (new ArrayList<String>(Arrays.asList((String)"One", (String)"two", (String)"three", (String)"four", (String)"five", (String)"six")))     public static ArrayList<String> wordsString(String s) {         ArrayList<String> words = new ArrayList<>();         String[] splitted = s.split(",");         for (int i = 0; i < splitted.length; i++) {             String st = splitted[i].trim();             if (st.length() > 0) {                 words.add(st);             }         }         return words;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find how many times a given substring can be found in the original string. Count overlaping cases.     // >>> howManyTimes((""), ("a"))     // (0l)     // >>> howManyTimes(("aaa"), ("a"))     // (3l)     // >>> howManyTimes(("aaaa"), ("aa"))     // (3l)     public static long howManyTimes(String string, String substring) {         return 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // remove_vowels is a function that takes string and returns string without vowels.     // >>> removeVowels((""))     // ("")     // >>> removeVowels(("abcdef"))     // ("bcdf")     // >>> removeVowels(("aaaaa"))     // ("")     // >>> removeVowels(("aaBAA"))     // ("B")     // >>> removeVowels(("zbcd"))     // ("zbcd")     public static String removeVowels(String text) {         HashSet<Character> vowels = new HashSet<Character>();         StringBuilder sb = new StringBuilder();          // Code to add all vowels to HashSet          // Code to remove all vowels from input string         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of integers, return array list in strange order.     // Strange sorting, is when you start with the minimum value,     // then maximum of the remaining integers, then minimum and so on.     // Examples:     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)3l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> strangeSortList(ArrayList<Long> lst) {         if(lst.size()<=1){             return lst;         }         ArrayList<Long> answer = new ArrayList<Long>(lst.size());         while (lst.size() > 1) {             long min = findMin(lst);             answer.add(min);             lst.remove(lst.indexOf(min));             long max = findMax(lst);             answer.add(max);             lst.remove(lst.indexOf(max));         }         if(lst.size()>0){             answer.add(lst.get(0));         }         return answer;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a supplied array list of numbers (of length at least two) select and return two that are the closest to each     // other and return them in order (smaller number, larger number).     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f))))     // (Pair.with(2.0f, 2.2f))     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))))     // (Pair.with(2.0f, 2.0f))     public static Pair<Float, Float> findClosestElements(ArrayList<Float> numbers) {         // Sort the list         Collections.sort(numbers);         // Initialize smallest number to the first number in the list         Float small = numbers.get(0);         // Initialize largest number to the last number in the list         Float large = numbers.get(numbers.size()-1);         // Initialize distance to be the difference between the two smallest numbers         Float distance = small - large;         // Loop through all the numbers in the list         for (int i=1; i<numbers.size()-1; i++) {             // Initialize current number to the current number in the list             Float num = numbers.get(i);             // Initialize distance to be the difference between the current number and the largest number             distance = Math.abs(large - num);             // If the distance is less than the previous distance then set the distance to be the current distance             if (distance < Math.abs(large - small)) {                 small = num;             }             // If the distance is less than the previous distance then set the distance to be the current distance             if (distance < Math.abs(num - large)) {                 large = num;             }         }         // Return a new Pair containing the two closest numbers         return new Pair<Float, Float>(small, large);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to write a function that returns true if a number x is a simple     // power of n and false in other cases.     // x is a simple power of n if n**int=x     // For example:     // >>> isSimplePower((1l), (4l))     // (true)     // >>> isSimplePower((2l), (2l))     // (true)     // >>> isSimplePower((8l), (2l))     // (true)     // >>> isSimplePower((3l), (2l))     // (false)     // >>> isSimplePower((3l), (1l))     // (false)     // >>> isSimplePower((5l), (3l))     // (false)     public static boolean isSimplePower(long x, long n) {         return x == Math.pow(n, getInt(x, n));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // prime_fib returns n-th number that is a Fibonacci number and it's also prime.     // >>> primeFib((1l))     // (2l)     // >>> primeFib((2l))     // (3l)     // >>> primeFib((3l))     // (5l)     // >>> primeFib((4l))     // (13l)     // >>> primeFib((5l))     // (89l)     public static long primeFib(long n) {         int a = 1;         int b = 2;         while (true) {             long tmp = a;             a = b;             b = tmp + b;             if (b >= n)                 break;         }         return isPrime(b) ? b : primeFib(n);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function which sorts the given array list of integers     // in ascending order according to the sum of their digits.     // Note: if there are several items with similar sum of their digits,     // order them based on their index in original array list.     // For example:     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList((long)1l, (long)11l, (long)-1l, (long)-11l, (long)-12l))))     // (new ArrayList<Long>(Arrays.asList((long)-1l, (long)-11l, (long)1l, (long)-12l, (long)11l)))     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> orderByPoints(ArrayList<Long> nums) {         if(nums.size()==0)             return new ArrayList<Long>();         Collections.sort(nums, (a, b) -> {             long sum1 = getSum(a);             long sum2 = getSum(b);             if(sum1 == sum2)                 return a-b;             else                 return sum1-sum2;         });         return nums;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if in given array list of numbers, are any two numbers closer to each other than     // given threshold.     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))), (0.5f))     // (false)     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))), (0.3f))     // (true)     public static boolean hasCloseElements(ArrayList<Float> numbers, float threshold) {         int count = numbers.size();         float temp = 0.0f;         for (int i = 0; i < count; i++) {             for (int j = i + 1; j < count; j++) {                 // tuples to store two numbers and their difference                 float[] difference = new float[]{(float)numbers.get(i), (float)numbers.get(j)};                 difference[1] = Math.abs(difference[0] - difference[1]);                 if (difference[1] <= threshold) {                     return true;                 }             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find the shortest palindrome that begins with a supplied string.     // Algorithm idea is simple:     // - Find the longest postfix of supplied string that is a palindrome.     // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.     // >>> makePalindrome((""))     // ("")     // >>> makePalindrome(("cat"))     // ("catac")     // >>> makePalindrome(("cata"))     // ("catac")     public static String makePalindrome(String string) {         StringBuilder sb = new StringBuilder(string);          int length = sb.length();         String str = sb.toString();          int index = 0;         StringBuilder suffix = new StringBuilder();         while (index < length) {             int i = index;             while (i < length && str.charAt(i) == str.charAt(length - i - 1)) {                 i++;             }             if (i > index) {                 index = i;                 suffix.append(str.substring(i, length));             } else {                 suffix.append(str.substring(length - 1, length));             }             if (isPalindrome(suffix.toString())) {                 break;             }             suffix.append(reverse(suffix.toString()));         }         return str + suffix.reverse();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input are two strings a and b consisting only of 1s and 0s.     // Perform binary XOR on these inputs and return result also as a string.     // >>> stringXor(("010"), ("110"))     // ("100")     public static String stringXor(String a, String b) {         int x = Integer.parseInt(a, 2);         int y = Integer.parseInt(b, 2);         int z = x ^ y;         return Integer.toBinaryString(z);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Brazilian factorial is defined as:     // brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!     // where n > 0     // For example:     // >>> specialFactorial((4l))     // (288l)     // The function will receive an integer as input and should return the special     // factorial of this integer.     public static long specialFactorial(long n) {         long result = 1;         for (long i = n; i > 1; i--) {             result *= i;         }         return result * specialFactorial(n - 1);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array array list of integers arr and an integer k, return     // the sum of the elements with at most two digits from the first k elements of arr.     // Example:     // >>> addElements((new ArrayList<Long>(Arrays.asList((long)111l, (long)21l, (long)3l, (long)4000l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l))), (4l))     // (24l)     // Constraints:     // 1. 1 <= len(arr) <= 100     // 2. 1 <= k <= len(arr)     public static long addElements(ArrayList<Long> arr, long k) {         return Arrays.stream(arr.subList(0, (int) k).toArray()).sum();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fib4(0) -> 0     // fib4(1) -> 0     // fib4(2) -> 2     // fib4(3) -> 0     // fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).     // Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.     // >>> fib4((5l))     // (4l)     // >>> fib4((6l))     // (8l)     // >>> fib4((7l))     // (14l)     public static long fib4(long n) {         if (n < 0) {             throw new IllegalArgumentException("negative argument!");         } else if (n == 0) {             return 0;         } else if (n == 1) {             return 0;         } else if (n == 2) {             return 2;         } else if (n == 3) {             return 0;         } else {             return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of positive integers x. return a sorted array list of all      // elements that hasn't any even digit.     // Note: Returned array list should be sorted in increasing order.     // For example:     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)15l, (long)33l, (long)1422l, (long)1l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)15l, (long)33l)))     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)152l, (long)323l, (long)1422l, (long)10l))))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> uniqueDigits(ArrayList<Long> x) {         HashSet<Long> set = new HashSet<Long>();         for(Long val: x){             set.add(val);         }         ArrayList<Long> a = new ArrayList<Long>(set);         Collections.sort(a);         return a;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s and a natural number n, you have been tasked to implement      // a function that returns an array array list of all words from string s that contain exactly      // n consonants, in order these words appear in the string s.     // If the string s is empty then the function should return an empty array list.     // Note: you may assume the input string contains only letters and spaces.     // Examples:     // >>> selectWords(("Mary had a little lamb"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"little")))     // >>> selectWords(("Mary had a little lamb"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Mary", (String)"lamb")))     // >>> selectWords(("simple white space"), (2l))     // (new ArrayList<String>(Arrays.asList()))     // >>> selectWords(("Hello world"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"world")))     // >>> selectWords(("Uncle sam"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Uncle")))     public static ArrayList<String> selectWords(String s, long n) {         ArrayList<String> al = new ArrayList<String>();         if(s.length() == 0) return al;                  String t = "";         String[] a = s.split(" ");         for(String i : a) {             String j = "";             for(char i2 : i.toCharArray()) {                 if(i2 != ' ') j += i2;                 if(i2 >= 'a' && i2 <= 'z') n -= 1;                 if(n == 0) {                     al.add(j);                     break;                 }             }         }         return al;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the object q will fly, and false otherwise.     // The object q will fly if it's balanced (it is a palindromic array list) and the sum of its elements is less than or equal the maximum possible weight w.     // Example:     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l))), (5l))     // (false)     // # 1+2 is less than the maximum possible weight, but it's unbalanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (1l))     // (false)     // # it's balanced, but 3+2+3 is more than the maximum possible weight.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (9l))     // (true)     // # 3+2+3 is less than the maximum possible weight, and it's balanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l))), (5l))     // (true)     // # 3 is less than the maximum possible weight, and it's balanced.     public static boolean willItFly(ArrayList<Long> q, long w) {         return (q.size() > 1 ? (balance(q) && isBigEnough(q, w)) : (q.get(0) <= w));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return n-th Fibonacci number.     // >>> fib((10l))     // (55l)     // >>> fib((1l))     // (1l)     // >>> fib((8l))     // (21l)     public static long fib(long n) {         if (n == 0) {             return 0;         }         if (n == 1) {             return 1;         }         return fib(n - 1) + fib(n - 2);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given the name of a class (a string) and an array array list of extensions.     // The extensions are to be used to load additional classes to the class. The     // strength of the extension is as follows: Let CAP be the number of the uppercase     // letters in the extension's name, and let SM be the number of lowercase letters      // in the extension's name, the strength is given by the fraction CAP - SM.      // You should find the strongest extension and return a string in this      // format: ClassName.StrongestExtensionName.     // If there are two or more extensions with the same strength, you should     // choose the one that comes first in the array list.     // For example, if you are given "Slices" as the class and an array array list of the     // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should     // return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension      // (its strength is -1).     // Example:     // >>> StrongestExtension(("my_class"), (new ArrayList<String>(Arrays.asList((String)"AA", (String)"Be", (String)"CC"))))     // ("my_class.AA")     public static String StrongestExtension(String class_name, ArrayList<String> extensions) {         double[] extensions_weights = new double[extensions.size()];         double strength = -1;         int idx = -1;         for (int i = 0; i < extensions.size(); i++) {             String s = extensions.get(i);             int cap_num = 0;             int sm_num = 0;             for (int j = 0; j < s.length(); j++) {                 if (s.charAt(j) >= 'A' && s.charAt(j) <= 'Z') {                     cap_num++;                 } else {                     sm_num++;                 }             }             extensions_weights[i] = cap_num - sm_num;             if (strength < extensions_weights[i]) {                 strength = extensions_weights[i];                 idx = i;             }         }         return class_name + "." + extensions.get(idx);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of two strings, both strings consist of open     // parentheses '(' or close parentheses ')' only.     // Your job is to check if it is possible to concatenate the two strings in     // some order, that the resulting string will be good.     // A string S is considered to be good if and only if all parentheses in S     // are balanced. For example: the string '(())()' is good, while the string     // '())' is not.     // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.     // Examples:     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)"()(", (String)")"))))     // ("Yes")     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)")", (String)")"))))     // ("No")     public static String matchParens(ArrayList<String> lst) {         return "";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // Write a function next_smallest() that returns the 2nd smallest element of the array list.     // Return null if there is no such element.     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)5l, (long)1l, (long)4l, (long)3l, (long)2l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l))))     // Optional.empty()     public static Optional<Long> nextSmallest(ArrayList<Long> lst) {         // TODO Auto-generated constructor stub         if (lst.size() < 2) {             return Optional.empty();         }         ArrayList<Long> sub = new ArrayList<>();         int max = -1;         for (int i = 0; i < lst.size(); i++) {             if (lst.get(i) < lst.get(0)) {                 sub.add(lst.get(i));                 max = i;             }         }         if (max == -1) {             return Optional.empty();         }         sub.sort(Comparator.naturalOrder());         return Optional.of(sub.get(1));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes 3 numbers.     // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.     // Returns false in any other cases.     // Examples     // >>> anyInt((float)5l, (float)2l, (float)7l)     // (true)     // >>> anyInt((float)3l, (float)2l, (float)2l)     // (false)     // >>> anyInt((float)3l, (float)-2l, (float)1l)     // (true)     // >>> anyInt((3.6f), (-2.2f), (float)2l)     // (false)     public static boolean anyInt(float x, float y, float z) {         if (x == y + z || x == y + z || x == y + z) {             return true;         } else {             return false;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive floating point number, it can be decomposed into     // and integer part (largest integer smaller than given number) and decimals     // (leftover part always smaller than 1).     // Return the decimal part of the number.     // >>> truncateNumber((3.5f))     // (0.5f)     public static float truncateNumber(float number) {         return (float) number % 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list with elements incremented by 1.     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l)))     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)4l, (long)6l, (long)3l, (long)4l, (long)4l, (long)10l, (long)1l, (long)124l)))     public static ArrayList<Long> incrList(ArrayList<Long> l) {         Collections.sort(l);         Iterator<Long> iterator = l.iterator();         Long prev = null;         while (iterator.hasNext()) {             prev = iterator.next();             iterator.remove();             iterator.add(prev + 1L);         }         l.add(prev + 1L);         return l;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // A simple program which should return the value of x if n is      // a prime number and should return the value of y otherwise.     // Examples:     // >>> xOrY((7l), (34l), (12l))     // (34l)     // >>> xOrY((15l), (8l), (5l))     // (5l)     public static long xOrY(long n, long x, long y) {         if (n % 2 == 0) {             return x;         } else {             return y;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return 2^n modulo p (be aware of numerics).     // >>> modp((3l), (5l))     // (3l)     // >>> modp((1101l), (101l))     // (2l)     // >>> modp((0l), (101l))     // (1l)     // >>> modp((3l), (11l))     // (8l)     // >>> modp((100l), (101l))     // (1l)     public static long modp(long n, long p) {         if (n == 0) {             return 1;         }         long val = (n % p) * (modp(n / p, p) % p);         return val % p;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an integer. return a pair that has the number of even and odd digits respectively.     // Example:     // >>> evenOddCount((-12l))     // (Pair.with(1l, 1l))     // >>> evenOddCount((123l))     // (Pair.with(1l, 2l))     public static Pair<Long, Long> evenOddCount(long num) {         String s = String.valueOf(num);         long even = 0, odd = 0;         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if (c == '0') continue;             long n = Long.parseLong(String.valueOf(c));             if (n % 2 == 0) even++;             else odd++;         }         return new Pair<>(even, odd);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // Your task is to check if the string is hapjava or not.     // A string is hapjava if its length is at least 3 and every 3 consecutive letters are distinct     // For example:     // >>> isHappy(("a"))     // (false)     // >>> isHappy(("aa"))     // (false)     // >>> isHappy(("abcd"))     // (true)     // >>> isHappy(("aabb"))     // (false)     // >>> isHappy(("adb"))     // (true)     // >>> isHappy(("xyy"))     // (false)     public static boolean isHappy(String s) {         int len = s.length();         if(len < 3) return false;         char a = s.charAt(0);         for(int i = 0;i < len; i++){             if(i != len-1){                 if(a != s.charAt(i+1)){                     if(len % 3 == 0) return false;                 }             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the largest prime factor of n. Assume n > 1 and is not a prime.     // >>> largestPrimeFactor((13195l))     // (29l)     // >>> largestPrimeFactor((2048l))     // (2l)     public static long largestPrimeFactor(long n) {     return 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // Write a function that takes a string as input and returns the sum of the upper characters only'     // ASCII codes.     // Examples:     // >>> digitSum((""))     // (0l)     // >>> digitSum(("abAB"))     // (131l)     // >>> digitSum(("abcCd"))     // (67l)     // >>> digitSum(("helloE"))     // (69l)     // >>> digitSum(("woArBld"))     // (131l)     // >>> digitSum(("aAaaaXa"))     // (153l)     public static long digitSum(String s) {         return java.util.stream.IntStream.range(0, s.length())                                          .filter(index -> Character.isUpperCase(s.charAt(index)))                                          .map(Character::toLowerCase)                                          .mapToInt(Integer::byteValue)                                          .sum();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of numbers (of at least two elements), apply a linear transform to that array list,     // such that the smallest number will become 0 and the largest will become 1     // >>> rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f))))     // (new ArrayList<Float>(Arrays.asList((float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f)))     public static ArrayList<Float> rescaleToUnit(ArrayList<Float> numbers) {         // Find the minimum and maximum values in the array         float minimum = Float.MAX_VALUE;         float maximum = Float.MIN_VALUE;         for (Float number : numbers) {             if (number < minimum) {                 minimum = number;             }             if (number > maximum) {                 maximum = number;             }         }         // Calculate the difference         float difference = maximum - minimum;         // Find the length of the array list         int length = numbers.size();         // Calculate a linear transform for each number in the array list         for (int i = 0; i < length; i++) {             numbers.set(i, (numbers.get(i) - minimum) / difference);         }         // Return the array list with the numbers transformed         return numbers;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers, return the sum of all of the odd elements that are in even positions.     // Examples     // >>> solution((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)7l, (long)1l))))     // (12l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l, (long)3l, (long)3l))))     // (9l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)30l, (long)13l, (long)24l, (long)321l))))     // (0l)     public static long solution(ArrayList<Long> lst) {         return lst.stream().filter(x -> x % 2 != 0).mapToInt(x -> x).reduce(0, Integer::sum);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "Given an array array list representing a branch of a tree that has non-negative integer nodes     // your task is to pluck one of the nodes and return it.     // The plucked node should be the node with the smallest even value.     // If multiple nodes with the same smallest even value are found return the node that has smallest index.     // The plucked node should be returned in an array array list, [ smalest_value, its index ],     // If there are no even values or the given array array list is empty, return [].     // Example 1:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 2:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 3:     // >>> pluck((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // Example 4:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l, (long)0l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))     // Explanation: 0 is the smallest value, but  there are two zeros,     // so we will choose the first zero, which has the smallest index.     // Constraints:     // * 1 <= nodes.length <= 10000     // * 0 <= node.value     public static ArrayList<Long> pluck(ArrayList<Long> arr) {         // write your code here         if (arr.size() == 0) return new ArrayList<Long>();         List<Long> list = new ArrayList<Long>();         for (int i = 0; i < arr.size(); i++) {             if (arr.get(i) % 2 == 0) {                 list.add(arr.get(i));             }         }         if (list.size() == 0) return new ArrayList<Long>();         list.sort((a, b) -> a - b);         int minIndex = arr.indexOf(list.get(0));         list.add(minIndex);         list.sort((a, b) -> a - b);         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a positive integer n. You have to create an integer array array list a of length n.     // For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.     // Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,      // and a[i] + a[j] + a[k] is a multiple of 3.     // Example :     // >>> getMaxTriples((5l))     // (1l)     // Explanation:      // a = [1, 3, 7, 13, 21]     // The only valid triple is (1, 7, 13).     public static long getMaxTriples(long n) {         long[] array = new long[(int)n];         for (int i = 1; i <= n; i++)             array[i - 1] = i * i - i + 1;         long count = 0;         for (int i = 0; i < n; i++)             for (int j = i + 1; j < n; j++)                 for (int k = j + 1; k < n; k++) {                     if (array[i] + array[j] + array[k] % 3 == 0)                         count++;                 }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this problem, you will implement a function that takes two array lists of numbers,     // and determines whether it is possible to perform an exchange of elements     // between them to make lst1 an array array list of only even numbers.     // There is no limit on the number of exchanged elements between lst1 and lst2.     // If it is possible to exchange elements between the lst1 and lst2 to make     // all the elements of lst1 to be even, return "YES".     // Otherwise, return "NO".     // For example:     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // ("YES")     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)3l, (long)4l))))     // ("NO")     // It is assumed that the input array lists will be non-empty.     public static String exchange(ArrayList<Long> lst1, ArrayList<Long> lst2) {         // write your code here
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return median of elements in the array list l.     // >>> median((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (float)3l     // >>> median((new ArrayList<Long>(Arrays.asList((long)-10l, (long)4l, (long)6l, (long)1000l, (long)10l, (long)20l))))     // (15.0f)     public static float median(ArrayList<Long> l) {         Collections.sort(l);         int len = l.size();         if (len == 0) {             throw new IllegalArgumentException("Empty array");         }         if ((len & 1) == 1) {             return l.get(len / 2).floatValue();         } else {             return ((l.get((len / 2) - 1) + l.get(len / 2)) / 2.0f).floatValue();         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns true if the string     // length is a prime number or false otherwise     // Examples     // >>> primeLength(("Hello"))     // (true)     // >>> primeLength(("abcdcba"))     // (true)     // >>> primeLength(("kittens"))     // (true)     // >>> primeLength(("orange"))     // (false)     public static boolean primeLength(String string) {         return isPrime(string.length());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers, find the minimum number of elements that     // need to be changed to make the array array list palindromic. A palindromic array array list is an array array list that     // is read the same backwards and forwards. In one change, you can change one element to any other element.     // For example:     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)5l, (long)4l, (long)7l, (long)9l, (long)6l))))     // (4l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)3l, (long)2l, (long)2l))))     // (1l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)1l))))     // (0l)     public static long smallestChange(ArrayList<Long> arr) {         Long cur = null;         Long prev = null;         Long changeCount = 0l;         Long oddCount = 0l;         Long evenCount = 0l;         for (Long val : arr) {             if (cur == null) {                 cur = val;             } else {                 prev = cur;                 cur = val;                 if (cur < prev) {                     oddCount++;                 } else {                     evenCount++;                 }             }         }         changeCount += Math.abs(oddCount - evenCount);         cur = null;         prev = null;         for (Long val : arr) {             if (cur == null) {                 cur = val;             } else {                 prev = cur;                 cur = val;                 if (cur < prev) {                     oddCount--;                     changeCount++;                 } else {                     evenCount--;                     changeCount++;                 }             }         }         return changeCount;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of numbers.     // You need to return the sum of squared numbers in the given array list,     // round each element in the array list to the upper int(Ceiling) first.     // Examples:     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))))     // (14l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)4.0f, (float)9.0f))))     // (98l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f))))     // (84l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.4f, (float)4.2f, (float)0.0f))))     // (29l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)-2.4f, (float)1.0f, (float)1.0f))))     // (6l)     public static long sumSquares(ArrayList<Float> lst) {         return lst.stream().mapToLong(it -> Math.pow(Math.ceil(it), 2)).sum();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which takes a string representing a file's name, and returns     // 'Yes' if the the file's name is valid, and returns 'No' otherwise.     // A file's name is considered to be valid if and only if all the following conditions      // are met:     // - There should not be more than three digits ('0'-'9') in the file's name.     // - The file's name contains exactly one dot '.'     // - The substring before the dot should not be empty, and it starts with a letter from      // the latin alphapet ('a'-'z' and 'A'-'Z').     // - The substring after the dot should be one of these: ['txt', 'exe', 'dll']     // Examples:     // >>> fileNameCheck(("example.txt"))     // ("Yes")     // >>> fileNameCheck(("1example.dll"))     // ("No")     public static String fileNameCheck(String file_name) {         // validate file name         String[] file_array = file_name.split("\\.");         if ((file_array.length == 1 || file_array.length > 2) ||             (file_array[1].length() > 3)) {             return "No";         } else {             String sub_name = file_array[0];             String[] dot_array = sub_name.split("\\.");             if (dot_array.length > 1) {                 if (dot_array[0].length() == 0 ||                      !(dot_array[0].charAt(0) >= 'a' && dot_array[0].charAt(0) <= 'z') ||                     !(dot_array[0].charAt(0) >= 'A' && dot_array[0].charAt(0) <= 'Z')) {                     return "No";                 } else if (dot_array[1].length() == 0) {                     return "No";                 } else {                     if (isValid(dot_array[1])) {                         return "Yes";                     } else {                         return "No";                     }                 }             } else {                 if (sub_name.length() == 0) {                     return "No";                 } else {                     if (isValid(file_array[1])) {                         return "Yes";                     } else {                         return "No";                     }                 }             }         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // triples_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are three distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)9l, (long)7l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean triplesSumToZero(ArrayList<Long> l) {         for (int i = 0; i < l.size(); i++) {             for (int j = i+1; j < l.size(); j++) {                 for (int k = j+1; k < l.size(); k++) {                     if (l.get(i) + l.get(j) + l.get(k) == 0) {                         return true;                     }                 }             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given two intervals,     // where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).     // The given intervals are closed which means that the interval (start, end)     // includes both start and end.     // For each given interval, it is assumed that its start is less or equal its end.     // Your task is to determine whether the length of intersection of these two      // intervals is a prime number.     // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)     // which its length is 1, which not a prime number.     // If the length of the intersection is a prime number, return "YES",     // otherwise, return "NO".     // If the two intervals don't intersect, return "NO".     // [input/output] samples:     // >>> intersection((Pair.with(1l, 2l)), (Pair.with(2l, 3l)))     // ("NO")     // >>> intersection((Pair.with(-1l, 1l)), (Pair.with(0l, 4l)))     // ("NO")     // >>> intersection((Pair.with(-3l, -1l)), (Pair.with(-5l, 5l)))     // ("YES")     public static String intersection(Pair<Long, Long> interval1, Pair<Long, Long> interval2) {                  long x1 = interval1.getValue1();         long y1 = interval1.getValue2();         long x2 = interval2.getValue1();         long y2 = interval2.getValue2();                  if(x1 < x2) {             if(x1 > y2) return "NO";         } else {             if(x2 > y1) return "NO";         }                  return isPrime(getIntervalLength(interval1, interval2));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string containing multiple groups of nested parentheses. Your goal is to     // separate those group into separate strings and return the array list of those.     // Separate groups are balanced (each open brace is properly closed) and not nested within each other     // Ignore any spaces in the input string.     // >>> separateParenGroups(("( ) (( )) (( )( ))"))     // (new ArrayList<String>(Arrays.asList((String)"()", (String)"(())", (String)"(()())")))     public static ArrayList<String> separateParenGroups(String paren_string) {         // Invalid inputs will lead to some combination of null and empty string in the result         ArrayList<String> results = new ArrayList<String>();         ArrayList<String> paren_chunks = new ArrayList<String>();         int paren_stack = 0;         for (char c : paren_string.toCharArray()) {             switch (c) {                 case '(':                     if (paren_stack == 0) {                         paren_chunks.add(new String());                     }                     paren_stack++;                     break;                 case ')':                     paren_stack--;                     if (paren_stack == 0) {                         results.add(paren_chunks.get(paren_chunks.size() - 1));                         paren_chunks.remove(paren_chunks.size() - 1);                     }                     break;                 default:                     if (paren_stack != 0) {                         paren_chunks.get(paren_chunks.size() - 1) += c;                     }                     break;             }         }         return results;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // I think we all remember that feeling when the result of some long-awaited     // event is finally known. The feelings and thoughts you have at that moment are     // definitely worth noting down and comparing.     // Your task is to determine if a person correctly guessed the results of a number of matches.     // You are given two array array lists of scores and guesses of equal length, where each index shows a match.      // Return an array array list of the same length denoting how far off each guess was. If they have guessed correctly,     // the value is 0, and if not, the value is the absolute difference between the guess and the score.     // example:     // >>> compare((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)2l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)3l, (long)3l)))     // >>> compare((new ArrayList<Long>(Arrays.asList((long)0l, (long)5l, (long)0l, (long)0l, (long)0l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)1l, (long)0l, (long)0l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l, (long)1l, (long)0l, (long)0l, (long)6l)))     public static ArrayList<Long> compare(ArrayList<Long> game, ArrayList<Long> guess) {         ArrayList<Long> correct = new ArrayList<>();         for (int i = 0; i < game.size(); i++) {             if (game.get(i).equals(guess.get(i))) {                 correct.add(0L);             } else {                 correct.add(Math.abs(guess.get(i) - game.get(i)));             }         }         return correct;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the count of the numbers of n-digit     // positive integers that start or end with 1.     public static long startsOneEnds(long n) {         long count = 0;         for (long i = 1; i < n; i++) {             String s = Long.toString(i);             if (s.startsWith("1") || s.endsWith("1")) {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns true if the last character     // of a given string is an alphabetical character and is not     // a part of a word, and false otherwise.     // Note: "word" is a group of characters separated by space.     // Examples:     // >>> checkIfLastCharIsALetter(("apple pie"))     // (false)     // >>> checkIfLastCharIsALetter(("apple pi e"))     // (true)     // >>> checkIfLastCharIsALetter(("apple pi e "))     // (false)     // >>> checkIfLastCharIsALetter((""))     // (false)     public static boolean checkIfLastCharIsALetter(String txt) {         String[] words = txt.split("\\s+");         String lastWord = words[words.length - 1];         char lastChar = lastWord.charAt(lastWord.length() - 1);         boolean result = false;         for(int i = 0; i < lastWord.length(); i++){             char currChar = lastWord.charAt(i);             if(Character.isLetter(currChar)){                 if(i == lastWord.length() - 1){                     result = true;                 }             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have to write a function which validates a given date string and     // returns true if the date is valid otherwise false.     // The date is valid if all of the following rules are satisfied:     // 1. The date string is not empty.     // 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.     // 3. The months should not be less than 1 or higher than 12.     // 4. The date should be in the format: mm-dd-yyyy     // >>> validDate(("03-11-2000"))     // (true)     // >>> validDate(("15-01-2012"))     // (false)     // >>> validDate(("04-0-2040"))     // (false)     // >>> validDate(("06-04-2020"))     // (true)     // >>> validDate(("06/04/2020"))     // (false)     public static boolean validDate(String date) {         String[] input = date.split("-");         // String[] months = {"01", "03", "05", "07", "08", "10", "12"};         String[] months = {"01", "03", "05", "07", "08", "10", "12"};         String[] months2 = {"04", "06", "09", "11"};         String[] months3 = {"02"};         String[] input1 = input[0].split("/");         String[] input2 = input[1].split("/");         String[] input3 = input[2].split("/");         if (date.length() == 0) {             return false;         }         if ((input1[0].equals(months3[0]) && (input2[0].equals(months2[3]) && input3[0].equals(months3[0])))) {             if ((Integer.parseInt(input2[1]) < 1 || Integer.parseInt(input2[1]) > 30) ||                     (Integer.parseInt(input3[1]) < 1 || Integer.parseInt(input3[1]) > 29) ||                     (Integer.parseInt(input1[1]) < 1 || Integer.parseInt(input1[1]) > 31) ||                     (Integer.parseInt(input2[0]) < 1 || Integer.parseInt(input2[0]) > 12) ||                     (Integer.parseInt(input3[0]) < 1 || Integer.parseInt(input3[0]) > 12) ||                     (Integer.parseInt(input1[0]) < 1 || Integer.parseInt(input1[0]) > 12)) {                 return false;             }         } else {             if ((Integer.parseInt(input2[0]) < 1 || Integer.parseInt(input2[0]) > 12) ||                     (Integer.parseInt(input1[0]) < 1 || Integer.parseInt(input1[0]) > 12) ||                     (Integer.parseInt(input3[0]) < 1 || Integer.parseInt(input3[0]) > 12)) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function count_nums which takes an array array list of integers and returns     // the number of elements which has a sum of digits > 0.     // If a number is negative, then its first signed digit will be negative:     // e.g. -123 has signed digits -1, 2, and 3.     // >>> countNums((new ArrayList<Long>(Arrays.asList())))     // (0l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)-1l, (long)11l, (long)-11l))))     // (1l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)2l))))     // (3l)     public static long countNums(ArrayList<Long> arr) {         long result = 0l;         long sum = 0l;         for (Long l : arr) {             sum = l;             while (sum > 0) {                 if (sum > 0) {                     sum = sum / 10;                     result++;                 } else {                     break;                 }             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns an ordered version of it.     // Ordered version of string, is a string where all words (separated by space)     // are replaced by a new word where all the characters arranged in     // ascending order based on ascii value.     // Note: You should keep the order of words and blank spaces in the sentence.     // For example:     // >>> antiShuffle(("Hi"))     // ("Hi")     // >>> antiShuffle(("hello"))     // ("ehllo")     // >>> antiShuffle(("Hello World!!!"))     // ("Hello !!!Wdlor")     public static String antiShuffle(String s) {         StringBuilder result = new StringBuilder();         for (String word : s.split(" ")) {             result.append(Arrays.stream(word.chars()).mapToObj(i -> (char)i).sorted().collect(Collectors.joining())).append(" ");         }         return result.toString().trim();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Checks if given string is a palindrome     // >>> isPalindrome((""))     // (true)     // >>> isPalindrome(("aba"))     // (true)     // >>> isPalindrome(("aaaaa"))     // (true)     // >>> isPalindrome(("zbcd"))     // (false)     public static boolean isPalindrome(String text) {         int len = text.length();         int left = 0;         int right = len - 1;         while (left < right) {             if (!(Character.toLowerCase(text.charAt(left)) == Character.toLowerCase(text.charAt(right)))) {                 return false;             }             left++;             right--;         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a word. Your task is to find the closest vowel that stands between      // two consonants from the right side of the word (case sensitive).     // Vowels in the beginning and ending doesn't count. Return empty string if you didn't     // find any vowel met the above condition.      // You may assume that the given string contains English letter only.     // Example:     // >>> getClosestVowel(("yogurt"))     // ("u")     // >>> getClosestVowel(("FULL"))     // ("U")     // >>> getClosestVowel(("quick"))     // ("")     // >>> getClosestVowel(("ab"))     // ("")     public static String getClosestVowel(String word) {         int i=0;         StringBuilder s=new StringBuilder(word);         s.reverse();         int index=0;         while(index<s.length()-2){             if(s.charAt(index)=='A'||s.charAt(index)=='E'||s.charAt(index)=='I'||s.charAt(index)=='O'||s.charAt(index)=='U'||s.charAt(index)=='a'||s.charAt(index)=='e'||s.charAt(index)=='i'||s.charAt(index)=='o'||s.charAt(index)=='u'){                 return s.charAt(index)+"";             }else{                 index++;             }         }         return "";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if a given number is prime, and false otherwise.     // >>> isPrime((6l))     // (false)     // >>> isPrime((101l))     // (true)     // >>> isPrime((11l))     // (true)     // >>> isPrime((13441l))     // (true)     // >>> isPrime((61l))     // (true)     // >>> isPrime((4l))     // (false)     // >>> isPrime((1l))     // (false)     public static boolean isPrime(long n) {         return PrimeUtil.isPrime(n);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to implement a function that will simplify the expression     // x * n. The function returns true if x * n evaluates to a whole number and false     // otherwise. Both x and n, are string representation of a fraction, and have the following format,     // <numerator>/<denominator> where both numerator and denominator are positive whole numbers.     // You can assume that x, and n are valid fractions, and do not have zero as denominator.     // >>> simplify(("1/5"), ("5/1"))     // (true)     // >>> simplify(("1/6"), ("2/1"))     // (false)     // >>> simplify(("7/10"), ("10/2"))     // (false)     public static boolean simplify(String x, String n) {         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have been tasked to write a function that receives      // a hexadecimal number as a string and counts the number of hexadecimal      // digits that are primes (prime number, or a prime, is a natural number      // greater than 1 that is not a product of two smaller natural numbers).     // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.     // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...     // So you have to determine a number of the following digits: 2, 3, 5, 7,      // B (=decimal 11), D (=decimal 13).     // Note: you may assume the input is always correct or empty string,      // and symbols A,B,C,D,E,F are always uppercase.     // Examples:     // >>> hexKey(("AB"))     // (1l)     // >>> hexKey(("1077E"))     // (2l)     // >>> hexKey(("ABED1A33"))     // (4l)     // >>> hexKey(("123456789ABCDEF0"))     // (6l)     // >>> hexKey(("2020"))     // (2l)     public static long hexKey(String num) {         long sum = 0;         for (int i = 0; i < num.length(); i++) {             if ((num.charAt(i) == '2') || (num.charAt(i) == '3') || (num.charAt(i) == '5')                     || (num.charAt(i) == '7') || (num.charAt(i) == 'B') || (num.charAt(i) == 'D')) {                 sum++;             }         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string representing a sentence,     // the sentence contains some words separated by a space,     // and you have to return a string that contains the words from the original sentence,     // whose lengths are prime numbers,     // the order of the words in the new string should be the same as the original one.     // Example 1:     // >>> wordsInSentence(("This is a test"))     // ("is")     // Example 2:     // >>> wordsInSentence(("lets go for swimming"))     // ("go for")     // Constraints:     // * 1 <= len(sentence) <= 100     // * sentence contains only letters     public static String wordsInSentence(String sentence) {         if(sentence.length() < 2) return "";         String[] words = sentence.split(" ");         List<String> wordsPrime = words.stream().filter(word -> isPrime(word.length())).toList();         StringBuilder sb = new StringBuilder();         Iterator<String> it = wordsPrime.iterator();         while(it.hasNext()) {             sb.append(it.next());             sb.append(" ");         }         sb.deleteCharAt(sb.length() - 1);         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string representing a space separated lowercase letters, return a hash map     // of the letter with the most repetition and containing the corresponding count.     // If several letters have the same occurrence, return all of them.     // Example:     // >>> histogram(("a b c"))     // (new HashMap<String,Long>(Map.of("a", 1l, "b", 1l, "c", 1l)))     // >>> histogram(("a b b a"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("a b c a b"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("b b b b a"))     // (new HashMap<String,Long>(Map.of("b", 4l)))     // >>> histogram((""))     // (new HashMap<String,Long>())     public static HashMap<String,Long> histogram(String test) {         HashMap<String,Long> histo = new HashMap<String,Long>();         if (test.isEmpty()) {             return new HashMap<String,Long>();         }         String[] split = test.split(" ");         String[] array = new String[split.length];         for (int i = 0; i < array.length; i++) {             array[i] = split[i];         }         return new HashMap<String,Long>(map(array));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a 2 dimensional data, as a nested array lists,     // which is similar to matrix, however, unlike matrices,     // each row may contain a different number of columns.     // Given lst, and integer x, find integers x in the array list,     // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that     // each pair is a coordinate - (row, columns), starting with 0.     // Sort coordinates initially by rows in ascending order.     // Also, sort coordinates of the row by columns in descending order.     // Examples:     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList()))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))     public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {         List<Integer> rn = new ArrayList<Integer>();         for (int i = 0; i < lst.size(); i++) {             if (lst.get(i).contains(x)) {                 rn.add(i);             }         }         List<Integer> cn = new ArrayList<Integer>();         for (int i = 0; i < lst.size(); i++) {             for (int j = lst.get(i).size() - 1; j >= 0; j--) {                 if (lst.get(i).get(j) == x) {                     cn.add(j);                 }             }         }         List<Pair<Long, Long>> p = new ArrayList<Pair<Long, Long>>();         for (int i = 0; i < rn.size(); i++) {             p.add(new Pair<Long, Long>(rn.get(i), cn.get(i)));         }         Collections.sort(p, new Comparator<Pair<Long, Long>>() {              @Override             public int compare(Pair<Long
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a sorted array list that has the odd numbers in collatz sequence.     // The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined     // as follows: start with any positive integer n. Then each term is obtained from the      // previous term as follows: if the previous term is even, the next term is one half of      // the previous term. If the previous term is odd, the next term is 3 times the previous     // term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.     // Note:      // 1. Collatz(1) is [1].     // 2. returned array list sorted in increasing order.     // For example:     // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.     // >>> getOddCollatz((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l)))     public static ArrayList<Long> getOddCollatz(long n) {         ArrayList<Long> result = new ArrayList<Long>();         while (n > 1) {             result.add(n);             if (n % 2 == 0) {                 n = n / 2;             } else {                 n = 3 * n + 1;             }         }         Collections.sort(result);         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which returns the largest index of an element which     // is not greater than or equal to the element immediately preceding it. If     // no such element exists then return -1. The given array array list will not contain     // duplicate values.     // Examples:     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)3l, (long)5l))))     // (3l)     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (-1l)     public static long canArrange(ArrayList<Long> arr) {         if (arr.size() == 0) return -1;         Collections.sort(arr);         long[] arrV = new long[arr.size()];         for (int i = 0; i < arr.size(); i++) arrV[i] = arr.get(i);         return canArrange(arrV);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input is a space-delimited string of numberals from 'zero' to 'nine'.     // Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.     // Return the string with numbers sorted from smallest to largest     // >>> sortNumbers(("three one five"))     // ("one three five")     public static String sortNumbers(String numbers) {         // you fill in here
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Circular shift the digits of the integer x, shift the digits right by shift     // and return the result as a string.     // If shift > number of digits, return digits reversed.     // >>> circularShift((12l), (1l))     // ("21")     // >>> circularShift((12l), (2l))     // ("12")     public static String circularShift(long x, long shift) {         long res = x;         if (shift > 0) {             res = (res % (Math.pow(10, shift))) + (res / Math.pow(10, shift));         }         return String.valueOf(res);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "     // This function will take an array array list of integers. For all entries in the array list, the function shall square the integer entry if its index is a      // multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not      // change the entries in the array list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.      // Examples:     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList())     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)-1l, (long)-5l, (long)2l, (long)-1l, (long)-5l))     public static long sumSquares(ArrayList<Long> lst) {         for(int i = 0; i < lst.size(); i++) {             if (i % 3 == 0) {                 lst.set(i, lst.get(i) * lst.get(i));             }             if (i % 4 == 0) {                 lst.set(i, lst.get(i) * lst.get(i) * lst.get(i));             }         }          long sum = 0;         for(long i : lst) {             sum += i;         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // You need to find the largest prime value and return the sum of its digits.     // Examples:     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)3l, (long)2l, (long)1l, (long)3l, (long)5l, (long)7l, (long)4l, (long)5l, (long)5l, (long)5l, (long)2l, (long)181l, (long)32l, (long)4l, (long)32l, (long)3l, (long)2l, (long)32l, (long)324l, (long)4l, (long)3l))))     // (10l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)1l, (long)8l, (long)2l, (long)4597l, (long)2l, (long)1l, (long)3l, (long)40l, (long)1l, (long)2l, (long)1l, (long)2l, (long)4l, (long)2l, (long)5l, (long)1l))))     // (25l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)1l, (long)32l, (long)5107l, (long)34l, (long)83278l, (long)109l, (long)163l, (long)23l, (long)2323l, (long)32l, (long)30l, (long)1l, (long)9l, (long)3l))))     // (13l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)724l, (long)32l, (long)71l, (long)99l, (long)32l, (long)6l, (long)0l, (long)5l, (long)91l, (long)83l, (long)0l, (long)5l, (long)6l))))     // (11l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)81l, (long)12l, (long)3l, (long)1l, (long)21l))))     // (3l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)8l, (long)1l, (long)2l, (long)1l, (long)7l))))     // (7l)     public static long skjkasdkd(ArrayList<Long> lst) {         // find the largest prime value         long maxPrime = 0;         for (Long l : lst) {             maxPrime = Math.max(maxPrime, l.longValue());         }         // prime numbers are greater than 1         if (maxPrime == 1) {             return 1;         }         // get the sum of the digits of the largest prime value         long sum = 0;         while (maxPrime > 0) {             sum += maxPrime % 10;             maxPrime = maxPrime / 10;         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of integers, return a pair consisting of a sum and a product of all the integers in an array array list.     // Empty sum should be equal to 0 and empty product should be equal to 1.     // >>> sumProduct((new ArrayList<Long>(Arrays.asList())))     // (Pair.with(0l, 1l))     // >>> sumProduct((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (Pair.with(10l, 24l))     public static Pair<Long, Long> sumProduct(ArrayList<Long> numbers) {         if(numbers.size() == 0){             return new Pair<Long, Long>(0L, 1L);         }         long sum = 0;         long product = 1;         for(int i=0; i<numbers.size(); i++){             sum += numbers.get(i);             product *= numbers.get(i);         }         return new Pair<Long, Long>(sum, product);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes two positive numbers x and y and returns the     // biggest even integer number that is in the range [x, y] inclusive. If      // there's no such number, then the function should return -1.     // For example:     // >>> chooseNum((12l), (15l))     // (14l)     // >>> chooseNum((13l), (12l))     // (-1l)     public static long chooseNum(long x, long y) {         // your code here
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns a pair (a, b), where 'a' is     // the largest of negative integers, and 'b' is the smallest     // of positive integers in an array array list.     // If there is no negative or positive integers, return them as null.     // Examples:     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l, (long)7l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(1l))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList())))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     public static Pair<Optional<Long>, Optional<Long>> largestSmallestIntegers(ArrayList<Long> lst) {         if(lst.size()==0)             return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));         List<Long> negative = new ArrayList<>();         List<Long> positive = new ArrayList<>();         for(Long i: lst)             if(i<0)                 negative.add(i);             else                 positive.add(i);         if(positive.size()==0)             return Pair.with(Optional.of(Optional.empty()), Optional.of(negative.get(negative.size()-1)));         else if(negative.size()==0)             return Pair.with(Optional.of(positive.get(0)), Optional.of(Optional.empty()));         else{             long min = positive.get(0);             long max = negative.get(negative.size()-1);             for(int i = 1; i<positive.size(); i++)                 if(positive.get(i) < min)                     min = positive.get(i);             for(int i = negative.size()-2; i>=0; i--)                 if(negative.get(i) > max)                     max = negative.get(i);             return Pair.with(Optional.of(min), Optional.of(max));         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string, find out how many distinct characters (regardless of case) does it consist of     // >>> countDistinctCharacters(("xyzXYZ"))     // (3l)     // >>> countDistinctCharacters(("Jerry"))     // (4l)     public static long countDistinctCharacters(String string) {         HashSet<Character> charSet = new HashSet<>();         for (char c : string.toCharArray()) {             charSet.add(c);         }         return charSet.size();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, you have to make a pile of n levels of stones.     // The first level has n stones.     // The number of stones in the next level is:     // - the next odd number if n is odd.     // - the next even number if n is even.     // Return the number of stones in each level in an array array list, where element at index     // i represents the number of stones in the level (i+1).     // Examples:     // >>> makeAPile((3l))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)7l)))     public static ArrayList<Long> makeAPile(long n) {         ArrayList<Long> result = new ArrayList<>(n);         for (long i = 0; i < n; i++) {             result.add(((n - i) % 2 == 0) ? n - i : n - i + 1);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list arr of integers and you need to return     // sum of magnitudes of integers multiplied by product of all signs     // of each number in the array array list, represented by 1, -1 or 0.     // Note: return null for empty arr.     // Example:     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)-4l))))     // Optional.of(9l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l))))     // Optional.of(0l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     public static Optional<Long> prodSigns(ArrayList<Long> arr) {         if (arr.size() == 0) return Optional.empty();         int sign = 1;         long total = 0;         long prod = 1;         for (long i : arr) {             total += sign * i;             prod *= sign;             sign = -sign;         }         return Optional.of(prod * total);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers nums, find the minimum sum of any non-empty sub-array array list     // of nums.     // Example     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l, (long)1l, (long)2l, (long)4l))))     // (1l)     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l))))     // (-6l)     public static long minSubArraySum(ArrayList<Long> nums) {         int start = 0, end = 0, min = 0, sum = 0, minSum = 0;         int size = nums.size();         while (end < size) {             while (sum > 0 && end < size) {                 sum += nums.get(end);                 end++;             }             minSum += sum;             while (sum < 0 && start < size) {                 sum += nums.get(start);                 start++;             }             minSum += sum;             if (minSum < min)                 min = minSum;             sum = 0;             start++;             end++;         }         return min;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a string containing space-delimited numbers starting from 0 upto n inclusive.     // >>> stringSequence((0l))     // ("0")     // >>> stringSequence((5l))     // ("0 1 2 3 4 5")     public static String stringSequence(long n) {         StringBuffer sb = new StringBuffer();         for (long i = 0; i <= n; i++) {             sb.append(i).append(" ");         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word     // >>> cycpatternCheck(("abcd"), ("abd"))     // (false)     // >>> cycpatternCheck(("hello"), ("ell"))     // (true)     // >>> cycpatternCheck(("whassup"), ("psus"))     // (false)     // >>> cycpatternCheck(("abab"), ("baa"))     // (true)     // >>> cycpatternCheck(("efef"), ("eeff"))     // (false)     // >>> cycpatternCheck(("himenss"), ("simen"))     // (true)     public static boolean cycpatternCheck(String a, String b) {         //List<String> l1 = new ArrayList<>();         //List<String> l2 = new ArrayList<>();         //for(int i = 0; i < b.length()-1; i++) {         //    String temp = b.substring(i, b.length()-1);         //    if(temp.equals(b)) {         //        return true;         //    }         //    l1.add(temp);         //}         //for(int i = 0; i < a.length()-1; i++) {         //    String temp = a.substring(i, a.length()-1);         //    for(int j = 0; j < l1.size(); j++) {         //        if(temp.equals(l1.get(j))) {         //            return true;         //        }         //    }         //}         //return false;         return (a.contains(b) || a.contains(b.substring(1))) && (a.contains(b.substring(1)) || a.contains(b.substring(2)));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true is array list elements are monotonically increasing or decreasing.     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)20l))))     // (true)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))))     // (false)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)0l, (long)-10l))))     // (true)     public static boolean monotonic(ArrayList<Long> l) {         return l.stream().reduce((a, b) -> a < b ? -1 : a > b ? 1 : 0)                 .getAsInt() < 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Out of array list of strings, return the longest one. Return the first one in case of multiple     // strings of the same length. Return null in case the input array list is empty.     // >>> longest((new ArrayList<String>(Arrays.asList())))     // Optional.empty()     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // Optional.of("a")     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"bb", (String)"ccc"))))     // Optional.of("ccc")     public static Optional<String> longest(ArrayList<String> strings) {         // TODO: Implement this method         return null;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if all numbers in the array list l are below threshold t.     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)10l))), (100l))     // (true)     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))), (5l))     // (false)     public static boolean belowThreshold(ArrayList<Long> l, long t) {         for (long i : l) {             if (i >= t) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the given number is the multiplication of 3 prime numbers     // and false otherwise.     // Knowing that (a) is less then 100.      // Example:     // >>> isMultiplyPrime((30l))     // (true)     // 30 = 2 * 3 * 5     public static boolean isMultiplyPrime(long a) {         // Can't use set because hashing.         Set<Long> set = new HashSet<Long>();         for (long i=2;i<=Math.sqrt(a);i++) {             if (a%i==0) {                 set.add(i);                 set.add(a/i);             }         }         // If a can't be divided by the numbers in the set, then a is not a multiplication of 3 prime numbers.         return set.size() == 2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return only positive numbers in the array list.     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)-1l, (long)2l, (long)-4l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)6l)))     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)3l, (long)9l, (long)123l, (long)1l)))     public static ArrayList<Long> getPositive(ArrayList<Long> l) {         // TODO Auto-generated method stub         ArrayList<Long> r = new ArrayList<>();         for (Long c : l) {             if (c > 0) {                 r.add(c);             }         }         return r;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal     // to the values of the corresponding indicies of l, but sorted.     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)5l)))     public static ArrayList<Long> sortThird(ArrayList<Long> l) {         ArrayList<Long> l1 = new ArrayList<Long>();         for (int i = 0; i < l.size(); i++) {             if (i % 3 != 0) {                 l1.add(l.get(i));             }         }         for (int i = 0; i < l.size(); i++) {             if (i % 3 == 0) {                 l1.add(l.get(i));             }         }         return l1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.     // For each of the group, output the deepest level of nesting of parentheses.     // E.g. (()()) has maximum two levels of nesting while ((())) has three.     // >>> parseNestedParens(("(()()) ((())) () ((())()())"))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))     public static ArrayList<Long> parseNestedParens(String paren_string) {         // TODO: Fill in this method.         ArrayList<Long> paren_list = new ArrayList<Long>();         int i = 0;         Stack<Character> stack = new Stack<Character>();         int max = -1;         int curr = 0;         while (i < paren_string.length()) {             if (paren_string.charAt(i) == '(') {                 stack.push('(');                 curr++;                 if (curr > max) {                     max = curr;                 }             } else {                 stack.pop();                 curr--;             }             i++;         }         for (int j = 0; j < max; j++) {             paren_list.add(1l);         }         return paren_list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given length of a side and high return area for a triangle.     // >>> triangleArea((5l), (3l))     // (7.5f)     public static float triangleArea(long a, long h) {         float b = (float) (a * h) / 2;         return b;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Complete the function that takes two integers and returns      // the product of their unit digits.     // Assume the input is always valid.     // Examples:     // >>> multiply((148l), (412l))     // (16l)     // >>> multiply((19l), (28l))     // (72l)     // >>> multiply((2020l), (1851l))     // (0l)     // >>> multiply((14l), (-15l))     // (20l)     public static long multiply(long a, long b) {                  long z;         z=a;         a=a%10;         while(a>0){             z=z*10+a;             a=z/10;         }         b=b%10;         while(b>0){             z=z*10+b;             b=z/10;         }         return z;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of input numbers, calculate Mean Absolute Deviation     // around the mean of this dataset.     // Mean Absolute Deviation is the average absolute difference between each     // element and a centerpoint (mean in this case):     // MAD = average | x - x_mean |     // >>> meanAbsoluteDeviation((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f))))     // (1.0f)     public static float meanAbsoluteDeviation(ArrayList<Float> numbers) {         float mean = 0;         for (Float num : numbers) {             mean += num;         }         mean /= numbers.size();         float mad = 0;         for (Float num : numbers) {             mad += Math.abs(num - mean);         }         mad /= numbers.size();         return mad;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique common elements for two array lists.     // >>> common((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l, (long)34l, (long)653l, (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)1l, (long)5l, (long)9l, (long)653l, (long)121l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)653l)))     // >>> common((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     public static ArrayList<Long> common(ArrayList<Long> l1, ArrayList<Long> l2) {         ArrayList<Long> result = new ArrayList<>();         if (l1.size() == 0 || l2.size() == 0) {             return result;         }         int[] first = new int[l1.size()];         int[] second = new int[l2.size()];         for (int i = 0; i < l1.size(); i++) {             first[i] = l1.get(i);         }         for (int i = 0; i < l2.size(); i++) {             second[i] = l2.get(i);         }         Arrays.sort(first);         Arrays.sort(second);         int i = 0;         int j = 0;         while (i < l1.size() && j < l2.size()) {             if (first[i] == second[j]) {                 result.add(first[i]);                 i++;                 j++;             } else if (first[i] > second[j]) {                 j++;             } else {                 i++;             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer, obtain its roman numeral equivalent as a string,     // and return it in lowercase.     // Restrictions: 1 <= num <= 1000     // Examples:     // >>> intToMiniRoman((19l))     // ("xix")     // >>> intToMiniRoman((152l))     // ("clii")     // >>> intToMiniRoman((426l))     // ("cdxxvi")     public static String intToMiniRoman(long number) {         String[] miniRoman = {"i", "x", "c", "m"};         String[] miniRomanVal = {"1", "10", "100", "1000"};         List<String> list = new ArrayList<>();         long current;         int index = 0;         while (number > 0) {             current = number % 10;             list.add(miniRoman[index]);             number = number / 10;             if (current > 5) {                 list.add(miniRoman[index + 1]);                 current = current - 5;             }             for (int i = 0; i < current; i++) {                 list.add(miniRoman[index]);             }             index++;         }         Collections.reverse(list);         return String.join("", list);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this task, you will be given a string that represents a number of apples and oranges      // that are distributed in a basket of fruit this basket contains      // apples, oranges, and mango fruits. Given the string that represents the total number of      // the oranges and apples and an integer that represent the total number of the fruits      // in the basket return the number of the mango fruits in the basket.     // for examble:     // >>> fruitDistribution(("5 apples and 6 oranges"), (19l))     // (8l)     // >>> fruitDistribution(("0 apples and 1 oranges"), (3l))     // (2l)     // >>> fruitDistribution(("2 apples and 3 oranges"), (100l))     // (95l)     // >>> fruitDistribution(("100 apples and 1 oranges"), (120l))     // (19l)     public static long fruitDistribution(String s, long n) {         // write your code here         long total = 0;         long[] mango = new long[1];         for (long i = 0; i < s.length(); i++) {             long j = 0;             if (s.charAt(i) == 'a' || s.charAt(i) == 'e' || s.charAt(i) == 'i' || s.charAt(i) == 'o' || s.charAt(i) == 'u') {                 while (i + 1 < s.length() && s.charAt(i + 1) == ' ') {                     i++;                 }                 j = Long.parseLong(s.substring(i, i + 4));                 i += 4;                 while (i + 1 < s.length() && s.charAt(i + 1) == ' ') {                     i++;                 }                 if (j < 0) {                     break;                 } else {                     total += j;                 }             } else {                 while (i + 1 < s.length() && s.charAt(i + 1) == ' ') {                     i++;                 }                 j = Long.parseLong(s.substring(i, i + 4));                 i += 4;                 while (i + 1 < s.length() && s.charAt(i + 1) == ' ') {                     i++;                 }                 if (j < 0) {                     break;                 } else {                     total += j;                 }             }         }         if (total < n) {             return (n - total);         } else {             return 0;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c     // then check if the result string is palindrome.     // A string is called palindrome if it reads the same backward as forward.     // You should return a pair containing the result string and true/false for the check.     // Example     // >>> reverseDelete(("abcde"), ("ae"))     // (Pair.with("bcd", false))     // >>> reverseDelete(("abcdef"), ("b"))     // (Pair.with("acdef", false))     // >>> reverseDelete(("abcdedcba"), ("ab"))     // (Pair.with("cdedc", true))     public static Pair<String, Boolean> reverseDelete(String s, String c) {         StringBuilder stringBuilder = new StringBuilder(s);         return new Pair<>(stringBuilder.delete(stringBuilder.indexOf(c), stringBuilder.indexOf(c) + c.length()).toString(), new StringBuilder(stringBuilder.delete(stringBuilder.indexOf(c), stringBuilder.indexOf(c) + c.length()).toString()).reverse().toString().equals(stringBuilder.delete(stringBuilder.indexOf(c), stringBuilder.indexOf(c) + c.length()).toString()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a greatest common divisor of two integers a and b     // >>> greatestCommonDivisor((3l), (5l))     // (1l)     // >>> greatestCommonDivisor((25l), (15l))     // (5l)     public static long greatestCommonDivisor(long a, long b) {         return a*b/gcd(a,b);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this Kata, you have to sort an array array list of non-negative integers according to     // number of ones in their binary representation in ascending order.     // For similar number of ones, sort based on decimal value.     // It must be implemented like this:     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)-2l, (long)-3l, (long)-4l, (long)-5l, (long)-6l))))     // (new ArrayList<Long>(Arrays.asList((long)-6l, (long)-5l, (long)-4l, (long)-3l, (long)-2l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l)))     public static ArrayList<Long> sortArray(ArrayList<Long> arr) {         // #1. sort based on the number of 1s in their binary representation         Collections.sort(arr, new Comparator<Long>() {             @Override             public int compare(Long o1, Long o2) {                 return Long.bitCount(o1) - Long.bitCount(o2);             }         });         // #2. sort based on the decimal representation         Collections.sort(arr);         return arr;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Concatenate array list of strings into a single string     // >>> concatenate((new ArrayList<String>(Arrays.asList())))     // ("")     // >>> concatenate((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // ("abc")     public static String concatenate(ArrayList<String> strings) {         StringBuilder sb = new StringBuilder("");         for (String s : strings) {             sb.append(s);         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings as a parameter,     // deletes the strings that have odd lengths from it,     // and returns the resulted array list with a sorted order,     // The array list is always an array array list of strings and never an array array list of numbers,     // and it may contain duplicates.     // The order of the array list should be ascending by length of each word, and you     // should return the array list sorted by that rule.     // If two words have the same length, sort the array list alphabetically.     // The function should return an array array list of strings in sorted order.     // You may assume that all words will have the same length.     // For example:     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"aa", (String)"a", (String)"aaa"))))     // (new ArrayList<String>(Arrays.asList((String)"aa")))     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"ab", (String)"a", (String)"aaa", (String)"cd"))))     // (new ArrayList<String>(Arrays.asList((String)"ab", (String)"cd")))     public static ArrayList<String> sortedListSum(ArrayList<String> lst) {         ArrayList<Integer> l = new ArrayList<Integer>();         for(int i=0; i<lst.size(); i++){             l.add(lst.get(i).length());         }         Collections.sort(l, new Comparator<Integer>() {             public int compare(Integer x, Integer y) {                 if(x == y) return 0;                 else if(x > y) return 1;                 else return -1;             }         });         ArrayList<String> l2 = new ArrayList<String>();         for(int i=0; i<lst.size(); i++){             l2.add(lst.get(i));         }         Collections.sort(l2, new Comparator<String>() {             public int compare(String x, String y) {                 if(x.length() == y.length()) return x.compareTo(y);                 else return x.length() - y.length();             }         });         return l2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that contain given substring     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"array")))     public static ArrayList<String> filterBySubstring(ArrayList<String> strings, String substring) {         ArrayList<String> filtered = new ArrayList<String>();         for (String string : strings) {             if (string.contains(substring)) {                 filtered.add(string);             }         }         return filtered;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a value (string) representing a number     // and returns the closest integer to it. If the number is equidistant     // from two integers, round it away from zero.     // Examples     // >>> closestInteger(("10"))     // (10l)     // >>> closestInteger(("15.3"))     // (15l)     // Note:     // Rounding away from zero means that if the given number is equidistant     // from two integers, the one you should return is the one that is the     // farthest from zero. For example closest_integer("14.5") should     // return 15 and closest_integer("-14.5") should return -15.     public static long closestInteger(String value) {         long num = Long.parseLong(value);         int newNum = 0;         if(num < 0) {             newNum = -(Math.round(-num/2) * 2);         } else {             newNum = Math.round(num/2) * 2;         }         return newNum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function vowels_count which takes a string representing     // a word as input and returns the number of vowels in the string.     // Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a     // vowel, but only when it is at the end of the given word.     // Example:     // >>> vowelsCount(("abcde"))     // (2l)     // >>> vowelsCount(("ACEDY"))     // (3l)     public static long vowelsCount(String s) {         return (long) s.chars().filter(c -> (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y' && c == s.charAt(s.length()-1))).count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings.     // The array list contains different words. Return the word with maximum number     // of unique characters. If multiple strings have maximum number of unique     // characters, return the one which comes first in lexicographical order.     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"of", (String)"string"))))     // ("string")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"enam", (String)"game"))))     // ("enam")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"aaaaaaa", (String)"bb", (String)"cc"))))     // ("aaaaaaa")     public static String findMax(ArrayList<String> words) {         return null;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string 'text', return its md5 hash equivalent string.     // If 'text' is an empty string, return null.     // >>> stringToMd5(("Hello world"))     // Optional.of("3e25960a79dbc69b674cd4ec67a72c62")     public static Optional<String> stringToMd5(String text) {         // 1. Check if empty         if (text.isEmpty()) return Optional.empty();          // 2. Hash the input String         return Optional.of(text.hashCode() + "");
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Change numerical base of input number x to base.     // return string representation after the conversion.     // base numbers are less than 10.     // >>> changeBase((8l), (3l))     // ("22")     // >>> changeBase((8l), (2l))     // ("1000")     // >>> changeBase((7l), (2l))     // ("111")     public static String changeBase(long x, long base) {         StringBuilder sb = new StringBuilder();         while (x > 0) {             int digit = (int) (x % base);             sb.insert(0, digit);             x /= base;         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return true if the three     // sides form a right-angled triangle, false otherwise.     // A right-angled triangle is a triangle in which one angle is right angle or      // 90 degree.     // Example:     // >>> rightAngleTriangle((3l), (4l), (5l))     // (true)     // >>> rightAngleTriangle((1l), (2l), (3l))     // (false)     public static boolean rightAngleTriangle(long a, long b, long c) {         return a * a + b * b == c * c || b * b + c * c == a * a || a * a + c * c == b * b;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // It is the last week of the semester and the teacher has to give the grades     // to students. The teacher has been making her own algorithm for grading.     // The only problem is, she has lost the code she used for grading.     // She has given you an array array list of GPAs for some students and you have to write      // a function that can output an array array list of letter grades using the following table:     // GPA       |    Letter grade     // 4.0                A+     // > 3.7                A      // > 3.3                A-      // > 3.0                B+     // > 2.7                B      // > 2.3                B-     // > 2.0                C+     // > 1.7                C     // > 1.3                C-     // > 1.0                D+      // > 0.7                D      // > 0.0                D-     // 0.0                E     // Example:     // >>> gradeEquation((new ArrayList<Float>(Arrays.asList((float)4.0f, (float)3l, (float)1.7f, (float)2l, (float)3.5f))))     // (new ArrayList<String>(Arrays.asList((String)"A+", (String)"B", (String)"C-", (String)"C", (String)"A-")))     public static ArrayList<String> numericalLetterGrade(ArrayList<Float> grades) {         ArrayList<String> ret = new ArrayList<String>();         float grad = 0.0f;         for (float f : grades) {             grad = f;             if (grad >= 4.0f) {                 ret.add("A+");             } else if (grad > 3.7f) {                 ret.add("A");             } else if (grad > 3.3f) {                 ret.add("A-");             } else if (grad > 3.0f) {                 ret.add("B+");             } else if (grad > 2.7f) {                 ret.add("B");             } else if (grad > 2.3f) {                 ret.add("B-");             } else if (grad > 2.0f) {                 ret.add("C+");             } else if (grad > 1.7f) {                 ret.add("C");             } else if (grad > 1.3f) {                 ret.add("C-");             } else if (grad > 1.0f) {                 ret.add("D+");             } else if (grad > 0.7f) {                 ret.add("D");             } else if (grad > 0.0f) {                 ret.add("D-");             } else {                 ret.add("E");             }         }         return ret;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Insert a number 'delimeter' between every two consecutive elements of input array list `numbers'     // >>> intersperse((new ArrayList<Long>(Arrays.asList())), (4l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> intersperse((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))), (4l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)4l, (long)3l)))     public static ArrayList<Long> intersperse(ArrayList<Long> numbers, long delimeter) {         ArrayList<Long> list = new ArrayList<Long>(numbers);         if (list.size() <= 1)             return list;         for (int i = 1; i < list.size(); i++) {             list.add(i, delimeter);         }         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an array array list of numbers as input and returns      // the number of elements in the array array list that are greater than 10 and both      // first and last digits of a number are odd (1, 3, 5, 7, 9).     // For example:     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)15l, (long)-73l, (long)14l, (long)-15l))))     // (1l)     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)33l, (long)-2l, (long)-3l, (long)45l, (long)21l, (long)109l))))     // (2l)     public static long specialFilter(ArrayList<Long> nums) {         return (nums.stream().filter(n -> n > 10).filter(n -> n%2!=0 && ((n/10)%2!=0)).count());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // sum_to_n is a function that sums numbers from 1 to n.     // >>> sumToN((30l))     // (465l)     // >>> sumToN((100l))     // (5050l)     // >>> sumToN((5l))     // (15l)     // >>> sumToN((10l))     // (55l)     // >>> sumToN((1l))     // (1l)     public static long sumToN(long n) {         long sum = 0;         for (long i = 1; i <= n; i++) {             sum += i;         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From an array array list of integers, remove all elements that occur more than once.     // Keep order of elements left the same as in the input.     // >>> removeDuplicates((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)4l)))     public static ArrayList<Long> removeDuplicates(ArrayList<Long> numbers) {         return numbers.stream()                 .collect(Collectors.toSet())                 .stream()                 .sorted((Long a, Long b) -> a.compareTo(b))                 .map(Object::get)                 .collect(Collectors.toList());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two positive integers a and b, return the even digits between a     // and b, in ascending order.     // For example:     // >>> generateIntegers((2l), (8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((8l), (2l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((10l), (14l))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> generateIntegers(long a, long b) {         ArrayList<Long> list = new ArrayList<>();         if (b < a) {             return list;         }         for (long i = a; i <= b; i++) {             list.add(i);         }         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a given array list of integers, generate an array array list of rolling maximum element found until given moment     // in the sequence.     // >>> rollingMax((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)3l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l)))     public static ArrayList<Long> rollingMax(ArrayList<Long> numbers) {         ArrayList<Long> results = new ArrayList<>();         long max = 0;         for (int i = 0; i < numbers.size(); i++) {             if (max < numbers.get(i)) {                 max = numbers.get(i);             }             results.add(max);         }         return results;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're given an array array list of deposit and withdrawal operations on a bank account that starts with     // zero balance. Your task is to detect if at any point the balance of account fallls below zero, and     // at that point function should return true. Otherwise it should return false.     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (false)     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)-4l, (long)5l))))     // (true)     public static boolean belowZero(ArrayList<Long> operations) {         if (operations.get(0).equals(0)){             return false;         } else {             long prev = operations.get(0);             for (int i = 1; i < operations.size(); i++){                 long curr = operations.get(i);                 if (prev + curr < 0){                     return true;                 } else {                     prev = curr;                 }             }             return false;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a non-empty array list of positive integers. Return the greatest integer that is greater than      // zero, and has a frequency greater than or equal to the value of the integer itself.      // The frequency of an integer is the number of times it appears in the array list.     // If no such a value exist, return -1.     // Examples:     // >>> search((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)2l, (long)2l, (long)3l, (long)1l))))     // (2l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l, (long)4l))))     // (3l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)4l, (long)4l, (long)4l))))     // (-1l)     public static long search(ArrayList<Long> lst) {         long res = -1;         for (Long l : lst) {             int freq = Collections.frequency(lst, l);             if (l > 0 && freq >= l) {                 res = l;                 break;             }         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "(" and ")".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("("))     // (false)     // >>> correctBracketing(("()"))     // (true)     // >>> correctBracketing(("(()())"))     // (true)     // >>> correctBracketing((")(()"))     // (false)     public static boolean correctBracketing(String brackets) {         int openingBrackets = 0;         for (int i = 0; i < brackets.length(); i++) {             if (brackets.charAt(i) == '(') {                 openingBrackets++;             } else if (brackets.charAt(i) == ')') {                 if (openingBrackets > 0) openingBrackets--;                 else return false;             }         }         return openingBrackets == 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the odd indicies, while its values at the even indicies are equal     // to the values of the even indicies of l, but sorted.     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)6l, (long)5l, (long)4l)))     public static ArrayList<Long> sortEven(ArrayList<Long> l) {         ArrayList<Long> l2 = new ArrayList<>();         Iterator<Long> it = l.iterator();         while (it.hasNext()) {             if (it.hasNext()) {                 if (it.next() % 2 != 0) {                     l2.add(it.next());                     it.remove();                 }             }         }         Collections.sort(l);         return l2.addAll(l);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if two words have the same characters.     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddeddabc"))     // (true)     // >>> sameChars(("abcd"), ("dddddddabc"))     // (true)     // >>> sameChars(("dddddddabc"), ("abcd"))     // (true)     // >>> sameChars(("eabcd"), ("dddddddabc"))     // (false)     // >>> sameChars(("abcd"), ("dddddddabce"))     // (false)     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddddabc"))     // (false)     public static boolean sameChars(String s0, String s1) {         // return true;         char[] a0 = s0.toCharArray();         char[] a1 = s1.toCharArray();         Arrays.sort(a0);         Arrays.sort(a1);         return Arrays.equals(a0, a1);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "<" and ">".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("<"))     // (false)     // >>> correctBracketing(("<>"))     // (true)     // >>> correctBracketing(("<<><>>"))     // (true)     // >>> correctBracketing(("><<>"))     // (false)     public static boolean correctBracketing(String brackets) {         int i = 0;         Stack<Character> stack = new Stack<>();         for (Character c: brackets.toCharArray()) {             if (c == '<') {                 stack.push('<');             } else {                 if (stack.isEmpty()) return false;                 stack.pop();             }         }         return stack.isEmpty();
