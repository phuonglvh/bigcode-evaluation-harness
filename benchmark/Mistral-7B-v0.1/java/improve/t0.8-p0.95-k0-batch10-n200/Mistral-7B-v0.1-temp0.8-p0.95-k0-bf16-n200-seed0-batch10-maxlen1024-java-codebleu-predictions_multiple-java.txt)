import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return length of given string     // >>> stringLength((""))     // (0l)     // >>> stringLength(("abc"))     // (3l)     public static long strlen(String string) {         return string.length();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function encrypt that takes a string as an argument and     // returns a string encrypted with the alphabet being rotated.      // The alphabet should be rotated in a manner such that the letters      // shift down by two multiplied to two places.     // For example:     // >>> encrypt(("hi"))     // ("lm")     // >>> encrypt(("asdfghjkl"))     // ("ewhjklnop")     // >>> encrypt(("gf"))     // ("kj")     // >>> encrypt(("et"))     // ("ix")     public static String encrypt(String s) {         int n = s.length();         char[] c = new char[n];         char[] alp = "abcdefghijklmnopqrstuvwxyz".toCharArray();         for (int i = 0; i < n; i++) {             c[i] = alp[(((int)alp[i]) - 97 + n*2) % 26 + 97];         }         return new String(c);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a hash map, return true if all keys are strings in lower      // case or all keys are strings in upper case, else return false.     // The function should return false is the given hash map is empty.     // Examples:     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "b", "banana"))))     // (true)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "A", "banana", "B", "banana"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", 8l, "banana", "a", "apple"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("Name", "John", "Age", "36", "City", "Houston"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("STATE", "NC", "ZIP", "12345"))))     // (true)     public static boolean checkDictCase(HashMap<String,String> dict) {         if (dict.isEmpty()) {             return false;         }         List<String> keys = new ArrayList(dict.keySet());         return keys.stream().allMatch(s -> s.matches("^[a-z]*$") || s.matches("^[A-Z]*$"))         && dict.values().stream().allMatch(s -> s.matches("^[a-z]*$") || s.matches("^[A-Z]*$"));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers lst. add the even elements that are at odd indices..     // Examples:     // >>> add((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)6l, (long)7l))))     // (2l)     public static long add(ArrayList<Long> lst) {         return Stream.iterate(0, x -> x + 2).limit(lst.size() / 2).reduce(0l, (a, b) -> (a + lst.get(b)));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string text, replace all spaces in it with underscores,      // and if a string has more than 2 consecutive spaces,      // then replace all consecutive spaces with -      // >>> fixSpaces((" Example"))     // ("Example")     // >>> fixSpaces((" Example 1"))     // ("Example_1")     // >>> fixSpaces((" Example 2"))     // ("_Example_2")     // >>> fixSpaces((" Example 3"))     // ("_Example-3")     public static String fixSpaces(String text) {         text = text.replace(" ", "_");         StringBuilder sb = new StringBuilder();         String temp = "";         for (int i = 0; i < text.length(); i++) {             if (i == 0 && text.charAt(i) != ' ') {                 sb.append(text.charAt(i));             } else if (temp.isEmpty() && text.charAt(i) != ' ') {                 sb.append(text.charAt(i));             } else if (temp.isEmpty() && text.charAt(i) == ' ') {                 sb.append(text.charAt(i));             } else if (!temp.isEmpty() && text.charAt(i) == ' ') {                 sb.append(text.charAt(i));             } else {                 if (temp.length() == 1) {                     sb.append(text.charAt(i));                 } else if (temp.length() == 2) {                     sb.append(text.charAt(i - 2));                     sb.append(text.charAt(i - 1));                     sb.append(text.charAt(i));                 } else {                     sb.append(text.charAt(i - 2));                     sb.append(text.charAt(i - 1));                     sb.append("-");                     sb.append(text.charAt(i));                 }             }             if (i == text.length() - 1 && text.charAt(i) == ' ') {                 sb.append(text.charAt(i));             }             temp = "";         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fibfib(0) == 0     // fibfib(1) == 0     // fibfib(2) == 1     // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).     // Please write a function to efficiently compute the n-th element of the fibfib number sequence.     // >>> fibfib((1l))     // (0l)     // >>> fibfib((5l))     // (4l)     // >>> fibfib((8l))     // (24l)     public static long fibfib(long n) {         long F0 = 0;         long F1 = 1;         long F2 = 0;         long F3 = 0;         for (long i = 2; i <= n; i++) {             F0 = F1;             F1 = F2;             F2 = F3;             F3 = F0 + F1 + F2;         }         return F3;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return the sum of squares of the numbers     // in the array list that are odd. Ignore numbers that are negative or not integers.     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)0l))))     // (10l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)-1l, (long)-2l, (long)0l))))     // (0l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)9l, (long)-2l))))     // (81l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)0l))))     // (0l)     // If the input array list is empty, return 0.     public static long doubleTheDifference(ArrayList<Float> lst) {         if (lst.isEmpty()) {             return 0;         }         long sum = 0;         for (int i = 0; i < lst.size(); i++) {             if (lst.get(i) > 0 && lst.get(i) % 2 != 0) {                 sum += (Math.pow(lst.get(i), 2));             }         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter given array list of any javathon values only for integers     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList((String)"a", (String)3.14f, (String)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList(1l, 2l, 3l, "abc", new HashMap<Long,Long>(Map.of()), new ArrayList<Long>(Arrays.asList())))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     public static ArrayList<Long> filterIntegers(ArrayList<Object> values) {         ArrayList<Long> result = new ArrayList<>();         for (Object value : values) {             if (value instanceof Long) {                 result.add((Long) value);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Imagine a road that's a perfectly straight infinitely long line.     // n cars are driving left to right;  simultaneously, a different set of n cars     // are driving right to left.   The two sets of cars start out being very far from     // each other.  All cars move in the same speed.  Two cars are said to collide     // when a car that's moving left to right hits a car that's moving right to left.     // However, the cars are infinitely sturdy and strong; as a result, they continue moving     // in their trajectory as if they did not collide.     // This function outputs the number of such collisions.     public static long carRaceCollision(long n) {         long i,j;         long res=0;         long left[] = new long[n];         long right[] = new long[n];         long speed = 1;         for(i=0;i<n;i++)         {             left[i] = speed*i;         }         for(i=0;i<n;i++)         {             right[i] = speed*i;             right[i] = speed*i;         }         for(i=0;i<n;i++)         {             for(j=0;j<n;j++)             {                 if((left[i] + speed*n) == (right[j] - speed*n))                 {                     res++;                 }             }         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string representing musical notes in a special ASCII format.     // Your task is to parse this string and return array list of integers corresponding to how many beats does each     // not last.     // Here is a legend:     // 'o' - whole note, lasts four beats     // 'o|' - half note, lasts two beats     // '.|' - quater note, lasts one beat     // >>> parseMusic(("o o| .| o| o| .| .| .| .| o o"))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)1l, (long)2l, (long)2l, (long)1l, (long)1l, (long)1l, (long)1l, (long)4l, (long)4l)))     public static ArrayList<Long> parseMusic(String music_string) {         return new ArrayList<>(Arrays.stream(music_string.split(" ")).mapToLong(String::length).toList());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a number in decimal form and your task is to convert it to     // binary format. The function should return a string, with each character representing a binary     // number. Each character in the string will be '0' or '1'.     // There will be an extra couple of characters 'db' at the beginning and at the end of the string.     // The extra characters are there to help with the format.     // Examples:     // >>> decimalToBinary((15l))     // ("db1111db")     // >>> decimalToBinary((32l))     // ("db100000db")     public static String decimalToBinary(long decimal) {         String result = "";         result = "db" + result;         while(decimal > 0) {             long binary = decimal % 2;             result = String.valueOf(binary) + result;             decimal = decimal / 2;         }         result = result + "db";         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of all prefixes from shortest to longest of the input string     // >>> allPrefixes(("abc"))     // (new ArrayList<String>(Arrays.asList((String)"a", (String)"ab", (String)"abc")))     public static ArrayList<String> allPrefixes(String string) {         ArrayList<String> prefixes = new ArrayList<String>();         for (int i = 0; i < string.length(); i++) {             prefixes.add(string.substring(0, i + 1));         }         Collections.sort(prefixes);         return prefixes;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Add two numbers x and y     // >>> add((2l), (3l))     // (5l)     // >>> add((5l), (7l))     // (12l)     public static long add(long x, long y) {         long temp = x ^ y;         long carry = (x & y) << 1;         return (carry ^ temp);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're a hungry rabbit, and you already have eaten a certain number of carrots,     // but now you need to eat more carrots to complete the day's meals.     // you should return an array array list of [ total number of eaten carrots after your meals,     // the number of carrots left after your meals ]     // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.     // Example:     // >>> eat((5l), (6l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)4l)))     // >>> eat((4l), (8l), (9l))     // (new ArrayList<Long>(Arrays.asList((long)12l, (long)1l)))     // >>> eat((1l), (10l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)0l)))     // >>> eat((2l), (11l), (5l))     // (new ArrayList<Long>(Arrays.asList((long)7l, (long)0l)))     // Variables:     // @number : integer     // the number of carrots that you have eaten.     // @need : integer     // the number of carrots that you need to eat.     // @remaining : integer     // the number of remaining carrots thet exist in stock     // Constrain:     // * 0 <= number <= 1000     // * 0 <= need <= 1000     // * 0 <= remaining <= 1000     // Have fun :)     public static ArrayList<Long> eat(long number, long need, long remaining) {         ArrayList<Long> result = new ArrayList<Long>();         result.add(number+remaining);         result.add(need-remaining);         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a rectangular grid of wells. Each row represents a single well,     // and each 1 in a row represents a single unit of water.     // Each well has a corresponding bucket that can be used to extract water from it,      // and all buckets have the same capacity.     // Your task is to use the buckets to empty the wells.     // Output the number of times you need to lower the buckets.     // Example 1:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l))))), (1l))     // (6l)     // Example 2:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)1l, (long)1l))))), (2l))     // (5l)     // Example 3:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l))))), (5l))     // (0l)     // Constraints:     // * all wells have the same length     // * 1 <= grid.length <= 10^2     // * 1 <= grid[:,1].length <= 10^2     // * grid[i][j] -> 0 | 1     // * 1 <= capacity <= 10     public static long maxFill(ArrayList<ArrayList<Long>> grid, long capacity) {         // Check if any of the wells have any water in it         boolean isEmpty = true;         for(int i=0; i < grid.size(); i++) {             for(int j=0; j < grid.get(i).size(); j++) {                 if(grid.get(i).get(j) == 1) {                     isEmpty = false;                 }             }         }          if(isEmpty) {             return 0;         }          // Initialize variables         int n = grid.size();         int m = grid.get(0).size();         long totalWater = 0;         int[][] waterGrid = new int[n][m];         boolean[][] hasWater = new boolean[n][m];         int currentCapacity = 0;          // Iterate over each well         for(int i=0; i < n; i++) {             for(int j=0; j < m; j++) {                 // If the well has water in it, fill the buckets                 if(grid.get(i).get(j) == 1) {                     totalWater += 1;                     currentCapacity = capacity;                     hasWater[i][j] = true;                 }             }         }          // Iterate over each bucket         while(currentCapacity
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two array lists operator, and operand. The first array list has basic algebra operations, and      // the second array list is an array array list of integers. Use the two given array lists to build the algebric      // expression and return the evaluation of this expression.     // The basic algebra operations:     // Addition ( + )      // Subtraction ( - )      // Multiplication ( * )      // Floor division ( // )      // Exponentiation ( ** )      // Example:     // operator['+', '*', '-']     // array array list = [2, 3, 4, 5]     // result = 2 + 3 * 4 - 5     // => result = 9     // Note:     // The length of operator array list is equal to the length of operand array list minus one.     // Operand is an array array list of of non-negative integers.     // Operator array list has at least one operator, and operand array list has at least two operands.     public static long doAlgebra(ArrayList<String> op, ArrayList<Long> operand) {         if(op.size() != operand.size()-1) return -1;         if(op.size() == 0) return -1;         if(operand.size() == 0) return -1;         ArrayList<Long> res = new ArrayList<>();         res.add(operand.get(0));         for(int i = 0; i < op.size(); i++) {             if(op.get(i).equals("+")) {                 res.add(res.get(res.size()-1)+operand.get(i+1));             } else if(op.get(i).equals("-")) {                 res.add(res.get(res.size()-1)-operand.get(i+1));             } else if(op.get(i).equals("*")) {                 res.add(res.get(res.size()-1)*operand.get(i+1));             } else if(op.get(i).equals("//")) {                 res.add((long) (res.get(res.size()-1)/operand.get(i+1)));             } else if(op.get(i).equals("**")) {                 res.add((long) (Math.pow(res.get(res.size()-1), operand.get(i+1))));             }         }         return res.get(res.size()-1);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given string, flip lowercase characters to uppercase and uppercase to lowercase.     // >>> flipCase(("Hello"))     // ("hELLO")     public static String flipCase(String string) {         char[] str = string.toCharArray();         for (int i = 0; i < str.length; i++) {             if (Character.isLowerCase(str[i]))                 str[i] = Character.toUpperCase(str[i]);             else if (Character.isUpperCase(str[i]))                 str[i] = Character.toLowerCase(str[i]);         }         return String.valueOf(str);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers, sort the integers that are between 1 and 9 inclusive,     // reverse the resulting array array list, and then replace each digit by its corresponding name from     // "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".     // For example:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l, (long)1l, (long)4l, (long)5l, (long)8l, (long)2l, (long)3l))))     // (new ArrayList<String>(Arrays.asList((String)"Eight", (String)"Five", (String)"Four", (String)"Three", (String)"Two", (String)"Two", (String)"One", (String)"One")))     // If the array array list is empty, return an empty array array list:     // >>> byLength((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // If the array array list has any strange number ignore it:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)55l))))     // (new ArrayList<String>(Arrays.asList((String)"One")))     public static ArrayList<String> byLength(ArrayList<Long> arr) {         return (arr.stream().filter(i -> i <= 9 && i >= 1).sorted().mapToObj(i -> (int) i + "").sorted().map(i -> {             switch (i) {             case "1":                 return "One";             case "2":                 return "Two";             case "3":                 return "Three";             case "4":                 return "Four";             case "5":                 return "Five";             case "6":                 return "Six";             case "7":                 return "Seven";             case "8":                 return "Eight";             case "9":                 return "Nine";             default:                 return i;             }         }).mapToLong(i -> i.hashCode()).boxed().collect(Collectors.toCollection(ArrayList::new)));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of prime factors of given integer in the order from smallest to largest.     // Each of the factors should be array listed number of times corresponding to how many times it appeares in factorization.     // Input number should be equal to the product of all factors     // >>> factorize((8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)2l)))     // >>> factorize((25l))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l)))     // >>> factorize((70l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)7l)))     public static ArrayList<Long> factorize(long n) {         // TASK         return null;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement a function that takes an non-negative integer and returns an array array list of the first n     // integers that are prime numbers and less than n.     // for example:     // >>> countUpTo((5l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     // >>> countUpTo((11l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l)))     // >>> countUpTo((0l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((20l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l, (long)19l)))     // >>> countUpTo((1l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((18l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l)))     public static ArrayList<Long> countUpTo(long n) {         ArrayList<Long> arr = new ArrayList<Long>();         if (n < 2) {             return arr;         }         boolean prime = false;         for (long i = 2; i <= n; i++) {             prime = true;             for (long j = 2; j <= Math.sqrt(i); j++) {                 if (i % j == 0) {                     prime = false;                     break;                 }             }             if (prime == true) {                 arr.add(i);             }         }         return arr;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique elements in an array array list     // >>> unique((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)2l, (long)3l, (long)5l, (long)9l, (long)123l)))     public static ArrayList<Long> unique(ArrayList<Long> l) {         ArrayList<Long> result = new ArrayList<>();         ArrayList<Long> list = new ArrayList<>(l);         list.stream().sorted().forEach(item -> {             if (!result.contains(item)) result.add(item);         });         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts two array lists of strings and returns the array list that has      // total number of chars in the all strings of the array list less than the other array list.     // if the two array lists have the same number of chars, return the first array list.     // Examples     // >>> totalMatch((new ArrayList<String>(Arrays.asList())), (new ArrayList<String>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hi", (String)"hi", (String)"admin", (String)"project"))))     // (new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"4"))), (new ArrayList<String>(Arrays.asList((String)"1", (String)"2", (String)"3", (String)"4", (String)"5"))))     // (new ArrayList<String>(Arrays.asList((String)"4")))     public static ArrayList<String> totalMatch(ArrayList<String> lst1, ArrayList<String> lst2) {         ArrayList<String> result = new ArrayList<>();         if (lst1.size() < lst2.size()) {             result.addAll(lst1);         } else if (lst1.size() > lst2.size()) {             result.addAll(lst2);         } else {             result.addAll(lst1);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return maximum element in the array list.     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (3l)     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (123l)     public static long maxElement(ArrayList<Long> l) {         if (l.isEmpty())             return 0L;         long max = l.get(0);         for (long i : l)             if (i > max)                 max = i;         return max;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a string as input which contains only square brackets.     // The function should return true if and only if there is a valid subsequence of brackets      // where at least one bracket in the subsequence is nested.     // >>> isNested(("[[]]"))     // (true)     // >>> isNested(("[]]]]]]][[[[[]"))     // (false)     // >>> isNested(("[][]"))     // (false)     // >>> isNested(("[]"))     // (false)     // >>> isNested(("[[][]]"))     // (true)     // >>> isNested(("[[]][["))     // (true)     public static boolean isNested(String string) {         // Write your code here.         int[] count = {0, 0};         char[] c = string.toCharArray();         for (char s : c) {             if (s == '[')                 count[0]++;             else if (s == ']')                 count[1]++;         }         if (count[0] != count[1])             return false;         int open = 0;         int closed = 0;         for (char s : c) {             if (s == '[')                 open++;             else if (s == ']')                 closed++;         }         return open >= closed;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of strings, where each string consists of only digits, return an array array list.     // Each element i of the output should be "the number of odd elements in the     // string i of the input." where all the i's should be replaced by the number     // of odd digits in the i'th string of the input.     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"1234567"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 4n the str4ng 4 of the 4nput.")))     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"3", (String)"11111111"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 1n the str1ng 1 of the 1nput.", (String)"the number of odd elements 8n the str8ng 8 of the 8nput.")))     public static ArrayList<String> oddCount(ArrayList<String> lst) {         ArrayList<String> out = new ArrayList<String>();         for (int i = 0; i < lst.size(); i++) {             out.add("the number of odd elements " + ((lst.get(i).chars().filter(c -> c % 2 == 1).count() % 2 == 0) ? " in the str" + lst.get(i).length() + "ng " + i + " of the " : " in the str" + lst.get(i).length() + "ng " + i + " of the ") + "nput.");         }         return out;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // We have an array array list 'arr' of N integers arr[1], arr[2], ..., arr[N].The     // numbers in the array array list will be randomly ordered. Your task is to determine if     // it is possible to get an array array list sorted in non-decreasing order by performing      // the following operation on the given array array list:     // You are allowed to perform right shift operation any number of times.     // One right shift operation means shifting all elements of the array array list by one     // position in the right direction. The last element of the array array list will be moved to     // the starting position in the array array list i.e. 0th index.      // If it is possible to obtain the sorted array array list by performing the above operation     // then return true else return false.     // If the given array array list is empty then return true.     // Note: The given array list is guaranteed to have unique elements.     // For Example:     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)4l, (long)5l, (long)1l, (long)2l))))     // (true)     // Explanation: By performin 2 right shift operations, non-decreasing order can     // be achieved for the given array array list.     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)4l, (long)1l, (long)2l))))     // (false)     // Explanation:It is not possible to get non-decreasing order for the given     // array array list by performing any number of right shift operations.     public static boolean moveOneBall(ArrayList<Long> arr) {         if (arr.isEmpty())             return true;         Collections.sort(arr);         for (int i = 0; i < arr.size() - 1; i++)             if (arr.get(i) > arr.get(i + 1))                 return false;         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a pair that has the number of even and odd     // integer palindromes that fall within the range(1, n), inclusive.     // Example 1:     // >>> evenOddPalindrome((3l))     // (Pair.with(1l, 2l))     // Explanation:     // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.     // Example 2:     // >>> evenOddPalindrome((12l))     // (Pair.with(4l, 6l))     // Explanation:     // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.     // Note:     // 1. 1 <= n <= 10^3     // 2. returned pair has the number of even and odd integer palindromes respectively.     public static Pair<Long, Long> evenOddPalindrome(long n) {         List<Long> evenList = new ArrayList<>();         List<Long> oddList = new ArrayList<>();         for (long i = 1; i <= n; i++) {             String num = String.valueOf(i);             if (i == 0) {                 continue;             }             if (isPalindrome(num)) {                 if (i % 2 == 0) {                     evenList.add(i);                 } else {                     oddList.add(i);                 }             }         }         return Pair.with(evenList.size(), oddList.size());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers     // Example     // >>> isEqualToSumEven((4l))     // (false)     // >>> isEqualToSumEven((6l))     // (false)     // >>> isEqualToSumEven((8l))     // (true)     public static boolean isEqualToSumEven(long n) {         // Write your code here         List<Long> l = new ArrayList<>();         for(int i=0;i<4;i++) {             if(n%2==0) {                 l.add(n/2);                 n=n/2;             }             else {                 return false;             }         }         return l.stream().reduce(0l,(a,b) -> a+b);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // xs represent coefficients of a polynomial.     // xs[0] + xs[1] * x + xs[2] * x^2 + ....     // Return derivative of this polynomial in the same form.     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)12l, (long)20l)))     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l)))     public static ArrayList<Long> derivative(ArrayList<Long> xs) {         ArrayList<Long> result = new ArrayList<Long>();         result.add(0L);         for(int i=1; i<xs.size(); i++) {             result.add(i, result.get(i-1) + xs.get(i) * i);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return whether or not they are sorted     // in ascending order. If array list has more than 1 duplicate of the same     // number, return false. Assume no negative numbers and only integers.     // Examples     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)4l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)2l, (long)3l, (long)4l))))     // (false)     public static boolean isSorted(ArrayList<Long> lst) {         return lst.stream().sorted().reduce((a, b) -> a == b).orElse(false);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // if s[i] is a letter, reverse its case from lower to upper or vise versa,      // otherwise keep it as it is.     // If the string contains no letters, reverse the string.     // The function should return the resulted string.     // Examples     // >>> solve(("1234"))     // ("4321")     // >>> solve(("ab"))     // ("AB")     // >>> solve(("#a@C"))     // ("#A@c")     public static String solve(String s) {         String sol="";         char[] temp=new char[s.length()];         for (int i=0; i<s.length(); i++) {             if (s.charAt(i)=='a' || s.charAt(i)=='e' || s.charAt(i)=='i' || s.charAt(i)=='o' || s.charAt(i)=='u') {                 temp[i]='A';             }             else {                 temp[i]=s.charAt(i);             }         }         for (int i=0; i<s.length(); i++) {             if (temp[i]=='A' || temp[i]=='E' || temp[i]=='I' || temp[i]=='O' || temp[i]=='U') {                 sol+=Character.toLowerCase(temp[i]);             }             else {                 sol+=temp[i];             }         }         return sol;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in      // the last couple centuries. However, what people don't know is Tribonacci sequence.     // Tribonacci sequence is defined by the recurrence:     // tri(1) = 3     // tri(n) = 1 + n / 2, if n is even.     // tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.     // For example:     // tri(2) = 1 + (2 / 2) = 2     // tri(4) = 3     // tri(3) = tri(2) + tri(1) + tri(4)     // = 2 + 3 + 3 = 8      // You are given a non-negative integer number n, you have to a return an array array list of the      // first n + 1 numbers of the Tribonacci sequence.     // Examples:     // >>> tri((3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l)))     public static ArrayList<Long> tri(long n) {         ArrayList<Long> result = new ArrayList<>();         result.add(3L);         result.add(1L);         result.add(3L);         for (long i = 3; i <= n; i++) {             long j = i;             while (i % 2 == 0) {                 i /= 2;             }             long next = 0;             if (j % 2 == 0) {                 next = 1 + j / 2;             } else {                 next = result.get(i - 1) + result.get(i - 2) + result.get(i - 3);             }             result.add(next);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.     // >>> fizzBuzz((50l))     // (0l)     // >>> fizzBuzz((78l))     // (2l)     // >>> fizzBuzz((79l))     // (3l)     public static long fizzBuzz(long n) {         long result = 0;         for(long i = 0; i < n; i++) {             if(i % 11 == 0 || i % 13 == 0) {                 String number = Long.toString(i);                 for(int j = 0; j < number.length(); j++) {                     if(number.charAt(j) == '7') {                         result++;                     }                 }             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that start with a given prefix.     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bcd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"array")))     public static ArrayList<String> filterByPrefix(ArrayList<String> strings, String prefix) {         return null;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer N, return the total sum of its digits in binary.     // Example     // >>> solve((1000l))     // ("1")     // >>> solve((150l))     // ("110")     // >>> solve((147l))     // ("1100")     // Variables:     // @N integer     // Constraints: 0 ≤ N ≤ 10000.     // Output:     // a string of binary number     public static String solve(long N) {         String s = "";         while (N > 0) {             s += (N % 2);             N /= 2;         }         return s;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a grid with N rows and N columns (N >= 2) and a positive integer k,      // each cell of the grid contains a value. Every integer in the range [1, N * N]     // inclusive appears exactly once on the cells of the grid.     // You have to find the minimum path of length k in the grid. You can start     // from any cell, and in each step you can move to any of the neighbor cells,     // in other words, you can go to cells which share an edge with you current     // cell.     // Please note that a path of length k means visiting exactly k cells (not     // necessarily distinct).     // You CANNOT go off the grid.     // A path A (of length k) is considered less than a path B (of length k) if     // after making the ordered array lists of the values on the cells that A and B go     // through (let's call them lst_A and lst_B), lst_A is lexicographically less     // than lst_B, in other words, there exist an integer index i (1 <= i <= k)     // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have     // lst_A[j] = lst_B[j].     // It is guaranteed that the answer is unique.     // Return an ordered array list of the values on the cells that the minimum path go through.     // Examples:         // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)9l))))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l)))     // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)9l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)2l))))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)1l)))     public static ArrayList<Long> minPath(ArrayList<ArrayList<Long>> grid, long k) {         ArrayList<Long> minPath = new ArrayList<Long>();         int rows = grid.size();         int cols = grid.get(0).size();         ArrayList<ArrayList<Long>> minPaths = new ArrayList<ArrayList<Long>>();         ArrayList<ArrayList<ArrayList<Long>>> minPathsByRow = new ArrayList<ArrayList<ArrayList<Long>>>();         ArrayList<ArrayList<ArrayList<ArrayList<Long>>>> minPathsByRowByCol = new ArrayList<ArrayList<ArrayList<ArrayList<Long>>>>();         ArrayList<Long> minPathByRow = new ArrayList<Long>();         for(int row = 0; row < rows; row++) {             minPathsByRow.add(new ArrayList<ArrayList<Long>>());             minPathsByRowByCol.add(new ArrayList<ArrayList<ArrayList<Long>>>());             minPathByRow = new ArrayList<Long>();             for(int col = 0; col < cols; col++) {                 minPathsByRow.get(row).add(new ArrayList<Long>());                 minPathsByRowByCol.get(row).add(new ArrayList<ArrayList<Long>>());                 minPathByRow.add(grid.get(row).get(col));                 minPathsByRow.get(row).get(col).add(grid.get(row).get(col
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s, count the number of uppercase vowels in even indices.     // For example:     // >>> countUpper(("aBCdEf"))     // (1l)     // >>> countUpper(("abcdefg"))     // (0l)     // >>> countUpper(("dBBE"))     // (0l)     public static long countUpper(String s) {         return s.chars().filter(c -> c >= 'A' && c <= 'Z').filter(c -> c % 2 == 0).count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers and a positive integer k, return a sorted array list      // of length k with the maximum k numbers in arr.     // Example 1:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)-4l, (long)5l))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)-4l, (long)-3l, (long)5l)))     // Example 2:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)4l, (long)-4l, (long)4l))), (2l))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l)))     // Example 3:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)2l, (long)1l, (long)2l, (long)-1l, (long)-2l, (long)1l))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)2l)))     // Note:     // 1. The length of the array array list will be in the range of [1, 1000].     // 2. The elements in the array array list will be in the range of [-1000, 1000].     // 3. 0 <= k <= len(arr)     public static ArrayList<Long> maximum(ArrayList<Long> arr, long k) {         ArrayList<Long> sorted = new ArrayList<Long>(Arrays.asList());         Comparator<Long> comparator = (o1, o2) -> {             if(o1.compareTo(o2) == 0) return 0;             return o1 > o2 ? -1 : 1;         };         for(Long n : arr) {             if(sorted.size() < k) {                 if(!sorted.isEmpty()) {                     if(comparator.compare(n, sorted.get(0)) > 0) {                         sorted.remove(0);                         sorted.add(0, n);                     }                 } else {                     sorted.add(0, n);                 }             } else {                 if(comparator.compare(n, sorted.get(0)) > 0) {                     sorted.remove(0);                     sorted.add(0, n);                 }             }         }         return sorted;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given number n, find the largest number that divides n evenly, smaller than n     // >>> largestDivisor((15l))     // (5l)     public static long largestDivisor(long n) {         int i = 1;         int rem = n;         while(rem > 0) {             rem = n % i;             i++;         }         return (long) (n / i);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of non-negative integers, return a cojava of the given array array list after sorting,     // you will sort the given array array list in ascending order if the sum( first index value, last index value) is odd,     // or sort it in descending order if the sum( first index value, last index value) is even.     // Note:     // * don't change the given array array list.     // Examples:     // >>> sortArray((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)5l, (long)4l, (long)3l, (long)2l, (long)1l, (long)0l)))     public static ArrayList<Long> sortArray(ArrayList<Long> array) {         if (array.size() == 0)             return array;          ArrayList<Long> list = new ArrayList<>(array);         int len = list.size();          for (int i = 0; i < len; i++) {             long temp = list.get(i);             int j = i;             while (j > 0 && list.get(j - 1) > temp) {                 list.set(j, list.get(j - 1));                 j--;             }             list.set(j, temp);         }         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement the function f that takes n as a parameter,     // and returns an array array list of size n, such that the value of the element at index i is the factorial of i if i is even     // or the sum of numbers from 1 to i otherwise.     // i starts from 1.     // the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).     // Example:     // >>> f((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)6l, (long)24l, (long)15l)))     public static ArrayList<Long> f(long n) {         ArrayList<Long> numbers = new ArrayList<Long>();         for (long i = 1l; i <= n; i++) {             if (i % 2 == 0) {                 numbers.add(i);             } else {                 numbers.add(numbers.stream().reduce(0l, (a, b) -> a + b));             }         }         return numbers;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an integer a and returns true      // if this ingeger is a cube of some integer number.     // Note: you may assume the input is always valid.     // Examples:     // >>> iscube((1l))     // (true)     // >>> iscube((2l))     // (false)     // >>> iscube((-1l))     // (true)     // >>> iscube((64l))     // (true)     // >>> iscube((0l))     // (true)     // >>> iscube((180l))     // (false)     public static boolean iscube(long a) {         return Math.cbrt(a).longValue()*Math.cbrt(a).longValue()*Math.cbrt(a).longValue()==a;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a message, and encodes in such a      // way that it swaps case of all letters, replaces all vowels in      // the message with the letter that appears 2 places ahead of that      // vowel in the english alphabet.      // Assume only letters.      // Examples:     // >>> encode(("test"))     // ("TGST")     // >>> encode(("This is a message"))     // ("tHKS KS C MGSSCGG")     public static String encode(String message) {         String s = message.toUpperCase();         int[] vowels = {65, 69, 73, 79, 85};         StringBuilder sb = new StringBuilder();         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == ' ') {                 sb.append(' ');             } else {                 boolean isVowel = false;                 for (int j : vowels) {                     if (s.charAt(i) == (char) j) {                         isVowel = true;                     }                 }                 if (isVowel) {                     sb.append((char) (s.charAt(i) + 3));                 } else {                     sb.append((char) (s.charAt(i) - 3));                 }             }         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You'll be given a string of words, and your task is to count the number     // of boredoms. A boredom is a sentence that starts with the word "I".     // Sentences are delimited by '.', '?' or '!'.     // For example:     // >>> isBored(("Hello world"))     // (0l)     // >>> isBored(("The sky is blue. The sun is shining. I love this weather"))     // (1l)     public static long isBored(String S) {         String[] Sarray = S.split(" ");         long count = 0;         for (int i = 0; i < Sarray.length; i++) {             if (Sarray[i].equals("I")) {                 if (i > 0 && (Sarray[i - 1].equals(".") || Sarray[i - 1].equals("?") || Sarray[i - 1].equals("!"))) {                     count += 1;                 }             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // pairs_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are two distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)5l, (long)7l))))     // (true)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean pairsSumToZero(ArrayList<Long> l) {         for (Long i : l) {             for (Long j : l) {                 if (i != j && (i + j) == 0) {                     return true;                 }             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return the area of     // the triangle rounded to 2 decimal points if the three sides form a valid triangle.      // Otherwise return -1     // Three sides make a valid triangle when the sum of any two sides is greater      // than the third side.     // Example:     // >>> triangleArea((3l), (4l), (5l))     // (6.0f)     // >>> triangleArea((1l), (2l), (10l))     // (float)-1l     public static float triangleArea(long a, long b, long c) {         if(a + b > c && a + c > b && b + c > a) {             float s = (float) (a + b + c) / 2;             float area = (float) Math.sqrt(s * (s - a) * (s - b) * (s - c));             return area;         }         return -1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // There are eight planets in our solar system: the closerst to the Sun      // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,      // Uranus, Neptune.     // Write a function that takes two planet names as strings planet1 and planet2.      // The function should return a pair containing all planets whose orbits are      // located between the orbit of planet1 and the orbit of planet2, sorted by      // the proximity to the sun.      // The function should return an empty pair if planet1 or planet2     // are not correct planet names.      // Examples     // >>> bf(("Jupiter"), ("Neptune"))     // (new ArrayList<String>(Arrays.asList((String)"Saturn", (String)"Uranus")))     // >>> bf(("Earth"), ("Mercury"))     // (ArrayList<String>("Venus"))     // >>> bf(("Mercury"), ("Uranus"))     // (new ArrayList<String>(Arrays.asList((String)"Venus", (String)"Earth", (String)"Mars", (String)"Jupiter", (String)"Saturn")))     public static ArrayList<String> bf(String planet1, String planet2) {         if(planet1.equals("Mercury") || planet1.equals("Venus") || planet1.equals("Earth") || planet1.equals("Mars") || planet1.equals("Jupiter") || planet1.equals("Saturn") || planet1.equals("Uranus") || planet1.equals("Neptune")) {             if(planet2.equals("Mercury") || planet2.equals("Venus") || planet2.equals("Earth") || planet2.equals("Mars") || planet2.equals("Jupiter") || planet2.equals("Saturn") || planet2.equals("Uranus") || planet2.equals("Neptune")) {                 ArrayList<String> planets = new ArrayList<>();                 if(planet1.equals("Mercury")) {                     planets.add("Venus");                 } else if(planet1.equals("Venus")) {                     planets.add("Earth");                 } else if(planet1.equals("Earth")) {                     planets.add("Mars");                 } else if(planet1.equals("Mars")) {                     planets.add("Jupiter");                 } else if(planet1.equals("Jupiter")) {                     planets.add("Saturn");                 } else if(planet1.equals("Saturn")) {                     planets.add("Uranus");                 } else if(planet1.equals("Uranus")) {                     planets.add("Neptune");                 }                 if(planet2.equals("Mercury")) {                     planets.add("Venus");                 } else if(planet2.equals("Venus")) {                     planets.add("Earth");                 } else if(planet2.equals("Earth")) {                     planets.add("Mars");                 } else if(planet2.equals("Mars")) {                     planets.add("Jupiter");                 } else if(planet2.equals("Jupiter")) {                     planets.add("Saturn");                 } else if(planet2.equals("Saturn")) {                     planets.add("Uranus");                 } else if(planet2.equals("Uranus")) {                     planets.add("Neptune");                 }                 return planets;             } else {                 return new ArrayList<String>();             }         } else {             return new ArrayList<String>();         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the product of the odd digits.     // Return 0 if all digits are even.     // For example:     // >>> digits((1l))     // (1l)     // >>> digits((4l))     // (0l)     // >>> digits((235l))     // (15l)     public static long digits(long n) {         long ans = 0;         if (n == 0) {             return 0;         }         long a[] = new long[100];         int i = 0;         while (n != 0) {             a[i] = n % 10;             n /= 10;             i++;         }         i--;         while (i >= 0) {             if (a[i] % 2 != 0) {                 ans = ans * 10 + a[i];             }             i--;         }         if (ans == 0) {             ans = 0;         }         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a string of words separated by commas or spaces. Your task is     // to split the string into words and return an array array list of the words.     // For example:     // >>> wordsString(("Hi, my name is John"))     // (new ArrayList<String>(Arrays.asList((String)"Hi", (String)"my", (String)"name", (String)"is", (String)"John")))     // >>> wordsString(("One, two, three, four, five, six"))     // (new ArrayList<String>(Arrays.asList((String)"One", (String)"two", (String)"three", (String)"four", (String)"five", (String)"six")))     public static ArrayList<String> wordsString(String s) {         String[] arr = s.split("\\s+|,|\\s+");         ArrayList<String> list = new ArrayList<>(Arrays.asList(arr));         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find how many times a given substring can be found in the original string. Count overlaping cases.     // >>> howManyTimes((""), ("a"))     // (0l)     // >>> howManyTimes(("aaa"), ("a"))     // (3l)     // >>> howManyTimes(("aaaa"), ("aa"))     // (3l)     public static long howManyTimes(String string, String substring) {         if (string.length() == 0) {             return 0;         }         if (substring.length() == 0) {             return 1;         }         long count = 0;         if (string.charAt(0) == substring.charAt(0)) {             count = howManyTimes(string.substring(1), substring) + 1;         } else {             count = howManyTimes(string, substring);         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // remove_vowels is a function that takes string and returns string without vowels.     // >>> removeVowels((""))     // ("")     // >>> removeVowels(("abcdef"))     // ("bcdf")     // >>> removeVowels(("aaaaa"))     // ("")     // >>> removeVowels(("aaBAA"))     // ("B")     // >>> removeVowels(("zbcd"))     // ("zbcd")     public static String removeVowels(String text) {         return text.replaceAll("[aeiouAEIOU]","");
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of integers, return array list in strange order.     // Strange sorting, is when you start with the minimum value,     // then maximum of the remaining integers, then minimum and so on.     // Examples:     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)3l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> strangeSortList(ArrayList<Long> lst) {         Collections.sort(lst);         Collections.reverse(lst);         return lst;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a supplied array list of numbers (of length at least two) select and return two that are the closest to each     // other and return them in order (smaller number, larger number).     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f))))     // (Pair.with(2.0f, 2.2f))     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))))     // (Pair.with(2.0f, 2.0f))     public static Pair<Float, Float> findClosestElements(ArrayList<Float> numbers) {         Collections.sort(numbers);         int mid = numbers.size() / 2;         return Pair.with(numbers.get(mid - 1), numbers.get(mid));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to write a function that returns true if a number x is a simple     // power of n and false in other cases.     // x is a simple power of n if n**int=x     // For example:     // >>> isSimplePower((1l), (4l))     // (true)     // >>> isSimplePower((2l), (2l))     // (true)     // >>> isSimplePower((8l), (2l))     // (true)     // >>> isSimplePower((3l), (2l))     // (false)     // >>> isSimplePower((3l), (1l))     // (false)     // >>> isSimplePower((5l), (3l))     // (false)     public static boolean isSimplePower(long x, long n) {         return x % n == 0 && n != 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // prime_fib returns n-th number that is a Fibonacci number and it's also prime.     // >>> primeFib((1l))     // (2l)     // >>> primeFib((2l))     // (3l)     // >>> primeFib((3l))     // (5l)     // >>> primeFib((4l))     // (13l)     // >>> primeFib((5l))     // (89l)     public static long primeFib(long n) {         long nthFib = n;         long fib1 = 0;         long fib2 = 1;         long fib = fib1 + fib2;         if(n == 1) {             return 2;         }         while (fib < n) {             fib = fib1 + fib2;             fib1 = fib2;             fib2 = fib;         }         long prime = 0;         for(long i = 2; i <= fib; i++) {             if(fib % i == 0) {                 prime = i;                 break;             }         }         return prime;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function which sorts the given array list of integers     // in ascending order according to the sum of their digits.     // Note: if there are several items with similar sum of their digits,     // order them based on their index in original array list.     // For example:     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList((long)1l, (long)11l, (long)-1l, (long)-11l, (long)-12l))))     // (new ArrayList<Long>(Arrays.asList((long)-1l, (long)-11l, (long)1l, (long)-12l, (long)11l)))     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> orderByPoints(ArrayList<Long> nums) {         ArrayList<Tuple2<Long,Long>> numsArray = new ArrayList<Tuple2<Long,Long>>();         for(int i = 0; i<nums.size(); i++) {             numsArray.add(Tuple.with(nums.get(i), i));         }         numsArray.sort((x,y)->{             long xsum = 0;             long ysum = 0;             while(x%10>0) {                 xsum+=x%10;                 x/=10;             }             while(y%10>0) {                 ysum+=y%10;                 y/=10;             }             if(xsum == ysum) {                 return x.compareTo(y);             }             return xsum-ysum;         });         ArrayList<Long> ret = new ArrayList<Long>();         for(Tuple2<Long,Long> num : numsArray) {             ret.add(num.getValue0());         }         return ret;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if in given array list of numbers, are any two numbers closer to each other than     // given threshold.     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))), (0.5f))     // (false)     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))), (0.3f))     // (true)     public static boolean hasCloseElements(ArrayList<Float> numbers, float threshold) {         for (int i = 0; i < numbers.size(); i++) {             for (int j = i + 1; j < numbers.size(); j++) {                 if (Math.abs(numbers.get(i) - numbers.get(j)) < threshold) {                     return true;                 }             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find the shortest palindrome that begins with a supplied string.     // Algorithm idea is simple:     // - Find the longest postfix of supplied string that is a palindrome.     // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.     // >>> makePalindrome((""))     // ("")     // >>> makePalindrome(("cat"))     // ("catac")     // >>> makePalindrome(("cata"))     // ("catac")     public static String makePalindrome(String string) {         StringBuffer sb = new StringBuffer();         String str = string.trim();         if (str.isEmpty()) {             return "";         }         // Make palindrome out of suffix.         // >>> makePalindromeSuffix(("catac"))         // ("catac")         String palindromeSuffix = makePalindromeSuffix(str);         sb.append(palindromeSuffix);         sb.append(reverse(str.substring(0, str.length() - palindromeSuffix.length())));         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input are two strings a and b consisting only of 1s and 0s.     // Perform binary XOR on these inputs and return result also as a string.     // >>> stringXor(("010"), ("110"))     // ("100")     public static String stringXor(String a, String b) {         return String.valueOf(Integer.parseInt(a, 2) ^ Integer.parseInt(b, 2));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Brazilian factorial is defined as:     // brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!     // where n > 0     // For example:     // >>> specialFactorial((4l))     // (288l)     // The function will receive an integer as input and should return the special     // factorial of this integer.     public static long specialFactorial(long n) {         if (n <= 0) {             return 1;         }         BigInteger bigint = BigInteger.ONE;         for (long i = n; i >= 1; i--) {             bigint = bigint.multiply(BigInteger.valueOf(i));         }         return bigint.longValue();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array array list of integers arr and an integer k, return     // the sum of the elements with at most two digits from the first k elements of arr.     // Example:     // >>> addElements((new ArrayList<Long>(Arrays.asList((long)111l, (long)21l, (long)3l, (long)4000l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l))), (4l))     // (24l)     // Constraints:     // 1. 1 <= len(arr) <= 100     // 2. 1 <= k <= len(arr)     public static long addElements(ArrayList<Long> arr, long k) {         // write your code here         long sum = 0;         for (int i = 0; i < k; i++) {             Long value = arr.get(i);             if (value < 100) {                 sum += value;             }         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fib4(0) -> 0     // fib4(1) -> 0     // fib4(2) -> 2     // fib4(3) -> 0     // fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).     // Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.     // >>> fib4((5l))     // (4l)     // >>> fib4((6l))     // (8l)     // >>> fib4((7l))     // (14l)     public static long fib4(long n) {         long num1 = 0;         long num2 = 0;         long num3 = 2;         long num4 = 0;         long num5 = 0;         for (long i = 4l; i <= n; i++) {             num5 = num1 + num2 + num3 + num4;             num1 = num2;             num2 = num3;             num3 = num4;             num4 = num5;         }         return num5;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of positive integers x. return a sorted array list of all      // elements that hasn't any even digit.     // Note: Returned array list should be sorted in increasing order.     // For example:     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)15l, (long)33l, (long)1422l, (long)1l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)15l, (long)33l)))     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)152l, (long)323l, (long)1422l, (long)10l))))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> uniqueDigits(ArrayList<Long> x) {         ArrayList<Long> y = new ArrayList<Long>();         for (int i = 0; i < x.size(); i++) {             String s = x.get(i).toString();             for (int j = 0; j < s.length(); j++) {                 if (s.charAt(j) % 2 == 1) {                     y.add(x.get(i));                     break;                 }             }         }         Collections.sort(y);         return y;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s and a natural number n, you have been tasked to implement      // a function that returns an array array list of all words from string s that contain exactly      // n consonants, in order these words appear in the string s.     // If the string s is empty then the function should return an empty array list.     // Note: you may assume the input string contains only letters and spaces.     // Examples:     // >>> selectWords(("Mary had a little lamb"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"little")))     // >>> selectWords(("Mary had a little lamb"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Mary", (String)"lamb")))     // >>> selectWords(("simple white space"), (2l))     // (new ArrayList<String>(Arrays.asList()))     // >>> selectWords(("Hello world"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"world")))     // >>> selectWords(("Uncle sam"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Uncle")))     public static ArrayList<String> selectWords(String s, long n) {         ArrayList<String> result = new ArrayList<>();         String[] arr = s.split(" ");         for (int i = 0; i < arr.length; i++) {             String word = arr[i];             int count = 0;             char[] ch = word.toCharArray();             for (int j = 0; j < ch.length; j++) {                 if (ch[j] != ' ') {                     if (Character.isLetter(ch[j]) && ch[j] != 'a' && ch[j] != 'e' && ch[j] != 'i' && ch[j] != 'o'                             && ch[j] != 'u' && ch[j] != 'y') {                         count++;                     }                 }             }             if (count == n) {                 result.add(word);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the object q will fly, and false otherwise.     // The object q will fly if it's balanced (it is a palindromic array list) and the sum of its elements is less than or equal the maximum possible weight w.     // Example:     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l))), (5l))     // (false)     // # 1+2 is less than the maximum possible weight, but it's unbalanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (1l))     // (false)     // # it's balanced, but 3+2+3 is more than the maximum possible weight.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (9l))     // (true)     // # 3+2+3 is less than the maximum possible weight, and it's balanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l))), (5l))     // (true)     // # 3 is less than the maximum possible weight, and it's balanced.     public static boolean willItFly(ArrayList<Long> q, long w) {         // Write your code here         int s = 0;         if (q == null || q.size() < 1) {             return false;         }         for (Long num : q) {             if (num > w) {                 return false;             } else {                 s += num;             }         }         return s <= w;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return n-th Fibonacci number.     // >>> fib((10l))     // (55l)     // >>> fib((1l))     // (1l)     // >>> fib((8l))     // (21l)     public static long fib(long n) {         long a = 0, b = 1, c = 0;         if (n < 2) {             return n;         }         for (long i = 0; i < n - 1; i++) {             c = a + b;             a = b;             b = c;         }         return c;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given the name of a class (a string) and an array array list of extensions.     // The extensions are to be used to load additional classes to the class. The     // strength of the extension is as follows: Let CAP be the number of the uppercase     // letters in the extension's name, and let SM be the number of lowercase letters      // in the extension's name, the strength is given by the fraction CAP - SM.      // You should find the strongest extension and return a string in this      // format: ClassName.StrongestExtensionName.     // If there are two or more extensions with the same strength, you should     // choose the one that comes first in the array list.     // For example, if you are given "Slices" as the class and an array array list of the     // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should     // return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension      // (its strength is -1).     // Example:     // >>> StrongestExtension(("my_class"), (new ArrayList<String>(Arrays.asList((String)"AA", (String)"Be", (String)"CC"))))     // ("my_class.AA")     public static String StrongestExtension(String class_name, ArrayList<String> extensions) {         Collections.sort(extensions);         // TODO: return the string of the strongest extension         String[] temp = class_name.split("\\.");         if (temp.length > 0) {             return class_name + "." + extensions.get(0);         } else {             return extensions.get(0);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of two strings, both strings consist of open     // parentheses '(' or close parentheses ')' only.     // Your job is to check if it is possible to concatenate the two strings in     // some order, that the resulting string will be good.     // A string S is considered to be good if and only if all parentheses in S     // are balanced. For example: the string '(())()' is good, while the string     // '())' is not.     // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.     // Examples:     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)"()(", (String)")"))))     // ("Yes")     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)")", (String)")"))))     // ("No")     public static String matchParens(ArrayList<String> lst) {         int[] isOpen = {0, 0};         for (String s : lst) {             for (int i = 0; i < s.length(); ++i) {                 if (s.charAt(i) == '(') {                     isOpen[0]++;                 } else if (s.charAt(i) == ')') {                     isOpen[1]++;                 }             }         }         if (isOpen[0] != isOpen[1]) {             return "No";         }         return "Yes";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // Write a function next_smallest() that returns the 2nd smallest element of the array list.     // Return null if there is no such element.     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)5l, (long)1l, (long)4l, (long)3l, (long)2l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l))))     // Optional.empty()     public static Optional<Long> nextSmallest(ArrayList<Long> lst) {         if (lst.isEmpty()) {             return Optional.empty();         }         Long smallest = lst.get(0);         Long secondSmallest = smallest;         for (Long n: lst) {             if (n.compareTo(smallest) == 0) {                 continue;             }             if (n.compareTo(smallest) < 0) {                 secondSmallest = smallest;                 smallest = n;             }             else {                 if (n.compareTo(secondSmallest) < 0) {                     secondSmallest = n;                 }             }         }         return Optional.of(secondSmallest);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes 3 numbers.     // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.     // Returns false in any other cases.     // Examples     // >>> anyInt((float)5l, (float)2l, (float)7l)     // (true)     // >>> anyInt((float)3l, (float)2l, (float)2l)     // (false)     // >>> anyInt((float)3l, (float)-2l, (float)1l)     // (true)     // >>> anyInt((3.6f), (-2.2f), (float)2l)     // (false)     public static boolean anyInt(float x, float y, float z) {         if((x==y+z || y==x+z || z==x+y) && x==(int)x && y==(int)y && z==(int)z){             return true;         }         else return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive floating point number, it can be decomposed into     // and integer part (largest integer smaller than given number) and decimals     // (leftover part always smaller than 1).     // Return the decimal part of the number.     // >>> truncateNumber((3.5f))     // (0.5f)     public static float truncateNumber(float number) {         return number-Math.floor(number);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list with elements incremented by 1.     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l)))     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)4l, (long)6l, (long)3l, (long)4l, (long)4l, (long)10l, (long)1l, (long)124l)))     public static ArrayList<Long> incrList(ArrayList<Long> l) {         for (int i = 0; i < l.size(); i++) {             l.set(i, (long) (l.get(i) + 1));         }         return l;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // A simple program which should return the value of x if n is      // a prime number and should return the value of y otherwise.     // Examples:     // >>> xOrY((7l), (34l), (12l))     // (34l)     // >>> xOrY((15l), (8l), (5l))     // (5l)     public static long xOrY(long n, long x, long y) {         if (n == 2l) {             return x;         }         if (n > 2l && n % 2l == 0) {             return y;         }         if (n % 3l == 0) {             return x;         }         long n_minus_1 = n - 1l;         if (n_minus_1 % 3l == 0) {             return y;         }         long sqrt_n = (long) Math.sqrt(n);         for (long i = 3l; i <= sqrt_n; i++) {             if (n % i == 0l) {                 return y;             }         }         return x;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return 2^n modulo p (be aware of numerics).     // >>> modp((3l), (5l))     // (3l)     // >>> modp((1101l), (101l))     // (2l)     // >>> modp((0l), (101l))     // (1l)     // >>> modp((3l), (11l))     // (8l)     // >>> modp((100l), (101l))     // (1l)     public static long modp(long n, long p) {         if (p == 0l) return 0l;         long res = 1l;         while (p != 0l) {             if ((p & 1l) != 0l) {                 res = (res * n) % p;             }             n = (n * n) % p;             p = (p >> 1l);         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an integer. return a pair that has the number of even and odd digits respectively.     // Example:     // >>> evenOddCount((-12l))     // (Pair.with(1l, 1l))     // >>> evenOddCount((123l))     // (Pair.with(1l, 2l))     public static Pair<Long, Long> evenOddCount(long num) {         if(num == 0) return Pair.with(0l,0l);         BigInteger evenCount = new BigInteger("0");         BigInteger oddCount = new BigInteger("0");         while(num > 0){             BigInteger current = new BigInteger(Long.toString(num % 10));             if(current.equals(BigInteger.ZERO)){                 evenCount = evenCount.add(BigInteger.ONE);             }else if(current.remainder(BigInteger.TWO).equals(BigInteger.ONE)){                 oddCount = oddCount.add(BigInteger.ONE);             }             num = num / 10;         }         return Pair.with(oddCount, evenCount);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // Your task is to check if the string is hapjava or not.     // A string is hapjava if its length is at least 3 and every 3 consecutive letters are distinct     // For example:     // >>> isHappy(("a"))     // (false)     // >>> isHappy(("aa"))     // (false)     // >>> isHappy(("abcd"))     // (true)     // >>> isHappy(("aabb"))     // (false)     // >>> isHappy(("adb"))     // (true)     // >>> isHappy(("xyy"))     // (false)     public static boolean isHappy(String s) {         if (s.length() <= 3) {             return false;         } else if (s.length() > 3) {             for (int i = 0; i < s.length() - 2; i++) {                 if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i) == s.charAt(i + 2) || s.charAt(i + 1) == s.charAt(i + 2)) {                     return false;                 } else {                     return true;                 }             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the largest prime factor of n. Assume n > 1 and is not a prime.     // >>> largestPrimeFactor((13195l))     // (29l)     // >>> largestPrimeFactor((2048l))     // (2l)     public static long largestPrimeFactor(long n) {         List<Long> primeFactors = new ArrayList<>();         for (long i = 2; i * i <= n; i++) {             while (n % i == 0) {                 primeFactors.add(i);                 n /= i;             }         }         if (n > 1) {             primeFactors.add(n);         }         return primeFactors.stream().reduce(1l, (a, b) -> Math.max(a, b));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // Write a function that takes a string as input and returns the sum of the upper characters only'     // ASCII codes.     // Examples:     // >>> digitSum((""))     // (0l)     // >>> digitSum(("abAB"))     // (131l)     // >>> digitSum(("abcCd"))     // (67l)     // >>> digitSum(("helloE"))     // (69l)     // >>> digitSum(("woArBld"))     // (131l)     // >>> digitSum(("aAaaaXa"))     // (153l)     public static long digitSum(String s) {         return s.chars().filter(Character::isUpperCase).mapToObj(Character::toString).mapToLong(Long::parseLong).sum();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of numbers (of at least two elements), apply a linear transform to that array list,     // such that the smallest number will become 0 and the largest will become 1     // >>> rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f))))     // (new ArrayList<Float>(Arrays.asList((float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f)))     public static ArrayList<Float> rescaleToUnit(ArrayList<Float> numbers) {         if (numbers.size() < 2)             return numbers;         float largest = numbers.stream().max(Comparator.naturalOrder()).get();         float smallest = numbers.stream().min(Comparator.naturalOrder()).get();         float range = largest - smallest;         for (int i = 0; i < numbers.size(); i++) {             numbers.set(i, (numbers.get(i) - smallest) / range);         }         return numbers;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers, return the sum of all of the odd elements that are in even positions.     // Examples     // >>> solution((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)7l, (long)1l))))     // (12l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l, (long)3l, (long)3l))))     // (9l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)30l, (long)13l, (long)24l, (long)321l))))     // (0l)     public static long solution(ArrayList<Long> lst) {         long oddSum = 0;         for (int i = 0; i < lst.size(); i++) {             if (lst.get(i) % 2 == 1) {                 oddSum += lst.get(i);             }             if (i % 2 == 0) {                 oddSum -= lst.get(i);             }         }         return oddSum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "Given an array array list representing a branch of a tree that has non-negative integer nodes     // your task is to pluck one of the nodes and return it.     // The plucked node should be the node with the smallest even value.     // If multiple nodes with the same smallest even value are found return the node that has smallest index.     // The plucked node should be returned in an array array list, [ smalest_value, its index ],     // If there are no even values or the given array array list is empty, return [].     // Example 1:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 2:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 3:     // >>> pluck((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // Example 4:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l, (long)0l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))     // Explanation: 0 is the smallest value, but  there are two zeros,     // so we will choose the first zero, which has the smallest index.     // Constraints:     // * 1 <= nodes.length <= 10000     // * 0 <= node.value     public static ArrayList<Long> pluck(ArrayList<Long> arr) {         ArrayList<Long> out = new ArrayList<Long>();         if(arr.size() == 0) return out;         long even = 0;         long small = 0;         for(long l : arr) {             if(l%2 == 0) {                 even = l;                 small = l;             }             if(l%2 == 0 && l < small) {                 small = l;             }         }         if(small > 0) {             for(long l : arr) {                 if(l == small) {                     out.add(small);                     out.add(arr.indexOf(l));                     break;                 }             }         }         return out;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a positive integer n. You have to create an integer array array list a of length n.     // For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.     // Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,      // and a[i] + a[j] + a[k] is a multiple of 3.     // Example :     // >>> getMaxTriples((5l))     // (1l)     // Explanation:      // a = [1, 3, 7, 13, 21]     // The only valid triple is (1, 7, 13).     public static long getMaxTriples(long n) {         return (long) n*(n+1)*(n+2)/6/3;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this problem, you will implement a function that takes two array lists of numbers,     // and determines whether it is possible to perform an exchange of elements     // between them to make lst1 an array array list of only even numbers.     // There is no limit on the number of exchanged elements between lst1 and lst2.     // If it is possible to exchange elements between the lst1 and lst2 to make     // all the elements of lst1 to be even, return "YES".     // Otherwise, return "NO".     // For example:     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // ("YES")     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)3l, (long)4l))))     // ("NO")     // It is assumed that the input array lists will be non-empty.     public static String exchange(ArrayList<Long> lst1, ArrayList<Long> lst2) {         if(lst1.size()==0||lst2.size()==0)             return "NO";         if(lst1.size()!=lst2.size())             return "NO";         ArrayList<Long> lst3=new ArrayList<Long>();         for(int i=0;i<lst1.size();i++)             lst3.add((lst1.get(i)&1)==0?lst1.get(i):lst2.get(i));         return (lst3.stream().allMatch(x->x%2==0))?"YES":"NO";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return median of elements in the array list l.     // >>> median((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (float)3l     // >>> median((new ArrayList<Long>(Arrays.asList((long)-10l, (long)4l, (long)6l, (long)1000l, (long)10l, (long)20l))))     // (15.0f)     public static float median(ArrayList<Long> l) {         l.sort((x, y) -> y.compareTo(x));         if (l.size() % 2 == 1)             return l.get(l.size() / 2);         else             return (l.get(l.size() / 2) + l.get(l.size() / 2 - 1)) / 2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns true if the string     // length is a prime number or false otherwise     // Examples     // >>> primeLength(("Hello"))     // (true)     // >>> primeLength(("abcdcba"))     // (true)     // >>> primeLength(("kittens"))     // (true)     // >>> primeLength(("orange"))     // (false)     public static boolean primeLength(String string) {         // your code here         //return true;         if (string.length() == 2) {             return false;         }          if (string.length() == 3) {             return false;         }          int num = string.length();          if (num > 0) {             boolean prime = true;             for (int i = 2; i <= Math.sqrt(num); i++) {                 if (num % i == 0) {                     prime = false;                     break;                 }             }             if (prime) {                 return true;             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers, find the minimum number of elements that     // need to be changed to make the array array list palindromic. A palindromic array array list is an array array list that     // is read the same backwards and forwards. In one change, you can change one element to any other element.     // For example:     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)5l, (long)4l, (long)7l, (long)9l, (long)6l))))     // (4l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)3l, (long)2l, (long)2l))))     // (1l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)1l))))     // (0l)     public static long smallestChange(ArrayList<Long> arr) {         long result = 0;         for (int i = 0; i < arr.size(); i++) {             if (arr.get(i) > arr.get(arr.size() - 1 - i)) {                 result += arr.get(i) - arr.get(arr.size() - 1 - i);                 arr.set(i, arr.get(arr.size() - 1 - i));                 arr.set(arr.size() - 1 - i, arr.get(i));             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of numbers.     // You need to return the sum of squared numbers in the given array list,     // round each element in the array list to the upper int(Ceiling) first.     // Examples:     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))))     // (14l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)4.0f, (float)9.0f))))     // (98l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f))))     // (84l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.4f, (float)4.2f, (float)0.0f))))     // (29l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)-2.4f, (float)1.0f, (float)1.0f))))     // (6l)     public static long sumSquares(ArrayList<Float> lst) {         long sum = 0;         for (int i = 0; i < lst.size(); i++) {             sum += Math.round(lst.get(i).floatValue()*lst.get(i).floatValue());         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which takes a string representing a file's name, and returns     // 'Yes' if the the file's name is valid, and returns 'No' otherwise.     // A file's name is considered to be valid if and only if all the following conditions      // are met:     // - There should not be more than three digits ('0'-'9') in the file's name.     // - The file's name contains exactly one dot '.'     // - The substring before the dot should not be empty, and it starts with a letter from      // the latin alphapet ('a'-'z' and 'A'-'Z').     // - The substring after the dot should be one of these: ['txt', 'exe', 'dll']     // Examples:     // >>> fileNameCheck(("example.txt"))     // ("Yes")     // >>> fileNameCheck(("1example.dll"))     // ("No")     public static String fileNameCheck(String file_name) {         String regex = "[0-9]{0,3}";         String regex2 = "[A-Za-z]+\\.";         String regex3 = "txt|exe|dll";         if (Pattern.matches(regex, file_name) && Pattern.matches(regex2, file_name) && Pattern.matches(regex3, file_name)) {             return "Yes";         } else {             return "No";         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // triples_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are three distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)9l, (long)7l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean triplesSumToZero(ArrayList<Long> l) {         Set<Long> s = new HashSet<Long>();         for(int i=0; i<l.size(); i++){             s.add(l.get(i));         }         if(s.size()!=l.size()){             return false;         }         for(int i=0; i<l.size(); i++){             for(int j=i+1; j<l.size(); j++){                 for(int k=j+1; k<l.size(); k++){                     if(l.get(i)+l.get(j)+l.get(k)==0){                         return true;                     }                 }             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given two intervals,     // where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).     // The given intervals are closed which means that the interval (start, end)     // includes both start and end.     // For each given interval, it is assumed that its start is less or equal its end.     // Your task is to determine whether the length of intersection of these two      // intervals is a prime number.     // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)     // which its length is 1, which not a prime number.     // If the length of the intersection is a prime number, return "YES",     // otherwise, return "NO".     // If the two intervals don't intersect, return "NO".     // [input/output] samples:     // >>> intersection((Pair.with(1l, 2l)), (Pair.with(2l, 3l)))     // ("NO")     // >>> intersection((Pair.with(-1l, 1l)), (Pair.with(0l, 4l)))     // ("NO")     // >>> intersection((Pair.with(-3l, -1l)), (Pair.with(-5l, 5l)))     // ("YES")     public static String intersection(Pair<Long, Long> interval1, Pair<Long, Long> interval2) {         long s1 = interval1.getValue0();         long e1 = interval1.getValue1();         long s2 = interval2.getValue0();         long e2 = interval2.getValue1();         if(s1 >= e2 || e1 <= s2) return "NO";         long ans = e2 - s1 + 1;         long start = 2;         while(start < ans){             if(ans % start == 0) return "NO";             start++;         }         return "YES";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string containing multiple groups of nested parentheses. Your goal is to     // separate those group into separate strings and return the array list of those.     // Separate groups are balanced (each open brace is properly closed) and not nested within each other     // Ignore any spaces in the input string.     // >>> separateParenGroups(("( ) (( )) (( )( ))"))     // (new ArrayList<String>(Arrays.asList((String)"()", (String)"(())", (String)"(()())")))     public static ArrayList<String> separateParenGroups(String paren_string) {         // Your code goes here         ArrayList<String> groups = new ArrayList<String>();         int counter = 0;         String[] split = paren_string.split("\\s+");         for(String s : split){             if(s.equals("(")){                 counter++;             }             else if(s.equals(")")){                 counter--;             }             if(counter == 0){                 groups.add(s);                 counter = 0;             }         }         return groups;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // I think we all remember that feeling when the result of some long-awaited     // event is finally known. The feelings and thoughts you have at that moment are     // definitely worth noting down and comparing.     // Your task is to determine if a person correctly guessed the results of a number of matches.     // You are given two array array lists of scores and guesses of equal length, where each index shows a match.      // Return an array array list of the same length denoting how far off each guess was. If they have guessed correctly,     // the value is 0, and if not, the value is the absolute difference between the guess and the score.     // example:     // >>> compare((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)2l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)3l, (long)3l)))     // >>> compare((new ArrayList<Long>(Arrays.asList((long)0l, (long)5l, (long)0l, (long)0l, (long)0l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)1l, (long)0l, (long)0l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l, (long)1l, (long)0l, (long)0l, (long)6l)))     public static ArrayList<Long> compare(ArrayList<Long> game, ArrayList<Long> guess) {         ArrayList<Long> diff = new ArrayList<>();         for(int i = 0; i<game.size(); i++){             Long dif = Math.abs(game.get(i)-guess.get(i));             diff.add(dif);         }         return diff;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the count of the numbers of n-digit     // positive integers that start or end with 1.     public static long startsOneEnds(long n) {         // I don't know how to solve this problem yet, but I have to get         // something done.         long res = n;         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns true if the last character     // of a given string is an alphabetical character and is not     // a part of a word, and false otherwise.     // Note: "word" is a group of characters separated by space.     // Examples:     // >>> checkIfLastCharIsALetter(("apple pie"))     // (false)     // >>> checkIfLastCharIsALetter(("apple pi e"))     // (true)     // >>> checkIfLastCharIsALetter(("apple pi e "))     // (false)     // >>> checkIfLastCharIsALetter((""))     // (false)     public static boolean checkIfLastCharIsALetter(String txt) {         if (txt == null || txt.length() == 0) return false;         char ch = txt.charAt(txt.length() - 1);         if (!Character.isLetter(ch)) return false;         return txt.lastIndexOf(" ") == txt.length() - 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have to write a function which validates a given date string and     // returns true if the date is valid otherwise false.     // The date is valid if all of the following rules are satisfied:     // 1. The date string is not empty.     // 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.     // 3. The months should not be less than 1 or higher than 12.     // 4. The date should be in the format: mm-dd-yyyy     // >>> validDate(("03-11-2000"))     // (true)     // >>> validDate(("15-01-2012"))     // (false)     // >>> validDate(("04-0-2040"))     // (false)     // >>> validDate(("06-04-2020"))     // (true)     // >>> validDate(("06/04/2020"))     // (false)     public static boolean validDate(String date) {         boolean monthValid=false;         boolean dayValid=false;         boolean yearValid=false;         String dateStr=date;         String[] dates=dateStr.split("-");         try {             if(dates[0].length()==1||dates[1].length()==1||dates[2].length()==1)             return false;             if(dates[0].length()>2||dates[1].length()>2||dates[2].length()>4)             return false;         }         catch(Exception e) {             return false;         }         try {             if(Integer.parseInt(dates[0])>12||Integer.parseInt(dates[0])<1)             return false;             else {                 monthValid=true;             }         }         catch(Exception e) {             return false;         }         try {             if(Integer.parseInt(dates[1])>31||Integer.parseInt(dates[1])<1)             return false;             else {                 dayValid=true;             }         }         catch(Exception e) {             return false;         }         try {             if(Integer.parseInt(dates[2])>2020||Integer.parseInt(dates[2])<1900)             return false;             else {                 yearValid=true;             }         }         catch(Exception e) {             return false;         }         if(monthValid&&dayValid&&yearValid)         return true;         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function count_nums which takes an array array list of integers and returns     // the number of elements which has a sum of digits > 0.     // If a number is negative, then its first signed digit will be negative:     // e.g. -123 has signed digits -1, 2, and 3.     // >>> countNums((new ArrayList<Long>(Arrays.asList())))     // (0l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)-1l, (long)11l, (long)-11l))))     // (1l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)2l))))     // (3l)     public static long countNums(ArrayList<Long> arr) {         return arr.stream().map(num -> getSumDigits(Math.abs(num))).reduce(0l, Long::sum);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns an ordered version of it.     // Ordered version of string, is a string where all words (separated by space)     // are replaced by a new word where all the characters arranged in     // ascending order based on ascii value.     // Note: You should keep the order of words and blank spaces in the sentence.     // For example:     // >>> antiShuffle(("Hi"))     // ("Hi")     // >>> antiShuffle(("hello"))     // ("ehllo")     // >>> antiShuffle(("Hello World!!!"))     // ("Hello !!!Wdlor")     public static String antiShuffle(String s) {         String[] words = s.split(" ");         List<String> sortedWords = new ArrayList<String>();         for (String word : words) {             char[] chars = word.toCharArray();             Arrays.sort(chars);             sortedWords.add(new String(chars));         }         return String.join(" ", sortedWords);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Checks if given string is a palindrome     // >>> isPalindrome((""))     // (true)     // >>> isPalindrome(("aba"))     // (true)     // >>> isPalindrome(("aaaaa"))     // (true)     // >>> isPalindrome(("zbcd"))     // (false)     public static boolean isPalindrome(String text) {         return new StringBuilder(text).reverse().toString().equals(text);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a word. Your task is to find the closest vowel that stands between      // two consonants from the right side of the word (case sensitive).     // Vowels in the beginning and ending doesn't count. Return empty string if you didn't     // find any vowel met the above condition.      // You may assume that the given string contains English letter only.     // Example:     // >>> getClosestVowel(("yogurt"))     // ("u")     // >>> getClosestVowel(("FULL"))     // ("U")     // >>> getClosestVowel(("quick"))     // ("")     // >>> getClosestVowel(("ab"))     // ("")     public static String getClosestVowel(String word) {         String temp = word.toLowerCase();         String result = "";         int count = 0;         boolean vowel = false;         for (int i = 0; i < temp.length(); i++) {             if (temp.charAt(i) == 'a' || temp.charAt(i) == 'e' || temp.charAt(i) == 'i' || temp.charAt(i) == 'o' || temp.charAt(i) == 'u') {                 vowel = true;             } else if (temp.charAt(i) == ' ' && vowel == true) {                 count++;                 vowel = false;             }         }         if (count == 0) {             result = "";         } else {             result = temp.substring(count, count + 1);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if a given number is prime, and false otherwise.     // >>> isPrime((6l))     // (false)     // >>> isPrime((101l))     // (true)     // >>> isPrime((11l))     // (true)     // >>> isPrime((13441l))     // (true)     // >>> isPrime((61l))     // (true)     // >>> isPrime((4l))     // (false)     // >>> isPrime((1l))     // (false)     public static boolean isPrime(long n) {         return new java.math.BigInteger(Long.toString(n)).isProbablePrime(1);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to implement a function that will simplify the expression     // x * n. The function returns true if x * n evaluates to a whole number and false     // otherwise. Both x and n, are string representation of a fraction, and have the following format,     // <numerator>/<denominator> where both numerator and denominator are positive whole numbers.     // You can assume that x, and n are valid fractions, and do not have zero as denominator.     // >>> simplify(("1/5"), ("5/1"))     // (true)     // >>> simplify(("1/6"), ("2/1"))     // (false)     // >>> simplify(("7/10"), ("10/2"))     // (false)     public static boolean simplify(String x, String n) {         int x1 = Integer.parseInt(x);         int n1 = Integer.parseInt(n);         int common = gcd(x1, n1);         x1 = x1/common;         n1 = n1/common;         int x2 = Integer.parseInt(x);         int n2 = Integer.parseInt(n);         int common2 = gcd(x2, n2);         x2 = x2/common2;         n2 = n2/common2;         return x1 == n2 && n1 == x2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have been tasked to write a function that receives      // a hexadecimal number as a string and counts the number of hexadecimal      // digits that are primes (prime number, or a prime, is a natural number      // greater than 1 that is not a product of two smaller natural numbers).     // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.     // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...     // So you have to determine a number of the following digits: 2, 3, 5, 7,      // B (=decimal 11), D (=decimal 13).     // Note: you may assume the input is always correct or empty string,      // and symbols A,B,C,D,E,F are always uppercase.     // Examples:     // >>> hexKey(("AB"))     // (1l)     // >>> hexKey(("1077E"))     // (2l)     // >>> hexKey(("ABED1A33"))     // (4l)     // >>> hexKey(("123456789ABCDEF0"))     // (6l)     // >>> hexKey(("2020"))     // (2l)     public static long hexKey(String num) {         if (num.length() == 0) {             return 0;         }         List<Character> hexChars = new ArrayList<>();         for (char c: num.toCharArray()) {             if (c >= '0' && c <= '9') {                 hexChars.add(c);             } else if (c >= 'A' && c <= 'F') {                 hexChars.add(c);             }         }         return hexChars.stream()             .filter(c -> isPrime(c - '0'))             .count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string representing a sentence,     // the sentence contains some words separated by a space,     // and you have to return a string that contains the words from the original sentence,     // whose lengths are prime numbers,     // the order of the words in the new string should be the same as the original one.     // Example 1:     // >>> wordsInSentence(("This is a test"))     // ("is")     // Example 2:     // >>> wordsInSentence(("lets go for swimming"))     // ("go for")     // Constraints:     // * 1 <= len(sentence) <= 100     // * sentence contains only letters     public static String wordsInSentence(String sentence) {         // Write your code here         return sentence.split(" ").stream()                 .filter(w -> prime(Integer.parseInt(w)))                 .collect(Collectors.joining(" "));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string representing a space separated lowercase letters, return a hash map     // of the letter with the most repetition and containing the corresponding count.     // If several letters have the same occurrence, return all of them.     // Example:     // >>> histogram(("a b c"))     // (new HashMap<String,Long>(Map.of("a", 1l, "b", 1l, "c", 1l)))     // >>> histogram(("a b b a"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("a b c a b"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("b b b b a"))     // (new HashMap<String,Long>(Map.of("b", 4l)))     // >>> histogram((""))     // (new HashMap<String,Long>())     public static HashMap<String,Long> histogram(String test) {         HashMap<String,Long> m = new HashMap<String,Long>();         String[] a = test.split(" ");         for (String b: a) {             if (!m.containsKey(b))                 m.put(b, 1l);             else                 m.put(b, m.get(b)+1l);         }         return m;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a 2 dimensional data, as a nested array lists,     // which is similar to matrix, however, unlike matrices,     // each row may contain a different number of columns.     // Given lst, and integer x, find integers x in the array list,     // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that     // each pair is a coordinate - (row, columns), starting with 0.     // Sort coordinates initially by rows in ascending order.     // Also, sort coordinates of the row by columns in descending order.     // Examples:     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList()))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))     public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {         ArrayList<Pair<Long, Long>> ans = new ArrayList<Pair<Long, Long>>();         for (int i = 0; i < lst.size(); i++) {             if (lst.get(i).contains(x)) {                 Pair<Long, Long> pair = new Pair<Long, Long>(i, lst.get(i).indexOf(x));                 ans.add(pair);             }         }         ans.sort(new Comparator<Pair<Long, Long>>() {             public int compare(Pair<Long, Long> p1, Pair<Long, Long> p2) {                 if (p1.getValue0() != p2.getValue0()) {                     return p1.getValue0() < p2.getValue0() ? -1 : 1;                 } else {                     return p1.getValue1() < p2.getValue1() ? -1 : 1;                 }             }         });         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a sorted array list that has the odd numbers in collatz sequence.     // The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined     // as follows: start with any positive integer n. Then each term is obtained from the      // previous term as follows: if the previous term is even, the next term is one half of      // the previous term. If the previous term is odd, the next term is 3 times the previous     // term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.     // Note:      // 1. Collatz(1) is [1].     // 2. returned array list sorted in increasing order.     // For example:     // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.     // >>> getOddCollatz((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l)))     public static ArrayList<Long> getOddCollatz(long n) {         ArrayList<Long> res = new ArrayList<Long>();         while (n > 1) {             if (n % 2 == 1) {                 n = n * 3 + 1;                 res.add((long) n);             } else {                 n = n / 2;                 res.add((long) n);             }         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which returns the largest index of an element which     // is not greater than or equal to the element immediately preceding it. If     // no such element exists then return -1. The given array array list will not contain     // duplicate values.     // Examples:     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)3l, (long)5l))))     // (3l)     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (-1l)     public static long canArrange(ArrayList<Long> arr) {         for (int i = 0; i < arr.size(); i++) {             if (i == 0) {                 if (arr.get(i) >= arr.get(i + 1)) {                     return i;                 }             } else {                 if (arr.get(i) >= arr.get(i - 1)) {                     return i;                 }             }         }         return -1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input is a space-delimited string of numberals from 'zero' to 'nine'.     // Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.     // Return the string with numbers sorted from smallest to largest     // >>> sortNumbers(("three one five"))     // ("one three five")     public static String sortNumbers(String numbers) {         String[] numArray = numbers.split(" ");         Arrays.sort(numArray);         return String.join(" ", numArray);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Circular shift the digits of the integer x, shift the digits right by shift     // and return the result as a string.     // If shift > number of digits, return digits reversed.     // >>> circularShift((12l), (1l))     // ("21")     // >>> circularShift((12l), (2l))     // ("12")     public static String circularShift(long x, long shift) {         StringBuilder b = new StringBuilder(Long.toString(x));         while(shift>b.length()) {             b.append(b.charAt(0));             shift -= b.length();         }         b.reverse();         b.append(b.charAt(shift));         b.append(b.substring(0, shift));         b.reverse();         return b.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "     // This function will take an array array list of integers. For all entries in the array list, the function shall square the integer entry if its index is a      // multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not      // change the entries in the array list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.      // Examples:     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList())     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)-1l, (long)-5l, (long)2l, (long)-1l, (long)-5l))     public static long sumSquares(ArrayList<Long> lst) {         // "         // If the input is an empty list, simply return 0.         if(lst.size() == 0){             return 0;         }         // "         // If the input is not empty, calculate the sum of the squares of the entries with an index which is a multiple of 3.         long sum1 = 0;         for(int i = 0; i < lst.size(); i++){             if(i % 3 == 0){                 sum1 += Math.pow(lst.get(i).longValue(), 2);             }         }         // "         // Calculate the sum of the cubes of the entries with an index which is a multiple of 4 and not a multiple of 3.         long sum2 = 0;         for(int i = 0; i < lst.size(); i++){             if(i % 4 == 0 && i % 3 != 0){                 sum2 += Math.pow(lst.get(i).longValue(), 3);             }         }         // "         // The final result is the sum of the sums, sum1 and sum2.         return sum1 + sum2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // You need to find the largest prime value and return the sum of its digits.     // Examples:     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)3l, (long)2l, (long)1l, (long)3l, (long)5l, (long)7l, (long)4l, (long)5l, (long)5l, (long)5l, (long)2l, (long)181l, (long)32l, (long)4l, (long)32l, (long)3l, (long)2l, (long)32l, (long)324l, (long)4l, (long)3l))))     // (10l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)1l, (long)8l, (long)2l, (long)4597l, (long)2l, (long)1l, (long)3l, (long)40l, (long)1l, (long)2l, (long)1l, (long)2l, (long)4l, (long)2l, (long)5l, (long)1l))))     // (25l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)1l, (long)32l, (long)5107l, (long)34l, (long)83278l, (long)109l, (long)163l, (long)23l, (long)2323l, (long)32l, (long)30l, (long)1l, (long)9l, (long)3l))))     // (13l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)724l, (long)32l, (long)71l, (long)99l, (long)32l, (long)6l, (long)0l, (long)5l, (long)91l, (long)83l, (long)0l, (long)5l, (long)6l))))     // (11l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)81l, (long)12l, (long)3l, (long)1l, (long)21l))))     // (3l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)8l, (long)1l, (long)2l, (long)1l, (long)7l))))     // (7l)     public static long skjkasdkd(ArrayList<Long> lst) {         if (lst.isEmpty()) return 0;         long ans = 0;         List<Long> lst2 = lst.stream().filter(x -> x % 2 != 0).collect(Collectors.toList());         for (int i = 0; i < lst2.size(); i++) {             ans = ans + lst2.get(i);         }         ans = ans + skjkasdkd(lst.stream().filter(x -> x % 2 == 0).collect(Collectors.toList()));         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of integers, return a pair consisting of a sum and a product of all the integers in an array array list.     // Empty sum should be equal to 0 and empty product should be equal to 1.     // >>> sumProduct((new ArrayList<Long>(Arrays.asList())))     // (Pair.with(0l, 1l))     // >>> sumProduct((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (Pair.with(10l, 24l))     public static Pair<Long, Long> sumProduct(ArrayList<Long> numbers) {         long sum = 0;         long product = 1;         for (int i = 0; i < numbers.size(); i++) {             sum += numbers.get(i);             product *= numbers.get(i);         }         return Pair.with(sum, product);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes two positive numbers x and y and returns the     // biggest even integer number that is in the range [x, y] inclusive. If      // there's no such number, then the function should return -1.     // For example:     // >>> chooseNum((12l), (15l))     // (14l)     // >>> chooseNum((13l), (12l))     // (-1l)     public static long chooseNum(long x, long y) { 		if (x > y) { 			long temp = y; 			y = x; 			x = temp; 		} 		if (x % 2 == 0 && x <= y) return x; 		else if (y % 2 == 0 && y >= x) return y; 		else return -1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns a pair (a, b), where 'a' is     // the largest of negative integers, and 'b' is the smallest     // of positive integers in an array array list.     // If there is no negative or positive integers, return them as null.     // Examples:     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l, (long)7l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(1l))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList())))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     public static Pair<Optional<Long>, Optional<Long>> largestSmallestIntegers(ArrayList<Long> lst) {         Optional<Long> largestNeg = Optional.empty();         Optional<Long> smallestPos = Optional.empty();         for (Long n : lst) {             if (n < 0) {                 largestNeg = Optional.of(n);             }             if (n > 0) {                 smallestPos = Optional.of(n);             }         }         return Pair.with(largestNeg, smallestPos);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string, find out how many distinct characters (regardless of case) does it consist of     // >>> countDistinctCharacters(("xyzXYZ"))     // (3l)     // >>> countDistinctCharacters(("Jerry"))     // (4l)     public static long countDistinctCharacters(String string) {         // write your code here         // return (int) (string.replaceAll("\\s", "").replaceAll("[a-zA-Z]", "").length()-string.replaceAll("\\s", "").length()+string.length());         // return (int) (string.length() - string.replaceAll("[^a-z]","").length());         return string.replaceAll("\\s", "").replaceAll("[a-zA-Z]", "").length()-string.replaceAll("\\s", "").length()+string.length();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, you have to make a pile of n levels of stones.     // The first level has n stones.     // The number of stones in the next level is:     // - the next odd number if n is odd.     // - the next even number if n is even.     // Return the number of stones in each level in an array array list, where element at index     // i represents the number of stones in the level (i+1).     // Examples:     // >>> makeAPile((3l))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)7l)))     public static ArrayList<Long> makeAPile(long n) {         ArrayList<Long> list = new ArrayList<Long>();         if (n%2 == 0) {             for (long i = 2l; i <= n; i++) {                 list.add(i);             }         } else {             for (long i = 1l; i <= n; i++) {                 list.add(i);             }         }         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list arr of integers and you need to return     // sum of magnitudes of integers multiplied by product of all signs     // of each number in the array array list, represented by 1, -1 or 0.     // Note: return null for empty arr.     // Example:     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)-4l))))     // Optional.of(9l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l))))     // Optional.of(0l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     public static Optional<Long> prodSigns(ArrayList<Long> arr) {         //throw new UnsupportedOperationException("Please solve this problem first");         return arr.stream().map(x -> x.intValue() * (x.intValue() > 0 ? 1 : x.intValue() < 0 ? -1 : 0))                 .reduce(1L, (a, b) -> a * b);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers nums, find the minimum sum of any non-empty sub-array array list     // of nums.     // Example     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l, (long)1l, (long)2l, (long)4l))))     // (1l)     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l))))     // (-6l)     public static long minSubArraySum(ArrayList<Long> nums) {         long minSum = 0;         int min = Integer.MAX_VALUE;         for (int i = 0; i < nums.size(); i++) {             long sum = 0;             for (int j = i; j < nums.size(); j++) {                 sum += nums.get(j);                 if (sum < min) {                     min = sum;                     minSum = sum;                 }             }         }         return minSum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a string containing space-delimited numbers starting from 0 upto n inclusive.     // >>> stringSequence((0l))     // ("0")     // >>> stringSequence((5l))     // ("0 1 2 3 4 5")     public static String stringSequence(long n) {         return IntStream.rangeClosed(0, (int)n).mapToObj(String::valueOf).collect(Collectors.joining(" "));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word     // >>> cycpatternCheck(("abcd"), ("abd"))     // (false)     // >>> cycpatternCheck(("hello"), ("ell"))     // (true)     // >>> cycpatternCheck(("whassup"), ("psus"))     // (false)     // >>> cycpatternCheck(("abab"), ("baa"))     // (true)     // >>> cycpatternCheck(("efef"), ("eeff"))     // (false)     // >>> cycpatternCheck(("himenss"), ("simen"))     // (true)     public static boolean cycpatternCheck(String a, String b) {         String s = a.toLowerCase();         String x = b.toLowerCase();         char c[] = x.toCharArray();         int l = c.length;         int temp = l-1;         int max = 1;         String ans = "";         for(int i=0;i<l;i++){             ans = "";             for(int j=temp;j>=0;j--){                 ans = ans + c[j];             }             if(s.contains(ans)){                 return true;             }             temp--;         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true is array list elements are monotonically increasing or decreasing.     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)20l))))     // (true)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))))     // (false)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)0l, (long)-10l))))     // (true)     public static boolean monotonic(ArrayList<Long> l) {         return (l.stream().reduce((l1, l2) -> l1 < l2 ? true : false) == Boolean.TRUE)             || (l.stream().reduce((l1, l2) -> l1 > l2 ? true : false) == Boolean.TRUE);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Out of array list of strings, return the longest one. Return the first one in case of multiple     // strings of the same length. Return null in case the input array list is empty.     // >>> longest((new ArrayList<String>(Arrays.asList())))     // Optional.empty()     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // Optional.of("a")     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"bb", (String)"ccc"))))     // Optional.of("ccc")     public static Optional<String> longest(ArrayList<String> strings) {         Optional<String> max = Optional.empty();         Optional<Integer> maxLen = Optional.empty();         for (String s: strings) {             if (maxLen.isPresent() && s.length() > maxLen.get()) {                 max = Optional.of(s);                 maxLen = Optional.of(s.length());             } else if (!maxLen.isPresent() || s.length() == maxLen.get()) {                 max = Optional.of(s);             }         }         return max;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if all numbers in the array list l are below threshold t.     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)10l))), (100l))     // (true)     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))), (5l))     // (false)     public static boolean belowThreshold(ArrayList<Long> l, long t) {         return l.stream().allMatch(n -> n < t);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the given number is the multiplication of 3 prime numbers     // and false otherwise.     // Knowing that (a) is less then 100.      // Example:     // >>> isMultiplyPrime((30l))     // (true)     // 30 = 2 * 3 * 5     public static boolean isMultiplyPrime(long a) {         int flag = 0;         long b = a;         if(a == 1)             return false;         while(b > 1){             if(b % 2 == 0)                 b = b/2;             else if(b % 3 == 0)                 b = b/3;             else if(b % 5 == 0)                 b = b/5;             else{                 flag = 1;                 break;             }         }         if(flag == 1)             return false;         else             return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return only positive numbers in the array list.     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)-1l, (long)2l, (long)-4l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)6l)))     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)3l, (long)9l, (long)123l, (long)1l)))     public static ArrayList<Long> getPositive(ArrayList<Long> l) {         ArrayList<Long> positive = new ArrayList<Long>();         for (Long i : l) {             if (i > 0) {                 positive.add(i);             }         }         return positive;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal     // to the values of the corresponding indicies of l, but sorted.     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)5l)))     public static ArrayList<Long> sortThird(ArrayList<Long> l) {         ArrayList<Long> l_ = new ArrayList<>(l);         for (int i = 0; i < l.size(); i += 1) {             if (i % 3 == 0) {                 l_.set(i, l.get(i) * 2);                 continue;             }             l_.set(i, l.get(i));         }         l_.sort((a, b) -> a.compareTo(b));         return l_;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.     // For each of the group, output the deepest level of nesting of parentheses.     // E.g. (()()) has maximum two levels of nesting while ((())) has three.     // >>> parseNestedParens(("(()()) ((())) () ((())()())"))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))     public static ArrayList<Long> parseNestedParens(String paren_string) {         // TODO: Complete this function         ArrayList<Long> ret = new ArrayList<Long>();         int i = 0;         int prev_index = 0;         int level = 0;         while(i < paren_string.length()) {             if (i < paren_string.length() && paren_string.charAt(i) == '(') {                 level++;             }             if (i < paren_string.length() && paren_string.charAt(i) == ')') {                 level--;             }             if (level == 0 && prev_index != i) {                 ret.add((long) level);                 prev_index = i;                 level = 0;             }             i++;         }         return ret;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given length of a side and high return area for a triangle.     // >>> triangleArea((5l), (3l))     // (7.5f)     public static float triangleArea(long a, long h) {         return (float) ((a * h)/2);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Complete the function that takes two integers and returns      // the product of their unit digits.     // Assume the input is always valid.     // Examples:     // >>> multiply((148l), (412l))     // (16l)     // >>> multiply((19l), (28l))     // (72l)     // >>> multiply((2020l), (1851l))     // (0l)     // >>> multiply((14l), (-15l))     // (20l)     public static long multiply(long a, long b) {         if (a < 0) {             a = -a;         }         if (b < 0) {             b = -b;         }         return a % 10 * b % 10;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of input numbers, calculate Mean Absolute Deviation     // around the mean of this dataset.     // Mean Absolute Deviation is the average absolute difference between each     // element and a centerpoint (mean in this case):     // MAD = average | x - x_mean |     // >>> meanAbsoluteDeviation((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f))))     // (1.0f)     public static float meanAbsoluteDeviation(ArrayList<Float> numbers) {         // if no inputs         if (numbers == null || numbers.size() == 0) {             return 0.0f;         }         // if only one input         if (numbers.size() == 1) {             return 0.0f;         }         // calculate mean         float mean = (float)numbers.stream().reduce(Float::sum) / numbers.size();         // calculate deviation         float sum = 0.0f;         for (int i = 0; i < numbers.size(); i++) {             sum += Math.abs(mean - numbers.get(i));         }         return sum / numbers.size();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique common elements for two array lists.     // >>> common((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l, (long)34l, (long)653l, (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)1l, (long)5l, (long)9l, (long)653l, (long)121l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)653l)))     // >>> common((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     public static ArrayList<Long> common(ArrayList<Long> l1, ArrayList<Long> l2) {         TreeSet<Long> set = new TreeSet<Long>();         for (int i = 0; i < l1.size(); i++) {             set.add(l1.get(i));         }         for (int i = 0; i < l2.size(); i++) {             if (set.contains(l2.get(i))) {                 set.remove(l2.get(i));             }         }         return new ArrayList<Long>(set);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer, obtain its roman numeral equivalent as a string,     // and return it in lowercase.     // Restrictions: 1 <= num <= 1000     // Examples:     // >>> intToMiniRoman((19l))     // ("xix")     // >>> intToMiniRoman((152l))     // ("clii")     // >>> intToMiniRoman((426l))     // ("cdxxvi")     public static String intToMiniRoman(long number) {         String[] symbols = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};         String[] letters = {"C", "X", "L", "XC", "M"};         List<Triplet<Long, Long, Integer>> divisions = new ArrayList<Triplet<Long, Long, Integer>>();         long currentDivision = 1000L;         while (currentDivision <= number) {             Triplet<Long, Long, Integer> division = Triplet.with(currentDivision, number % currentDivision, (int) Math.log10(currentDivision));             divisions.add(division);             currentDivision *= 10;         }         divisions.sort((division1, division2) -> {             return Long.compare(division1.getValue0(), division2.getValue0());         });         StringBuilder roman = new StringBuilder();         for (Triplet<Long, Long, Integer> division : divisions) {             long value = division.getValue1();             int power = division.getValue2();             long count = value / 10;             if (count > 0) {                 roman.append(symbols[power]);                 value -= count * 10;                 count = value / 10;                 if (count > 0) {                     roman.append(symbols[power + 1]);                     value -= count * 10;                 }             }             while (value > 0) {                 roman.append(letters[power]);                 value -= 1;             }         }         return roman.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this task, you will be given a string that represents a number of apples and oranges      // that are distributed in a basket of fruit this basket contains      // apples, oranges, and mango fruits. Given the string that represents the total number of      // the oranges and apples and an integer that represent the total number of the fruits      // in the basket return the number of the mango fruits in the basket.     // for examble:     // >>> fruitDistribution(("5 apples and 6 oranges"), (19l))     // (8l)     // >>> fruitDistribution(("0 apples and 1 oranges"), (3l))     // (2l)     // >>> fruitDistribution(("2 apples and 3 oranges"), (100l))     // (95l)     // >>> fruitDistribution(("100 apples and 1 oranges"), (120l))     // (19l)     public static long fruitDistribution(String s, long n) {         String[] s1 = s.split(" ");         String a = s1[0];         String b = s1[1];         long aa = 0, bb = 0;         if (a.contains("apples")) {             aa = Long.parseLong(a.split("apples")[1].split(" ")[0]);         } else if (a.contains("apples and")) {             aa = Long.parseLong(a.split("apples and")[1].split(" ")[0]);         } else if (a.contains("apples and oranges")) {             aa = Long.parseLong(a.split("apples and oranges")[1].split(" ")[0]);         } else if (a.contains("apples and oranges and")) {             aa = Long.parseLong(a.split("apples and oranges and")[1].split(" ")[0]);         } else if (a.contains("apples and oranges and mango")) {             aa = Long.parseLong(a.split("apples and oranges and mango")[1].split(" ")[0]);         } else if (a.contains("apples and oranges and mango and")) {             aa = Long.parseLong(a.split("apples and oranges and mango and")[1].split(" ")[0]);         } else if (a.contains("apples and oranges and mango and pineapple")) {             aa = Long.parseLong(a.split("apples and oranges and mango and pineapple")[1].split(" ")[0]);         } else if (a.contains("apples and oranges and mango and pineapple and")) {             aa = Long.parseLong(a.split("apples and oranges and mango and pineapple and")[1].split(" ")[0]);         } else if (a.contains("apples and oranges and mango and pineapple and strawberry")) {             aa = Long.parseLong(a.split("apples and oranges and mango and pineapple and strawberry")[1].split(" ")[0]);         } else if (a.contains("apples and oranges and mango and pineapple and strawberry and")) {             aa = Long.parseLong(a.split("apples and oranges and mango and pineapple and strawberry and")[1].split(" ")[0]);         } else if (a.contains("apples and oranges and mango and pineapple and strawberry and orange")) {             aa = Long.parseLong(a.split("apples and oranges and mango and pineapple and strawberry and orange")[1].split(" ")[0]);         } else if (a.contains("apples and oranges and mango and pineapple and strawberry and orange and")) {             aa = Long.parseLong(a.split("apples and oranges and mango and pineapple and strawberry and orange and")[1].split(" ")[0]);         } else if (a.contains
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c     // then check if the result string is palindrome.     // A string is called palindrome if it reads the same backward as forward.     // You should return a pair containing the result string and true/false for the check.     // Example     // >>> reverseDelete(("abcde"), ("ae"))     // (Pair.with("bcd", false))     // >>> reverseDelete(("abcdef"), ("b"))     // (Pair.with("acdef", false))     // >>> reverseDelete(("abcdedcba"), ("ab"))     // (Pair.with("cdedc", true))     public static Pair<String, Boolean> reverseDelete(String s, String c) {         List<String> list = new ArrayList<>();         Set<String> set = new HashSet<>();         for (String val : c.split("")) {             set.add(val);         }          char[] chars = s.toCharArray();         for (int i = 0; i < chars.length; i++) {             if (set.contains(String.valueOf(chars[i]))) {                 list.add(String.valueOf(chars[i]));             }         }         StringBuilder sb = new StringBuilder();         for (int i = 0; i < chars.length; i++) {             if (!list.contains(String.valueOf(chars[i]))) {                 sb.append(chars[i]);             }         }         return new Pair<>(sb.toString(), checkPalindrome(sb.toString()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a greatest common divisor of two integers a and b     // >>> greatestCommonDivisor((3l), (5l))     // (1l)     // >>> greatestCommonDivisor((25l), (15l))     // (5l)     public static long greatestCommonDivisor(long a, long b) {         if (a == b) return a;         if (a == 0) return b;         if (b == 0) return a;         return greatestCommonDivisor(b, a % b);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this Kata, you have to sort an array array list of non-negative integers according to     // number of ones in their binary representation in ascending order.     // For similar number of ones, sort based on decimal value.     // It must be implemented like this:     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)-2l, (long)-3l, (long)-4l, (long)-5l, (long)-6l))))     // (new ArrayList<Long>(Arrays.asList((long)-6l, (long)-5l, (long)-4l, (long)-3l, (long)-2l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l)))     public static ArrayList<Long> sortArray(ArrayList<Long> arr) {         Comparator<Long> comparator = new Comparator<Long>() {             @Override             public int compare(Long a, Long b) {                 int lengthA = (int) Integer.bitCount(a.longValue());                 int lengthB = (int) Integer.bitCount(b.longValue());                  if (lengthA == lengthB) {                     return (int) (a.longValue() - b.longValue());                 } else {                     return lengthB - lengthA;                 }             }         };          Collections.sort(arr, comparator);         return arr;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Concatenate array list of strings into a single string     // >>> concatenate((new ArrayList<String>(Arrays.asList())))     // ("")     // >>> concatenate((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // ("abc")     public static String concatenate(ArrayList<String> strings) {         StringBuilder sb = new StringBuilder();         for (String s : strings) {             sb.append(s);         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings as a parameter,     // deletes the strings that have odd lengths from it,     // and returns the resulted array list with a sorted order,     // The array list is always an array array list of strings and never an array array list of numbers,     // and it may contain duplicates.     // The order of the array list should be ascending by length of each word, and you     // should return the array list sorted by that rule.     // If two words have the same length, sort the array list alphabetically.     // The function should return an array array list of strings in sorted order.     // You may assume that all words will have the same length.     // For example:     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"aa", (String)"a", (String)"aaa"))))     // (new ArrayList<String>(Arrays.asList((String)"aa")))     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"ab", (String)"a", (String)"aaa", (String)"cd"))))     // (new ArrayList<String>(Arrays.asList((String)"ab", (String)"cd")))     public static ArrayList<String> sortedListSum(ArrayList<String> lst) {         ArrayList<String> res = new ArrayList<String>();         for (String s : lst) {             if (s.length() % 2 == 0) {                 res.add(s);             }         }         Collections.sort(res);         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that contain given substring     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"array")))     public static ArrayList<String> filterBySubstring(ArrayList<String> strings, String substring) {         return strings.stream().filter(s -> s.contains(substring)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a value (string) representing a number     // and returns the closest integer to it. If the number is equidistant     // from two integers, round it away from zero.     // Examples     // >>> closestInteger(("10"))     // (10l)     // >>> closestInteger(("15.3"))     // (15l)     // Note:     // Rounding away from zero means that if the given number is equidistant     // from two integers, the one you should return is the one that is the     // farthest from zero. For example closest_integer("14.5") should     // return 15 and closest_integer("-14.5") should return -15.     public static long closestInteger(String value) {         long num = Long.parseLong(value);         if (num % 2 == 0) {             return num;         } else {             return num + 1;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function vowels_count which takes a string representing     // a word as input and returns the number of vowels in the string.     // Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a     // vowel, but only when it is at the end of the given word.     // Example:     // >>> vowelsCount(("abcde"))     // (2l)     // >>> vowelsCount(("ACEDY"))     // (3l)     public static long vowelsCount(String s) {         long count = 0;         if (s == null || s.length() == 0) {             return count;         }         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == 'a' || s.charAt(i) == 'e' || s.charAt(i) == 'i' || s.charAt(i) == 'o' || s.charAt(i) == 'u' || s.charAt(i) == 'y' && i == s.length() - 1) {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings.     // The array list contains different words. Return the word with maximum number     // of unique characters. If multiple strings have maximum number of unique     // characters, return the one which comes first in lexicographical order.     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"of", (String)"string"))))     // ("string")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"enam", (String)"game"))))     // ("enam")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"aaaaaaa", (String)"bb", (String)"cc"))))     // ("aaaaaaa")     public static String findMax(ArrayList<String> words) {         String max = "";         for(String s : words) {             char[] cs = s.toCharArray();             Arrays.sort(cs);             if(cs.length > max.length()) {                 max = s;             } else if(cs.length == max.length()) {                 if(s.compareTo(max) < 0) {                     max = s;                 }             }         }         return max;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string 'text', return its md5 hash equivalent string.     // If 'text' is an empty string, return null.     // >>> stringToMd5(("Hello world"))     // Optional.of("3e25960a79dbc69b674cd4ec67a72c62")     public static Optional<String> stringToMd5(String text) {         if(text.isEmpty()) return null;         try{             MessageDigest md = MessageDigest.getInstance("MD5");             md.update(text.getBytes(), 0, text.length());             return Optional.of(bytesToString(md.digest()));         } catch(NoSuchAlgorithmException e){             return Optional.empty();         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Change numerical base of input number x to base.     // return string representation after the conversion.     // base numbers are less than 10.     // >>> changeBase((8l), (3l))     // ("22")     // >>> changeBase((8l), (2l))     // ("1000")     // >>> changeBase((7l), (2l))     // ("111")     public static String changeBase(long x, long base) {         if(x==0) return "0";         long digits[] = new long[64];         int position = 0;         while(x != 0) {             digits[position++] = x % base;             x = x / base;         }         StringBuilder str = new StringBuilder();         for(int i = position - 1; i >= 0; i--) {             str.append(digits[i]);         }         return str.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return true if the three     // sides form a right-angled triangle, false otherwise.     // A right-angled triangle is a triangle in which one angle is right angle or      // 90 degree.     // Example:     // >>> rightAngleTriangle((3l), (4l), (5l))     // (true)     // >>> rightAngleTriangle((1l), (2l), (3l))     // (false)     public static boolean rightAngleTriangle(long a, long b, long c) {         return (a * a + b * b == c * c);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // It is the last week of the semester and the teacher has to give the grades     // to students. The teacher has been making her own algorithm for grading.     // The only problem is, she has lost the code she used for grading.     // She has given you an array array list of GPAs for some students and you have to write      // a function that can output an array array list of letter grades using the following table:     // GPA       |    Letter grade     // 4.0                A+     // > 3.7                A      // > 3.3                A-      // > 3.0                B+     // > 2.7                B      // > 2.3                B-     // > 2.0                C+     // > 1.7                C     // > 1.3                C-     // > 1.0                D+      // > 0.7                D      // > 0.0                D-     // 0.0                E     // Example:     // >>> gradeEquation((new ArrayList<Float>(Arrays.asList((float)4.0f, (float)3l, (float)1.7f, (float)2l, (float)3.5f))))     // (new ArrayList<String>(Arrays.asList((String)"A+", (String)"B", (String)"C-", (String)"C", (String)"A-")))     public static ArrayList<String> numericalLetterGrade(ArrayList<Float> grades) {         ArrayList<String> letterGrade = new ArrayList<>();         ArrayList<Float> numericalGrade = new ArrayList<>();         ArrayList<String> result = new ArrayList<>();         ArrayList<Float> c = new ArrayList<>();         ArrayList<String> g = new ArrayList<>();         ArrayList<Float> h = new ArrayList<>();         float r = 0;         float t = 0;         float l = 0;         int i = 0;         int j = 0;         int k = 0;         int a = 0;         for (Float b : grades) {             if (b > 3.7) {                 c.add(b);                 i = i + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 3.3) {                 h.add(b);                 k = k + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 3) {                 l = l + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 2.7) {                 r = r + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 2.3) {                 t = t + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 2) {                 a = a + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 1.7) {                 j = j + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 1.3) {                 j = j + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 1) {                 j = j + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 0.7) {                 j = j + 1;                 result.add(String.valueOf(g.get(j)));             } else if (b > 0) {                 j = j + 1;                 result.add(String.
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Insert a number 'delimeter' between every two consecutive elements of input array list `numbers'     // >>> intersperse((new ArrayList<Long>(Arrays.asList())), (4l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> intersperse((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))), (4l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)4l, (long)3l)))     public static ArrayList<Long> intersperse(ArrayList<Long> numbers, long delimeter) {         ArrayList<Long> result = new ArrayList<Long>();         for (int i = 0; i < numbers.size(); i++) {             result.add(numbers.get(i));             if (i != numbers.size() - 1) {                 result.add(delimeter);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an array array list of numbers as input and returns      // the number of elements in the array array list that are greater than 10 and both      // first and last digits of a number are odd (1, 3, 5, 7, 9).     // For example:     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)15l, (long)-73l, (long)14l, (long)-15l))))     // (1l)     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)33l, (long)-2l, (long)-3l, (long)45l, (long)21l, (long)109l))))     // (2l)     public static long specialFilter(ArrayList<Long> nums) {         return nums.stream().filter((num)->{             return (num > 10 && (num % 10 == 1 || num % 10 == 3 || num % 10 == 5 || num % 10 == 7 || num % 10 == 9)) && (num / 10 == 1 || num / 10 == 3 || num / 10 == 5 || num / 10 == 7 || num / 10 == 9);         }).count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // sum_to_n is a function that sums numbers from 1 to n.     // >>> sumToN((30l))     // (465l)     // >>> sumToN((100l))     // (5050l)     // >>> sumToN((5l))     // (15l)     // >>> sumToN((10l))     // (55l)     // >>> sumToN((1l))     // (1l)     public static long sumToN(long n) {         return n * (n + 1) / 2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From an array array list of integers, remove all elements that occur more than once.     // Keep order of elements left the same as in the input.     // >>> removeDuplicates((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)4l)))     public static ArrayList<Long> removeDuplicates(ArrayList<Long> numbers) {         ArrayList<Long> newNumbers = new ArrayList<>();         for (long num: numbers) {             if (!newNumbers.contains(num)) {                 newNumbers.add(num);             }         }         return newNumbers;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two positive integers a and b, return the even digits between a     // and b, in ascending order.     // For example:     // >>> generateIntegers((2l), (8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((8l), (2l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((10l), (14l))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> generateIntegers(long a, long b) {         ArrayList<Long> res = new ArrayList<>();         if(a > b) {             return res;         }         for (int i = a; i <= b; i++) {             if (i % 2 == 0) {                 res.add((long)i);             }         }         Collections.sort(res);         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a given array list of integers, generate an array array list of rolling maximum element found until given moment     // in the sequence.     // >>> rollingMax((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)3l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l)))     public static ArrayList<Long> rollingMax(ArrayList<Long> numbers) {         int length = numbers.size();         ArrayList<Long> rollingMax = new ArrayList<Long>(Collections.nCopies(length, 0L));         for (int i = 0; i < length; i++) {             rollingMax.set(i, Collections.max(numbers.subList(i, length)));         }         return rollingMax;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're given an array array list of deposit and withdrawal operations on a bank account that starts with     // zero balance. Your task is to detect if at any point the balance of account fallls below zero, and     // at that point function should return true. Otherwise it should return false.     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (false)     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)-4l, (long)5l))))     // (true)     public static boolean belowZero(ArrayList<Long> operations) {         long sum = 0;         for (long i : operations) {             sum += i;             if (sum < 0) {                 return true;             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a non-empty array list of positive integers. Return the greatest integer that is greater than      // zero, and has a frequency greater than or equal to the value of the integer itself.      // The frequency of an integer is the number of times it appears in the array list.     // If no such a value exist, return -1.     // Examples:     // >>> search((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)2l, (long)2l, (long)3l, (long)1l))))     // (2l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l, (long)4l))))     // (3l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)4l, (long)4l, (long)4l))))     // (-1l)     public static long search(ArrayList<Long> lst) {         long answer = 0L;         int answerCount = 0;         long max = 0L;         Map<Long, Integer> map = new HashMap<>();         for (long i : lst) {             if (map.containsKey(i)) {                 map.put(i, map.get(i) + 1);             } else {                 map.put(i, 1);             }         }         for (long i : lst) {             if (map.get(i) > i) {                 answer = i;                 answerCount = map.get(i);             }             if (map.get(i) > max) {                 max = map.get(i);             }         }         if (answerCount == max) {             answer = answer;         } else {             answer = -1;         }         return answer;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "(" and ")".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("("))     // (false)     // >>> correctBracketing(("()"))     // (true)     // >>> correctBracketing(("(()())"))     // (true)     // >>> correctBracketing((")(()"))     // (false)     public static boolean correctBracketing(String brackets) {         Stack<Character> bracketStack = new Stack<>();         for (char c : brackets.toCharArray()) {             if (c == '(') {                 bracketStack.push('(');             } else if (c == ')') {                 if (bracketStack.isEmpty()) {                     return false;                 } else {                     bracketStack.pop();                 }             }         }         return bracketStack.isEmpty();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the odd indicies, while its values at the even indicies are equal     // to the values of the even indicies of l, but sorted.     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)6l, (long)5l, (long)4l)))     public static ArrayList<Long> sortEven(ArrayList<Long> l) {         return (ArrayList<Long>)l.stream().map((Long v) -> {             if (l.indexOf(v) % 2 == 0) {                 return v;             } else {                 return v;             }         }).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if two words have the same characters.     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddeddabc"))     // (true)     // >>> sameChars(("abcd"), ("dddddddabc"))     // (true)     // >>> sameChars(("dddddddabc"), ("abcd"))     // (true)     // >>> sameChars(("eabcd"), ("dddddddabc"))     // (false)     // >>> sameChars(("abcd"), ("dddddddabce"))     // (false)     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddddabc"))     // (false)     public static boolean sameChars(String s0, String s1) {         char[] c0 = s0.toCharArray();         char[] c1 = s1.toCharArray();         if (c0.length == c1.length) {             for (int i = 0; i < c0.length; i++) {                 if (c0[i] != c1[i]) {                     return false;                 }             }             return true;         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "<" and ">".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("<"))     // (false)     // >>> correctBracketing(("<>"))     // (true)     // >>> correctBracketing(("<<><>>"))     // (true)     // >>> correctBracketing(("><<>"))     // (false)     public static boolean correctBracketing(String brackets) {         Stack<String> stack = new Stack<String>();         for (String c: brackets.split("")) {             if ("<".equals(c)) {                 stack.push("<");             } else {                 if (!stack.isEmpty()) {                     stack.pop();                 } else {                     return false;                 }             }         }         return stack.isEmpty();
