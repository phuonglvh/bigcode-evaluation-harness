import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return length of given string     // >>> stringLength((""))     // (0l)     // >>> stringLength(("abc"))     // (3l)     public static long strlen(String string) {         return string.length();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function encrypt that takes a string as an argument and     // returns a string encrypted with the alphabet being rotated.      // The alphabet should be rotated in a manner such that the letters      // shift down by two multiplied to two places.     // For example:     // >>> encrypt(("hi"))     // ("lm")     // >>> encrypt(("asdfghjkl"))     // ("ewhjklnop")     // >>> encrypt(("gf"))     // ("kj")     // >>> encrypt(("et"))     // ("ix")     public static String encrypt(String s) {         return s;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a hash map, return true if all keys are strings in lower      // case or all keys are strings in upper case, else return false.     // The function should return false is the given hash map is empty.     // Examples:     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "b", "banana"))))     // (true)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "A", "banana", "B", "banana"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", 8l, "banana", "a", "apple"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("Name", "John", "Age", "36", "City", "Houston"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("STATE", "NC", "ZIP", "12345"))))     // (true)     public static boolean checkDictCase(HashMap<String,String> dict) {         if(dict.isEmpty()){             return false;         }         return dict.keySet().stream().allMatch(i -> i.matches("[a-zA-Z]+$")) || dict.keySet().stream().allMatch(i -> i.matches("[A-Z]+$"));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers lst. add the even elements that are at odd indices..     // Examples:     // >>> add((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)6l, (long)7l))))     // (2l)     public static long add(ArrayList<Long> lst) {         return Stream.of(lst).filter(e -> e % 2 == 0).sorted(Comparator.comparing(o -> o)).skip(1).reduce(0l, (a, b) -> a + b);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string text, replace all spaces in it with underscores,      // and if a string has more than 2 consecutive spaces,      // then replace all consecutive spaces with -      // >>> fixSpaces((" Example"))     // ("Example")     // >>> fixSpaces((" Example 1"))     // ("Example_1")     // >>> fixSpaces((" Example 2"))     // ("_Example_2")     // >>> fixSpaces((" Example 3"))     // ("_Example-3")     public static String fixSpaces(String text) {         return text.replaceAll("\\s+", "_");
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fibfib(0) == 0     // fibfib(1) == 0     // fibfib(2) == 1     // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).     // Please write a function to efficiently compute the n-th element of the fibfib number sequence.     // >>> fibfib((1l))     // (0l)     // >>> fibfib((5l))     // (4l)     // >>> fibfib((8l))     // (24l)     public static long fibfib(long n) {         // fib(n) = fib(n-1) + fib(n-2)         long fib0 = 0;         long fib1 = 0;         long fib2 = 1;         for (int i = 0; i < n; i++) {             long temp = fib0;             fib0 = fib1;             fib1 = fib2;             fib2 = fib0 + fib1;         }         return fib2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return the sum of squares of the numbers     // in the array list that are odd. Ignore numbers that are negative or not integers.     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)0l))))     // (10l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)-1l, (long)-2l, (long)0l))))     // (0l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)9l, (long)-2l))))     // (81l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)0l))))     // (0l)     // If the input array list is empty, return 0.     public static long doubleTheDifference(ArrayList<Float> lst) {         // Write your code here         Long sum = lst.stream().filter(n -> n%2 != 0).map(n -> n*n).reduce(0, Long::sum);         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter given array list of any javathon values only for integers     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList((String)"a", (String)3.14f, (String)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList(1l, 2l, 3l, "abc", new HashMap<Long,Long>(Map.of()), new ArrayList<Long>(Arrays.asList())))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     public static ArrayList<Long> filterIntegers(ArrayList<Object> values) {         return values.stream()                     .filter(v -> v instanceof Long || v instanceof Integer)                     .map(v -> (v instanceof Long) ? (Long)v : (long)(int)v)                     .collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Imagine a road that's a perfectly straight infinitely long line.     // n cars are driving left to right;  simultaneously, a different set of n cars     // are driving right to left.   The two sets of cars start out being very far from     // each other.  All cars move in the same speed.  Two cars are said to collide     // when a car that's moving left to right hits a car that's moving right to left.     // However, the cars are infinitely sturdy and strong; as a result, they continue moving     // in their trajectory as if they did not collide.     // This function outputs the number of such collisions.     public static long carRaceCollision(long n) {         long left = 0, right = n-1;         if (n % 2 == 0)             return n / 2;         else             return n / 2 + 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string representing musical notes in a special ASCII format.     // Your task is to parse this string and return array list of integers corresponding to how many beats does each     // not last.     // Here is a legend:     // 'o' - whole note, lasts four beats     // 'o|' - half note, lasts two beats     // '.|' - quater note, lasts one beat     // >>> parseMusic(("o o| .| o| o| .| .| .| .| o o"))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)1l, (long)2l, (long)2l, (long)1l, (long)1l, (long)1l, (long)1l, (long)4l, (long)4l)))     public static ArrayList<Long> parseMusic(String music_string) {         int index = 0;         int[] arr = new int[music_string.length()];         for (int i = 0; i < music_string.length(); i++) {             char ch = music_string.charAt(i);             if (ch == 'o') arr[i] = 4;             else if (ch == 'o|') arr[i] = 2;             else if (ch == '.|') arr[i] = 1;         }         return new ArrayList<>(Arrays.stream(arr).mapToLong(e -> e).boxed().collect(Collectors.toList()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a number in decimal form and your task is to convert it to     // binary format. The function should return a string, with each character representing a binary     // number. Each character in the string will be '0' or '1'.     // There will be an extra couple of characters 'db' at the beginning and at the end of the string.     // The extra characters are there to help with the format.     // Examples:     // >>> decimalToBinary((15l))     // ("db1111db")     // >>> decimalToBinary((32l))     // ("db100000db")     public static String decimalToBinary(long decimal) {         String s = String.format("%32s", Long.toBinaryString(decimal)).replace(" ", "0");         return "db" + s + "db";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of all prefixes from shortest to longest of the input string     // >>> allPrefixes(("abc"))     // (new ArrayList<String>(Arrays.asList((String)"a", (String)"ab", (String)"abc")))     public static ArrayList<String> allPrefixes(String string) {         ArrayList<String> ret = new ArrayList<>();         for(int i = 0; i <= string.length(); i++)             ret.add(string.substring(0, i));         return ret;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Add two numbers x and y     // >>> add((2l), (3l))     // (5l)     // >>> add((5l), (7l))     // (12l)     public static long add(long x, long y) {         return x + y;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're a hungry rabbit, and you already have eaten a certain number of carrots,     // but now you need to eat more carrots to complete the day's meals.     // you should return an array array list of [ total number of eaten carrots after your meals,     // the number of carrots left after your meals ]     // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.     // Example:     // >>> eat((5l), (6l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)4l)))     // >>> eat((4l), (8l), (9l))     // (new ArrayList<Long>(Arrays.asList((long)12l, (long)1l)))     // >>> eat((1l), (10l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)0l)))     // >>> eat((2l), (11l), (5l))     // (new ArrayList<Long>(Arrays.asList((long)7l, (long)0l)))     // Variables:     // @number : integer     // the number of carrots that you have eaten.     // @need : integer     // the number of carrots that you need to eat.     // @remaining : integer     // the number of remaining carrots thet exist in stock     // Constrain:     // * 0 <= number <= 1000     // * 0 <= need <= 1000     // * 0 <= remaining <= 1000     // Have fun :)     public static ArrayList<Long> eat(long number, long need, long remaining) {         // your code here         if(need > remaining){             ArrayList<Long> myList = new ArrayList<Long>();             myList.add(number + remaining);             myList.add(0l);             return myList;         }else{             ArrayList<Long> myList = new ArrayList<Long>();             myList.add(number + need);             myList.add(remaining - need);             return myList;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a rectangular grid of wells. Each row represents a single well,     // and each 1 in a row represents a single unit of water.     // Each well has a corresponding bucket that can be used to extract water from it,      // and all buckets have the same capacity.     // Your task is to use the buckets to empty the wells.     // Output the number of times you need to lower the buckets.     // Example 1:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l))))), (1l))     // (6l)     // Example 2:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)1l, (long)1l))))), (2l))     // (5l)     // Example 3:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l))))), (5l))     // (0l)     // Constraints:     // * all wells have the same length     // * 1 <= grid.length <= 10^2     // * 1 <= grid[:,1].length <= 10^2     // * grid[i][j] -> 0 | 1     // * 1 <= capacity <= 10     public static long maxFill(ArrayList<ArrayList<Long>> grid, long capacity) {         // Write your code here         return 0l;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two array lists operator, and operand. The first array list has basic algebra operations, and      // the second array list is an array array list of integers. Use the two given array lists to build the algebric      // expression and return the evaluation of this expression.     // The basic algebra operations:     // Addition ( + )      // Subtraction ( - )      // Multiplication ( * )      // Floor division ( // )      // Exponentiation ( ** )      // Example:     // operator['+', '*', '-']     // array array list = [2, 3, 4, 5]     // result = 2 + 3 * 4 - 5     // => result = 9     // Note:     // The length of operator array list is equal to the length of operand array list minus one.     // Operand is an array array list of of non-negative integers.     // Operator array list has at least one operator, and operand array list has at least two operands.     public static long doAlgebra(ArrayList<String> op, ArrayList<Long> operand) {         long result = 0;         for (int i = 0; i < operand.size(); i++) {             result += operand.get(i);             if (op.get(i).equals("+")) {                 continue;             } else if (op.get(i).equals("-")) {                 result *= -1;             } else if (op.get(i).equals("*")) {                 continue;             } else if (op.get(i).equals("//")) {                 result /= operand.get(i + 1);                 i++;             } else if (op.get(i).equals("**")) {                 result = (long)Math.pow(result, operand.get(i + 1));                 i++;             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given string, flip lowercase characters to uppercase and uppercase to lowercase.     // >>> flipCase(("Hello"))     // ("hELLO")     public static String flipCase(String string) {         String result = "";         for (char c : string.toCharArray()) {             if (Character.isUpperCase(c)) {                 result += Character.toLowerCase(c);             } else {                 result += Character.toUpperCase(c);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers, sort the integers that are between 1 and 9 inclusive,     // reverse the resulting array array list, and then replace each digit by its corresponding name from     // "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".     // For example:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l, (long)1l, (long)4l, (long)5l, (long)8l, (long)2l, (long)3l))))     // (new ArrayList<String>(Arrays.asList((String)"Eight", (String)"Five", (String)"Four", (String)"Three", (String)"Two", (String)"Two", (String)"One", (String)"One")))     // If the array array list is empty, return an empty array array list:     // >>> byLength((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // If the array array list has any strange number ignore it:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)55l))))     // (new ArrayList<String>(Arrays.asList((String)"One")))     public static ArrayList<String> byLength(ArrayList<Long> arr) {         if (arr.size() == 0) {             return new ArrayList<String>();         }         ArrayList<String> ans = new ArrayList<String>(arr.size());         for (Long i : arr) {             if (i >= 1l && i <= 9l) {                 ans.add(toWords(i));             }         }         Collections.sort(ans, Collections.reverseOrder());         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of prime factors of given integer in the order from smallest to largest.     // Each of the factors should be array listed number of times corresponding to how many times it appeares in factorization.     // Input number should be equal to the product of all factors     // >>> factorize((8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)2l)))     // >>> factorize((25l))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l)))     // >>> factorize((70l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)7l)))     public static ArrayList<Long> factorize(long n) {         ArrayList<Long> factors = new ArrayList<Long>();         for(int i=2; i<n; i++) {             while(n%i==0) {                 factors.add(new Long(i));                 n /= i;             }         }         if(n!=1) factors.add(new Long(n));         return factors;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement a function that takes an non-negative integer and returns an array array list of the first n     // integers that are prime numbers and less than n.     // for example:     // >>> countUpTo((5l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     // >>> countUpTo((11l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l)))     // >>> countUpTo((0l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((20l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l, (long)19l)))     // >>> countUpTo((1l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((18l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l)))     public static ArrayList<Long> countUpTo(long n) {         // Please do not change the code below         ArrayList<Long> primes = new ArrayList<Long>();         // Your code here         for (long i = 2; i < n; i++) {             boolean isPrime = true;             for (long j = 2; j < i; j++) {                 if (i % j == 0) {                     isPrime = false;                     break;                 }             }             if (isPrime) {                 primes.add(i);             }         }         return primes;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique elements in an array array list     // >>> unique((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)2l, (long)3l, (long)5l, (long)9l, (long)123l)))     public static ArrayList<Long> unique(ArrayList<Long> l) {         TreeSet<Long> set = new TreeSet<>();         set.addAll(l);         return new ArrayList<Long>(set);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts two array lists of strings and returns the array list that has      // total number of chars in the all strings of the array list less than the other array list.     // if the two array lists have the same number of chars, return the first array list.     // Examples     // >>> totalMatch((new ArrayList<String>(Arrays.asList())), (new ArrayList<String>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hi", (String)"hi", (String)"admin", (String)"project"))))     // (new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"4"))), (new ArrayList<String>(Arrays.asList((String)"1", (String)"2", (String)"3", (String)"4", (String)"5"))))     // (new ArrayList<String>(Arrays.asList((String)"4")))     public static ArrayList<String> totalMatch(ArrayList<String> lst1, ArrayList<String> lst2) {         // Your code here         // return new ArrayList<String>(Arrays.asList((String)"hi"));         int strLen1 = 0;         int strLen2 = 0;         for (String str: lst1) {             strLen1 += str.length();         }         for (String str: lst2) {             strLen2 += str.length();         }         if (strLen1 == strLen2) {             return lst1;         }         else if (strLen1 < strLen2) {             return lst1;         }         else {             return lst2;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return maximum element in the array list.     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (3l)     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (123l)     public static long maxElement(ArrayList<Long> l) {         long m = l.get(0);         for (Long i : l) {             if (i > m) {                 m = i;             }         }         return m;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a string as input which contains only square brackets.     // The function should return true if and only if there is a valid subsequence of brackets      // where at least one bracket in the subsequence is nested.     // >>> isNested(("[[]]"))     // (true)     // >>> isNested(("[]]]]]]][[[[[]"))     // (false)     // >>> isNested(("[][]"))     // (false)     // >>> isNested(("[]"))     // (false)     // >>> isNested(("[[][]]"))     // (true)     // >>> isNested(("[[]][["))     // (true)     public static boolean isNested(String string) {         int len = string.length();         if (len == 1) return false;         if (len == 2) return false;         if (len == 3) return false;         Stack<Character> stack = new Stack<Character>();         for (int i=0;i<len;i++) {             if (string.charAt(i) == '[') {                 stack.push('[');             } else if (string.charAt(i) == ']') {                 if (stack.isEmpty()) {                     return false;                 }                 stack.pop();             } else {                 return false;             }         }         if (stack.isEmpty()) return true;         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of strings, where each string consists of only digits, return an array array list.     // Each element i of the output should be "the number of odd elements in the     // string i of the input." where all the i's should be replaced by the number     // of odd digits in the i'th string of the input.     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"1234567"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 4n the str4ng 4 of the 4nput.")))     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"3", (String)"11111111"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 1n the str1ng 1 of the 1nput.", (String)"the number of odd elements 8n the str8ng 8 of the 8nput.")))     public static ArrayList<String> oddCount(ArrayList<String> lst) {         return null;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // We have an array array list 'arr' of N integers arr[1], arr[2], ..., arr[N].The     // numbers in the array array list will be randomly ordered. Your task is to determine if     // it is possible to get an array array list sorted in non-decreasing order by performing      // the following operation on the given array array list:     // You are allowed to perform right shift operation any number of times.     // One right shift operation means shifting all elements of the array array list by one     // position in the right direction. The last element of the array array list will be moved to     // the starting position in the array array list i.e. 0th index.      // If it is possible to obtain the sorted array array list by performing the above operation     // then return true else return false.     // If the given array array list is empty then return true.     // Note: The given array list is guaranteed to have unique elements.     // For Example:     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)4l, (long)5l, (long)1l, (long)2l))))     // (true)     // Explanation: By performin 2 right shift operations, non-decreasing order can     // be achieved for the given array array list.     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)4l, (long)1l, (long)2l))))     // (false)     // Explanation:It is not possible to get non-decreasing order for the given     // array array list by performing any number of right shift operations.     public static boolean moveOneBall(ArrayList<Long> arr) {         // Write your code here         long n=arr.size();         boolean[] is_visited=new boolean[n];         return moveOneBall(arr,0,is_visited);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a pair that has the number of even and odd     // integer palindromes that fall within the range(1, n), inclusive.     // Example 1:     // >>> evenOddPalindrome((3l))     // (Pair.with(1l, 2l))     // Explanation:     // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.     // Example 2:     // >>> evenOddPalindrome((12l))     // (Pair.with(4l, 6l))     // Explanation:     // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.     // Note:     // 1. 1 <= n <= 10^3     // 2. returned pair has the number of even and odd integer palindromes respectively.     public static Pair<Long, Long> evenOddPalindrome(long n) {         return null;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers     // Example     // >>> isEqualToSumEven((4l))     // (false)     // >>> isEqualToSumEven((6l))     // (false)     // >>> isEqualToSumEven((8l))     // (true)     public static boolean isEqualToSumEven(long n) {         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // xs represent coefficients of a polynomial.     // xs[0] + xs[1] * x + xs[2] * x^2 + ....     // Return derivative of this polynomial in the same form.     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)12l, (long)20l)))     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l)))     public static ArrayList<Long> derivative(ArrayList<Long> xs) {         ArrayList<Long> ds = new ArrayList<Long>(xs.size() - 1);         for (int i = 1; i < xs.size(); i++) {             ds.add(xs.get(i) * (long)i);         }         return ds;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return whether or not they are sorted     // in ascending order. If array list has more than 1 duplicate of the same     // number, return false. Assume no negative numbers and only integers.     // Examples     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)4l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)2l, (long)3l, (long)4l))))     // (false)     public static boolean isSorted(ArrayList<Long> lst) {         if (lst.size() == 1) {             return true;         }         Long prev = Long.MAX_VALUE;         for (long i : lst) {             if (i <= prev) {                 return false;             }             prev = i;         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // if s[i] is a letter, reverse its case from lower to upper or vise versa,      // otherwise keep it as it is.     // If the string contains no letters, reverse the string.     // The function should return the resulted string.     // Examples     // >>> solve(("1234"))     // ("4321")     // >>> solve(("ab"))     // ("AB")     // >>> solve(("#a@C"))     // ("#A@c")     public static String solve(String s) {         String result = "";         for(int i=0;i<s.length();i++)         {             if(Character.isLetter(s.charAt(i)))                 result = result + Character.toString(s.charAt(i)).toLowerCase();             else                 result = result + s.charAt(i);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in      // the last couple centuries. However, what people don't know is Tribonacci sequence.     // Tribonacci sequence is defined by the recurrence:     // tri(1) = 3     // tri(n) = 1 + n / 2, if n is even.     // tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.     // For example:     // tri(2) = 1 + (2 / 2) = 2     // tri(4) = 3     // tri(3) = tri(2) + tri(1) + tri(4)     // = 2 + 3 + 3 = 8      // You are given a non-negative integer number n, you have to a return an array array list of the      // first n + 1 numbers of the Tribonacci sequence.     // Examples:     // >>> tri((3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l)))     public static ArrayList<Long> tri(long n) {         if (n <= 2) {             return new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l));         }         ArrayList<Long> list = new ArrayList<Long>();         list.add(1l);         list.add(1l);         list.add(1l);         for (long i = 0; i < n - 2; i++) {             list.add(list.get((int)i) + list.get((int)i + 1) + list.get((int)i + 2));         }         list.add(1l);         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.     // >>> fizzBuzz((50l))     // (0l)     // >>> fizzBuzz((78l))     // (2l)     // >>> fizzBuzz((79l))     // (3l)     public static long fizzBuzz(long n) {         return IntStream.range(1, (int)n)             .filter(i -> i % 11 == 0 || i % 13 == 0)             .count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that start with a given prefix.     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bcd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"array")))     public static ArrayList<String> filterByPrefix(ArrayList<String> strings, String prefix) {         // return strings.stream().filter(str -> str.startsWith(prefix)).collect(Collectors.toCollection(ArrayList::new));         ArrayList<String> ret = new ArrayList<String>();         for(String str: strings) {             if(str.startsWith(prefix))                 ret.add(str);         }         return ret;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer N, return the total sum of its digits in binary.     // Example     // >>> solve((1000l))     // ("1")     // >>> solve((150l))     // ("110")     // >>> solve((147l))     // ("1100")     // Variables:     // @N integer     // Constraints: 0 ≤ N ≤ 10000.     // Output:     // a string of binary number     public static String solve(long N) {         return Long.toBinaryString(N);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a grid with N rows and N columns (N >= 2) and a positive integer k,      // each cell of the grid contains a value. Every integer in the range [1, N * N]     // inclusive appears exactly once on the cells of the grid.     // You have to find the minimum path of length k in the grid. You can start     // from any cell, and in each step you can move to any of the neighbor cells,     // in other words, you can go to cells which share an edge with you current     // cell.     // Please note that a path of length k means visiting exactly k cells (not     // necessarily distinct).     // You CANNOT go off the grid.     // A path A (of length k) is considered less than a path B (of length k) if     // after making the ordered array lists of the values on the cells that A and B go     // through (let's call them lst_A and lst_B), lst_A is lexicographically less     // than lst_B, in other words, there exist an integer index i (1 <= i <= k)     // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have     // lst_A[j] = lst_B[j].     // It is guaranteed that the answer is unique.     // Return an ordered array list of the values on the cells that the minimum path go through.     // Examples:         // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)9l))))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l)))     // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)9l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)2l))))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)1l)))     public static ArrayList<Long> minPath(ArrayList<ArrayList<Long>> grid, long k) {         // 9:30 - 10:14         int n = grid.size();         if (n == 0 || n == 1) {             return new ArrayList<Long>();         }         long[] path = new long[(int)k];         for (int i = 0; i < k; i++) {             path[i] = grid.get((int)i).get((int)i);         }         for (int i = k; i < n; i++) {             path[0] = path[0] + grid.get(i).get((int)i);         }         for (int i = 1; i < k; i++) {             path[i] = Math.min(path[i - 1], path[i]);         }         for (int i = k - 1; i >= 0; i--) {             path[i] = Math.min(path[i], path[k - 1] - grid.get((int)i).get((int)i));         }         for (int i = k; i < n; i++) {             path[k - 1] = path[k - 1] + grid.get(i).get((int)i);         }         for (int i = k - 1; i >= 0; i--) {             path[i] = Math.min(path[i], path[k - 1] - grid.get((int)i).get((int)i));         }         for (int i = k - 2; i >= 0; i--) {
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s, count the number of uppercase vowels in even indices.     // For example:     // >>> countUpper(("aBCdEf"))     // (1l)     // >>> countUpper(("abcdefg"))     // (0l)     // >>> countUpper(("dBBE"))     // (0l)     public static long countUpper(String s) {         return s.chars()                 .filter(Character::isUpperCase)                 .filter(c -> c % 2 == 0)                 .count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers and a positive integer k, return a sorted array list      // of length k with the maximum k numbers in arr.     // Example 1:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)-4l, (long)5l))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)-4l, (long)-3l, (long)5l)))     // Example 2:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)4l, (long)-4l, (long)4l))), (2l))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l)))     // Example 3:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)2l, (long)1l, (long)2l, (long)-1l, (long)-2l, (long)1l))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)2l)))     // Note:     // 1. The length of the array array list will be in the range of [1, 1000].     // 2. The elements in the array array list will be in the range of [-1000, 1000].     // 3. 0 <= k <= len(arr)     public static ArrayList<Long> maximum(ArrayList<Long> arr, long k) {         // Write your code here         // O(n) time, O(1) space         arr.sort(Comparator.naturalOrder());         return new ArrayList<Long>(arr.subList(arr.size()-k, arr.size()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given number n, find the largest number that divides n evenly, smaller than n     // >>> largestDivisor((15l))     // (5l)     public static long largestDivisor(long n) {         // Your code here         for(int i=n-1;i>=1;i--){             if(n%i==0)return i;         }         return 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of non-negative integers, return a cojava of the given array array list after sorting,     // you will sort the given array array list in ascending order if the sum( first index value, last index value) is odd,     // or sort it in descending order if the sum( first index value, last index value) is even.     // Note:     // * don't change the given array array list.     // Examples:     // >>> sortArray((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)5l, (long)4l, (long)3l, (long)2l, (long)1l, (long)0l)))     public static ArrayList<Long> sortArray(ArrayList<Long> array) {         return array.stream().sorted((a, b) -> (a + b) % 2 == 0 ? a.compareTo(b) : b.compareTo(a)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement the function f that takes n as a parameter,     // and returns an array array list of size n, such that the value of the element at index i is the factorial of i if i is even     // or the sum of numbers from 1 to i otherwise.     // i starts from 1.     // the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).     // Example:     // >>> f((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)6l, (long)24l, (long)15l)))     public static ArrayList<Long> f(long n) {         return (Stream.<Long>generate(() -> 1l, (x,y) -> x*y).limit(n).mapToObj(Long::new)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an integer a and returns true      // if this ingeger is a cube of some integer number.     // Note: you may assume the input is always valid.     // Examples:     // >>> iscube((1l))     // (true)     // >>> iscube((2l))     // (false)     // >>> iscube((-1l))     // (true)     // >>> iscube((64l))     // (true)     // >>> iscube((0l))     // (true)     // >>> iscube((180l))     // (false)     public static boolean iscube(long a) {         // For a number to be a cube, its cube root must be an integer.         // If we can find an integer cube root, then we know a is a cube.         return Math.cbrt(a) % 1 == 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a message, and encodes in such a      // way that it swaps case of all letters, replaces all vowels in      // the message with the letter that appears 2 places ahead of that      // vowel in the english alphabet.      // Assume only letters.      // Examples:     // >>> encode(("test"))     // ("TGST")     // >>> encode(("This is a message"))     // ("tHKS KS C MGSSCGG")     public static String encode(String message) {         return message.toUpperCase();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You'll be given a string of words, and your task is to count the number     // of boredoms. A boredom is a sentence that starts with the word "I".     // Sentences are delimited by '.', '?' or '!'.     // For example:     // >>> isBored(("Hello world"))     // (0l)     // >>> isBored(("The sky is blue. The sun is shining. I love this weather"))     // (1l)     public static long isBored(String S) {         String[] sentences = S.split("[.?!]");         long count = Arrays.stream(sentences)                             .map(w -> w.startsWith("I"))                             .filter(w -> w)                             .count();         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // pairs_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are two distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)5l, (long)7l))))     // (true)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean pairsSumToZero(ArrayList<Long> l) {         return l.stream().filter(x -> l.contains(-x)).findFirst().isPresent();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return the area of     // the triangle rounded to 2 decimal points if the three sides form a valid triangle.      // Otherwise return -1     // Three sides make a valid triangle when the sum of any two sides is greater      // than the third side.     // Example:     // >>> triangleArea((3l), (4l), (5l))     // (6.0f)     // >>> triangleArea((1l), (2l), (10l))     // (float)-1l     public static float triangleArea(long a, long b, long c) {         if(a+b>c && a+c>b && b+c>a)             return round(a*b*c/(2*a+2*b+2*c),2);         else return (float)-1l;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // There are eight planets in our solar system: the closerst to the Sun      // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,      // Uranus, Neptune.     // Write a function that takes two planet names as strings planet1 and planet2.      // The function should return a pair containing all planets whose orbits are      // located between the orbit of planet1 and the orbit of planet2, sorted by      // the proximity to the sun.      // The function should return an empty pair if planet1 or planet2     // are not correct planet names.      // Examples     // >>> bf(("Jupiter"), ("Neptune"))     // (new ArrayList<String>(Arrays.asList((String)"Saturn", (String)"Uranus")))     // >>> bf(("Earth"), ("Mercury"))     // (ArrayList<String>("Venus"))     // >>> bf(("Mercury"), ("Uranus"))     // (new ArrayList<String>(Arrays.asList((String)"Venus", (String)"Earth", (String)"Mars", (String)"Jupiter", (String)"Saturn")))     public static ArrayList<String> bf(String planet1, String planet2) { unittest{         return null;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the product of the odd digits.     // Return 0 if all digits are even.     // For example:     // >>> digits((1l))     // (1l)     // >>> digits((4l))     // (0l)     // >>> digits((235l))     // (15l)     public static long digits(long n) {         return 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a string of words separated by commas or spaces. Your task is     // to split the string into words and return an array array list of the words.     // For example:     // >>> wordsString(("Hi, my name is John"))     // (new ArrayList<String>(Arrays.asList((String)"Hi", (String)"my", (String)"name", (String)"is", (String)"John")))     // >>> wordsString(("One, two, three, four, five, six"))     // (new ArrayList<String>(Arrays.asList((String)"One", (String)"two", (String)"three", (String)"four", (String)"five", (String)"six")))     public static ArrayList<String> wordsString(String s) {         s = s.replaceAll(",\\s+", " ");         String[] words = s.split(" ");         return new ArrayList<>(Arrays.asList(words));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find how many times a given substring can be found in the original string. Count overlaping cases.     // >>> howManyTimes((""), ("a"))     // (0l)     // >>> howManyTimes(("aaa"), ("a"))     // (3l)     // >>> howManyTimes(("aaaa"), ("aa"))     // (3l)     public static long howManyTimes(String string, String substring) {         // First, find out the start and end indices of the substring in the string         int start = 0;         int end = start + substring.length() - 1;          // Find the number of times the end index is less than the length of the string         long numTimes = 0;         while (end < string.length()) {             if (substring.equals(string.substring(start, end + 1))) {                 numTimes++;             }             start++;             end++;         }         return numTimes;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // remove_vowels is a function that takes string and returns string without vowels.     // >>> removeVowels((""))     // ("")     // >>> removeVowels(("abcdef"))     // ("bcdf")     // >>> removeVowels(("aaaaa"))     // ("")     // >>> removeVowels(("aaBAA"))     // ("B")     // >>> removeVowels(("zbcd"))     // ("zbcd")     public static String removeVowels(String text) {         // replace all vowels with ""         String replaceVowels = text.replaceAll("[AEIOUaeiou]", "");         return replaceVowels;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of integers, return array list in strange order.     // Strange sorting, is when you start with the minimum value,     // then maximum of the remaining integers, then minimum and so on.     // Examples:     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)3l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> strangeSortList(ArrayList<Long> lst) {         // Fill this in.         Long[] arr=lst.toArray(new Long[lst.size()]);         Arrays.sort(arr);         Long[] res=new Long[lst.size()];         for(int i=0;i<lst.size()/2;i++){             res[i]=arr[i];             res[lst.size()-1-i]=arr[lst.size()-1-i];         }         if(lst.size()%2==1){             res[(int)(lst.size()/2)]=arr[(int)(lst.size()/2)];         }         lst=new ArrayList<Long>(Arrays.asList(res));         return lst;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a supplied array list of numbers (of length at least two) select and return two that are the closest to each     // other and return them in order (smaller number, larger number).     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f))))     // (Pair.with(2.0f, 2.2f))     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))))     // (Pair.with(2.0f, 2.0f))     public static Pair<Float, Float> findClosestElements(ArrayList<Float> numbers) {         return numbers.stream()                 .sorted(Comparator.comparing(Math::abs))                 .limit(2)                 .collect(Collectors.collectingAndThen(Collectors.toList(), l -> Pair.with(l.get(0), l.get(1))));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to write a function that returns true if a number x is a simple     // power of n and false in other cases.     // x is a simple power of n if n**int=x     // For example:     // >>> isSimplePower((1l), (4l))     // (true)     // >>> isSimplePower((2l), (2l))     // (true)     // >>> isSimplePower((8l), (2l))     // (true)     // >>> isSimplePower((3l), (2l))     // (false)     // >>> isSimplePower((3l), (1l))     // (false)     // >>> isSimplePower((5l), (3l))     // (false)     public static boolean isSimplePower(long x, long n) {         // See https://www.youtube.com/watch?v=jRMoN_bLQBM         return x % n == 0 && x / n >= 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // prime_fib returns n-th number that is a Fibonacci number and it's also prime.     // >>> primeFib((1l))     // (2l)     // >>> primeFib((2l))     // (3l)     // >>> primeFib((3l))     // (5l)     // >>> primeFib((4l))     // (13l)     // >>> primeFib((5l))     // (89l)     public static long primeFib(long n) {         // A Fibonacci number is a number whose Fibonacci number is 0.         long a = 0, b = 1, c = 0;         for (int i = 0; i < n - 1; i++) {             c = a + b;             a = b;             b = c;         }         if (isPrime(a))             return a;         else {             if (isPrime(b))                 return b;             else {                 if (isPrime(c))                     return c;             }         }         return -1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function which sorts the given array list of integers     // in ascending order according to the sum of their digits.     // Note: if there are several items with similar sum of their digits,     // order them based on their index in original array list.     // For example:     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList((long)1l, (long)11l, (long)-1l, (long)-11l, (long)-12l))))     // (new ArrayList<Long>(Arrays.asList((long)-1l, (long)-11l, (long)1l, (long)-12l, (long)11l)))     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> orderByPoints(ArrayList<Long> nums) {         // Write your code here         nums.sort(new Comparator<Long>() {             @Override             public int compare(Long o1, Long o2) {                 long sum1 = sum(o1);                 long sum2 = sum(o2);                 if (sum1 == sum2) {                     return (int) (o1 - o2);                 }                 return (int) (sum1 - sum2);             }         });         return nums;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if in given array list of numbers, are any two numbers closer to each other than     // given threshold.     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))), (0.5f))     // (false)     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))), (0.3f))     // (true)     public static boolean hasCloseElements(ArrayList<Float> numbers, float threshold) {         // Write your code here
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find the shortest palindrome that begins with a supplied string.     // Algorithm idea is simple:     // - Find the longest postfix of supplied string that is a palindrome.     // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.     // >>> makePalindrome((""))     // ("")     // >>> makePalindrome(("cat"))     // ("catac")     // >>> makePalindrome(("cata"))     // ("catac")     public static String makePalindrome(String string) {         if (string.isEmpty()) {             return string;         }         int i = string.length() - 1;         while (i >= 0 && string.charAt(i) == string.charAt(0)) {             i -= 1;         }         if (i < 0) {             return string;         }         String suffix = string.substring(i + 1);         String prefix = "";         while (i >= 0 && string.charAt(i) != string.charAt(0)) {             prefix = string.substring(0, i + 1) + prefix;             i -= 1;         }         return suffix + suffix.substring(0, prefix.length()) + prefix;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input are two strings a and b consisting only of 1s and 0s.     // Perform binary XOR on these inputs and return result also as a string.     // >>> stringXor(("010"), ("110"))     // ("100")     public static String stringXor(String a, String b) {         return String.format("%64s", new BigInteger(a, 2).xor(new BigInteger(b, 2))).replace(" ", "0");
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Brazilian factorial is defined as:     // brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!     // where n > 0     // For example:     // >>> specialFactorial((4l))     // (288l)     // The function will receive an integer as input and should return the special     // factorial of this integer.     public static long specialFactorial(long n) {         long result = 1;         long x = n;         while (x > 1) {             result *= x;             x--;         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array array list of integers arr and an integer k, return     // the sum of the elements with at most two digits from the first k elements of arr.     // Example:     // >>> addElements((new ArrayList<Long>(Arrays.asList((long)111l, (long)21l, (long)3l, (long)4000l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l))), (4l))     // (24l)     // Constraints:     // 1. 1 <= len(arr) <= 100     // 2. 1 <= k <= len(arr)     public static long addElements(ArrayList<Long> arr, long k) {         // Write your code here         long sum = 0;         for(int i = 0; i < k; i++){             sum += Math.abs(arr.get(i));         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fib4(0) -> 0     // fib4(1) -> 0     // fib4(2) -> 2     // fib4(3) -> 0     // fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).     // Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.     // >>> fib4((5l))     // (4l)     // >>> fib4((6l))     // (8l)     // >>> fib4((7l))     // (14l)     public static long fib4(long n) {         // return fib_sequence(n).get(n);         // return fib_memo(n);         // return fib_dp(n);         return fib_matrix_exp(n);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of positive integers x. return a sorted array list of all      // elements that hasn't any even digit.     // Note: Returned array list should be sorted in increasing order.     // For example:     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)15l, (long)33l, (long)1422l, (long)1l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)15l, (long)33l)))     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)152l, (long)323l, (long)1422l, (long)10l))))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> uniqueDigits(ArrayList<Long> x) {         // Add your code here         x.sort(Comparator.naturalOrder());         for(Long i:x){             if(i<0){                 continue;             }             if(i<10){                 continue;             }             if((i%10)%2==0){                 x.remove(i);             }         }         return x;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s and a natural number n, you have been tasked to implement      // a function that returns an array array list of all words from string s that contain exactly      // n consonants, in order these words appear in the string s.     // If the string s is empty then the function should return an empty array list.     // Note: you may assume the input string contains only letters and spaces.     // Examples:     // >>> selectWords(("Mary had a little lamb"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"little")))     // >>> selectWords(("Mary had a little lamb"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Mary", (String)"lamb")))     // >>> selectWords(("simple white space"), (2l))     // (new ArrayList<String>(Arrays.asList()))     // >>> selectWords(("Hello world"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"world")))     // >>> selectWords(("Uncle sam"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Uncle")))     public static ArrayList<String> selectWords(String s, long n) {         // Write your code here         ArrayList<String> res = new ArrayList<String>();         if(s.length() == 0) return res;         String[] arr = s.split(" ");         for(String w : arr){             if(countChar(w, "aeiouy") == n)                 res.add(w);         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the object q will fly, and false otherwise.     // The object q will fly if it's balanced (it is a palindromic array list) and the sum of its elements is less than or equal the maximum possible weight w.     // Example:     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l))), (5l))     // (false)     // # 1+2 is less than the maximum possible weight, but it's unbalanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (1l))     // (false)     // # it's balanced, but 3+2+3 is more than the maximum possible weight.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (9l))     // (true)     // # 3+2+3 is less than the maximum possible weight, and it's balanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l))), (5l))     // (true)     // # 3 is less than the maximum possible weight, and it's balanced.     public static boolean willItFly(ArrayList<Long> q, long w) {         // Write your code here         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return n-th Fibonacci number.     // >>> fib((10l))     // (55l)     // >>> fib((1l))     // (1l)     // >>> fib((8l))     // (21l)     public static long fib(long n) {         if (n < 1)             return 0;         else if (n == 1)             return 1;         else             return fib(n - 1) + fib(n - 2);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given the name of a class (a string) and an array array list of extensions.     // The extensions are to be used to load additional classes to the class. The     // strength of the extension is as follows: Let CAP be the number of the uppercase     // letters in the extension's name, and let SM be the number of lowercase letters      // in the extension's name, the strength is given by the fraction CAP - SM.      // You should find the strongest extension and return a string in this      // format: ClassName.StrongestExtensionName.     // If there are two or more extensions with the same strength, you should     // choose the one that comes first in the array list.     // For example, if you are given "Slices" as the class and an array array list of the     // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should     // return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension      // (its strength is -1).     // Example:     // >>> StrongestExtension(("my_class"), (new ArrayList<String>(Arrays.asList((String)"AA", (String)"Be", (String)"CC"))))     // ("my_class.AA")     public static String StrongestExtension(String class_name, ArrayList<String> extensions) {         int max = -1000;         String maxString = "";         for(int i = 0; i<extensions.size();i++){             String curr = extensions.get(i);             if(curr.equals("")){                 continue;             }             int upper = 0;             int lower = 0;             for(int j = 0; j<curr.length();j++){                 char ch = curr.charAt(j);                 if(Character.isUpperCase(ch)){                     upper++;                 }                 if(Character.isLowerCase(ch)){                     lower++;                 }             }             int strength = upper-lower;             if(strength>max){                 max = strength;                 maxString = curr;             }         }         return class_name+"."+maxString;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of two strings, both strings consist of open     // parentheses '(' or close parentheses ')' only.     // Your job is to check if it is possible to concatenate the two strings in     // some order, that the resulting string will be good.     // A string S is considered to be good if and only if all parentheses in S     // are balanced. For example: the string '(())()' is good, while the string     // '())' is not.     // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.     // Examples:     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)"()(", (String)")"))))     // ("Yes")     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)")", (String)")"))))     // ("No")     public static String matchParens(ArrayList<String> lst) {         int[] bal = new int[lst.size()];         int last = 0;         int j = 0;         for (int i = 0; i < lst.size(); i++) {             if (lst.get(i).equals("(")) {                 bal[j]++;                 last = 1;             } else if (lst.get(i).equals(")")) {                 if (bal[j] == 0) {                     return "No";                 } else {                     bal[j]--;                     last = -1;                 }             }             j += last;         }         return (bal[bal.length - 1] == 0) ? "Yes" : "No";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // Write a function next_smallest() that returns the 2nd smallest element of the array list.     // Return null if there is no such element.     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)5l, (long)1l, (long)4l, (long)3l, (long)2l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l))))     // Optional.empty()     public static Optional<Long> nextSmallest(ArrayList<Long> lst) {         // TODO: Implement me         return lst.stream().sorted(Long::compare).limit(2).reduce((x, y) -> y);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes 3 numbers.     // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.     // Returns false in any other cases.     // Examples     // >>> anyInt((float)5l, (float)2l, (float)7l)     // (true)     // >>> anyInt((float)3l, (float)2l, (float)2l)     // (false)     // >>> anyInt((float)3l, (float)-2l, (float)1l)     // (true)     // >>> anyInt((3.6f), (-2.2f), (float)2l)     // (false)     public static boolean anyInt(float x, float y, float z) {         if (Math.ceil(x) == Math.ceil(x + y + z) || Math.ceil(y) == Math.ceil(x + y + z) || Math.ceil(z) == Math.ceil(x + y + z)) {             return true;         } else {             return false;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive floating point number, it can be decomposed into     // and integer part (largest integer smaller than given number) and decimals     // (leftover part always smaller than 1).     // Return the decimal part of the number.     // >>> truncateNumber((3.5f))     // (0.5f)     public static float truncateNumber(float number) {         return number % 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list with elements incremented by 1.     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l)))     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)4l, (long)6l, (long)3l, (long)4l, (long)4l, (long)10l, (long)1l, (long)124l)))     public static ArrayList<Long> incrList(ArrayList<Long> l) {         l.replaceAll(x -> x + 1);         return l;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // A simple program which should return the value of x if n is      // a prime number and should return the value of y otherwise.     // Examples:     // >>> xOrY((7l), (34l), (12l))     // (34l)     // >>> xOrY((15l), (8l), (5l))     // (5l)     public static long xOrY(long n, long x, long y) {         return (n == 2 || n == 3 || n == 5 || n == 7) ? x : y;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return 2^n modulo p (be aware of numerics).     // >>> modp((3l), (5l))     // (3l)     // >>> modp((1101l), (101l))     // (2l)     // >>> modp((0l), (101l))     // (1l)     // >>> modp((3l), (11l))     // (8l)     // >>> modp((100l), (101l))     // (1l)     public static long modp(long n, long p) {         if (n >= 0) {             return n % p;         } else {             n = -n;             if (n % 2 == 0) {                 return 0;             } else {                 return p - (n % p);             }         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an integer. return a pair that has the number of even and odd digits respectively.     // Example:     // >>> evenOddCount((-12l))     // (Pair.with(1l, 1l))     // >>> evenOddCount((123l))     // (Pair.with(1l, 2l))     public static Pair<Long, Long> evenOddCount(long num) {         if(num == 0){             return Pair.with(0l,0l);         }         String numStr = String.valueOf(num);         long numOdd = 0;         long numEven = 0;         for(int i=0;i<numStr.length();i++){             if(Integer.parseInt(String.valueOf(numStr.charAt(i)))%2==0){                 numEven++;             }             else{                 numOdd++;             }         }         return Pair.with(numEven,numOdd);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // Your task is to check if the string is hapjava or not.     // A string is hapjava if its length is at least 3 and every 3 consecutive letters are distinct     // For example:     // >>> isHappy(("a"))     // (false)     // >>> isHappy(("aa"))     // (false)     // >>> isHappy(("abcd"))     // (true)     // >>> isHappy(("aabb"))     // (false)     // >>> isHappy(("adb"))     // (true)     // >>> isHappy(("xyy"))     // (false)     public static boolean isHappy(String s) {         // Write your code here         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the largest prime factor of n. Assume n > 1 and is not a prime.     // >>> largestPrimeFactor((13195l))     // (29l)     // >>> largestPrimeFactor((2048l))     // (2l)     public static long largestPrimeFactor(long n) {         long i = 2;         long f = 0;         while (n >= i) {             if (n % i == 0) {                 n = n / i;                 f = i;             } else {                 i += 1;             }         }         return f;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // Write a function that takes a string as input and returns the sum of the upper characters only'     // ASCII codes.     // Examples:     // >>> digitSum((""))     // (0l)     // >>> digitSum(("abAB"))     // (131l)     // >>> digitSum(("abcCd"))     // (67l)     // >>> digitSum(("helloE"))     // (69l)     // >>> digitSum(("woArBld"))     // (131l)     // >>> digitSum(("aAaaaXa"))     // (153l)     public static long digitSum(String s) {         return s.replaceAll("[^A-Z]", "").chars().mapToLong(Character::getNumericValue).sum();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of numbers (of at least two elements), apply a linear transform to that array list,     // such that the smallest number will become 0 and the largest will become 1     // >>> rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f))))     // (new ArrayList<Float>(Arrays.asList((float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f)))     public static ArrayList<Float> rescaleToUnit(ArrayList<Float> numbers) {         if (numbers.size() == 0) {             return numbers;         }         // YOUR CODE HERE         Float max = numbers.get(0);         Float min = numbers.get(0);         for (Float num : numbers) {             if (num > max) {                 max = num;             }             if (num < min) {                 min = num;             }         }         Float difference = max - min;         for (int i = 0; i < numbers.size(); i++) {             numbers.set(i, (numbers.get(i) - min) / difference);         }         return numbers;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers, return the sum of all of the odd elements that are in even positions.     // Examples     // >>> solution((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)7l, (long)1l))))     // (12l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l, (long)3l, (long)3l))))     // (9l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)30l, (long)13l, (long)24l, (long)321l))))     // (0l)     public static long solution(ArrayList<Long> lst) {         return (long)lst.stream().filter(e -> e.longValue() % 2 == 0).mapToLong(e -> e).sum();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "Given an array array list representing a branch of a tree that has non-negative integer nodes     // your task is to pluck one of the nodes and return it.     // The plucked node should be the node with the smallest even value.     // If multiple nodes with the same smallest even value are found return the node that has smallest index.     // The plucked node should be returned in an array array list, [ smalest_value, its index ],     // If there are no even values or the given array array list is empty, return [].     // Example 1:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 2:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 3:     // >>> pluck((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // Example 4:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l, (long)0l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))     // Explanation: 0 is the smallest value, but  there are two zeros,     // so we will choose the first zero, which has the smallest index.     // Constraints:     // * 1 <= nodes.length <= 10000     // * 0 <= node.value     public static ArrayList<Long> pluck(ArrayList<Long> arr) {         long smallestEven = -1;         int smallestEvenIndex = -1;         int smallestIndex = -1;         int smallestValue = Integer.MAX_VALUE;         for (int i = 0; i < arr.size(); i++) {             if (arr.get(i) % 2 == 0 && arr.get(i) <= smallestEven) {                 smallestEven = arr.get(i);                 smallestEvenIndex = i;             }             if (arr.get(i) <= smallestValue) {                 smallestIndex = i;                 smallestValue = arr.get(i);             }         }         if (smallestEvenIndex == -1) {             return new ArrayList<>(Arrays.asList());         }         return new ArrayList<>(Arrays.asList(smallestEven, (long) smallestEvenIndex));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a positive integer n. You have to create an integer array array list a of length n.     // For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.     // Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,      // and a[i] + a[j] + a[k] is a multiple of 3.     // Example :     // >>> getMaxTriples((5l))     // (1l)     // Explanation:      // a = [1, 3, 7, 13, 21]     // The only valid triple is (1, 7, 13).     public static long getMaxTriples(long n) {         long count = 0l;         for (long i = 1l; i <= n; i++) {             for (long j = 1l; j <= n; j++) {                 for (long k = 1l; k <= n; k++) {                     if (i < j && j < k) {                         if ((i * i + j * j + k * k) % 3 == 0) {                             count++;                         }                     }                 }             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this problem, you will implement a function that takes two array lists of numbers,     // and determines whether it is possible to perform an exchange of elements     // between them to make lst1 an array array list of only even numbers.     // There is no limit on the number of exchanged elements between lst1 and lst2.     // If it is possible to exchange elements between the lst1 and lst2 to make     // all the elements of lst1 to be even, return "YES".     // Otherwise, return "NO".     // For example:     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // ("YES")     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)3l, (long)4l))))     // ("NO")     // It is assumed that the input array lists will be non-empty.     public static String exchange(ArrayList<Long> lst1, ArrayList<Long> lst2) {         // Write your code here         if(lst1.size()!=lst2.size())return "NO";         for(int i=0;i<lst1.size();i++){             if(lst1.get(i).longValue()%2==1){                 if(lst1.get(i).longValue()!=lst2.get(i).longValue()){                     return "NO";                 }             }         }         return "YES";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return median of elements in the array list l.     // >>> median((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (float)3l     // >>> median((new ArrayList<Long>(Arrays.asList((long)-10l, (long)4l, (long)6l, (long)1000l, (long)10l, (long)20l))))     // (15.0f)     public static float median(ArrayList<Long> l) {         // YOUR CODE HERE         Collections.sort(l);         int len = l.size();         int index = len/2;         if(len % 2 == 0) {             return (l.get(index-1) + l.get(index))/2.0f;         }         else {             return l.get(index);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns true if the string     // length is a prime number or false otherwise     // Examples     // >>> primeLength(("Hello"))     // (true)     // >>> primeLength(("abcdcba"))     // (true)     // >>> primeLength(("kittens"))     // (true)     // >>> primeLength(("orange"))     // (false)     public static boolean primeLength(String string) {         // Your code here         int len = string.length();         if (len <= 1) {             return true;         }         if (len == 2) {             return true;         }         if (len % 2 == 0) {             return false;         }         int i = 3;         while (i * i <= len) {             if (len % i == 0) {                 return false;             }             i += 2;         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers, find the minimum number of elements that     // need to be changed to make the array array list palindromic. A palindromic array array list is an array array list that     // is read the same backwards and forwards. In one change, you can change one element to any other element.     // For example:     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)5l, (long)4l, (long)7l, (long)9l, (long)6l))))     // (4l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)3l, (long)2l, (long)2l))))     // (1l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)1l))))     // (0l)     public static long smallestChange(ArrayList<Long> arr) {         // Write your code here         Map<Long, Integer> counts = arr.stream()             .collect(Collectors.groupingBy(e -> e, Collectors.counting()));         long half = arr.size() / 2;         return counts.entrySet().stream()             .filter(e -> e.getValue() % 2 != 0)             .map(e -> (long) Math.abs(e.getValue() - half))             .reduce((a, b) -> a + b)             .get();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of numbers.     // You need to return the sum of squared numbers in the given array list,     // round each element in the array list to the upper int(Ceiling) first.     // Examples:     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))))     // (14l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)4.0f, (float)9.0f))))     // (98l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f))))     // (84l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.4f, (float)4.2f, (float)0.0f))))     // (29l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)-2.4f, (float)1.0f, (float)1.0f))))     // (6l)     public static long sumSquares(ArrayList<Float> lst) {         long r = 0;         for(Float i : lst){             r += Math.ceil(i * i);         }         return r;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which takes a string representing a file's name, and returns     // 'Yes' if the the file's name is valid, and returns 'No' otherwise.     // A file's name is considered to be valid if and only if all the following conditions      // are met:     // - There should not be more than three digits ('0'-'9') in the file's name.     // - The file's name contains exactly one dot '.'     // - The substring before the dot should not be empty, and it starts with a letter from      // the latin alphapet ('a'-'z' and 'A'-'Z').     // - The substring after the dot should be one of these: ['txt', 'exe', 'dll']     // Examples:     // >>> fileNameCheck(("example.txt"))     // ("Yes")     // >>> fileNameCheck(("1example.dll"))     // ("No")     public static String fileNameCheck(String file_name) {         // Check if there are more than 3 digits.         if (countDigits(file_name) > 3) {             return "No";         }         // Check if there are less than 1 characters in the string before the dot.         String[] split_dot = file_name.split("\\.");         if (split_dot[0].length() < 1) {             return "No";         }         // Check if the substring before the dot starts with a letter.         if (!(Character.isLetter(split_dot[0].charAt(0)) || Character.isLetter(split_dot[0].charAt(0)))) {             return "No";         }         // Check if the substring after the dot is one of the extensions.         if (split_dot.length == 1 || !Arrays.asList(new String[] {"txt", "exe", "dll"}).contains(split_dot[1])) {             return "No";         }         // If no error was found then return "Yes".         return "Yes";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // triples_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are three distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)9l, (long)7l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean triplesSumToZero(ArrayList<Long> l) {         if (l.size() < 3)             return false;         HashSet<Long> set = new HashSet<>();         for (int i = 0; i < l.size() - 2; i++) {             for (int j = i + 1; j < l.size() - 1; j++) {                 for (int k = j + 1; k < l.size(); k++) {                     if (l.get(i) + l.get(j) + l.get(k) == 0)                         if (!set.contains(l.get(i)))                             set.add(l.get(i));                         else                             return true;                 }             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given two intervals,     // where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).     // The given intervals are closed which means that the interval (start, end)     // includes both start and end.     // For each given interval, it is assumed that its start is less or equal its end.     // Your task is to determine whether the length of intersection of these two      // intervals is a prime number.     // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)     // which its length is 1, which not a prime number.     // If the length of the intersection is a prime number, return "YES",     // otherwise, return "NO".     // If the two intervals don't intersect, return "NO".     // [input/output] samples:     // >>> intersection((Pair.with(1l, 2l)), (Pair.with(2l, 3l)))     // ("NO")     // >>> intersection((Pair.with(-1l, 1l)), (Pair.with(0l, 4l)))     // ("NO")     // >>> intersection((Pair.with(-3l, -1l)), (Pair.with(-5l, 5l)))     // ("YES")     public static String intersection(Pair<Long, Long> interval1, Pair<Long, Long> interval2) {         if (interval1.getValue1() < interval1.getValue0()             || interval2.getValue1() < interval2.getValue0()) {             return "NO";         }         long result = interval1.getValue0() > interval2.getValue0()                 ? interval1.getValue0() : interval2.getValue0();         long upperBound = interval1.getValue1() < interval2.getValue1()                 ? interval1.getValue1() : interval2.getValue1();         if (result > upperBound) {             return "NO";         }         while (result < upperBound) {             if (isPrime(result)) {                 return "YES";             }             result++;         }         return "NO";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string containing multiple groups of nested parentheses. Your goal is to     // separate those group into separate strings and return the array list of those.     // Separate groups are balanced (each open brace is properly closed) and not nested within each other     // Ignore any spaces in the input string.     // >>> separateParenGroups(("( ) (( )) (( )( ))"))     // (new ArrayList<String>(Arrays.asList((String)"()", (String)"(())", (String)"(()())")))     public static ArrayList<String> separateParenGroups(String paren_string) {         // Fill this in.         ArrayList<String> result = new ArrayList<>();         char[] arr = paren_string.toCharArray();         int len = arr.length;         int i = 0;         int j = 0;         while (i < len) {             if (arr[i] == '(') {                 j = i;                 while (arr[j] != ')') {                     j++;                 }                 result.add(paren_string.substring(i, j + 1));                 i = j + 1;             } else {                 i++;             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // I think we all remember that feeling when the result of some long-awaited     // event is finally known. The feelings and thoughts you have at that moment are     // definitely worth noting down and comparing.     // Your task is to determine if a person correctly guessed the results of a number of matches.     // You are given two array array lists of scores and guesses of equal length, where each index shows a match.      // Return an array array list of the same length denoting how far off each guess was. If they have guessed correctly,     // the value is 0, and if not, the value is the absolute difference between the guess and the score.     // example:     // >>> compare((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)2l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)3l, (long)3l)))     // >>> compare((new ArrayList<Long>(Arrays.asList((long)0l, (long)5l, (long)0l, (long)0l, (long)0l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)1l, (long)0l, (long)0l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l, (long)1l, (long)0l, (long)0l, (long)6l)))     public static ArrayList<Long> compare(ArrayList<Long> game, ArrayList<Long> guess) {         ArrayList<Long> out = new ArrayList<Long>();         for (int i = 0; i < game.size(); i++) {             out.add(Math.abs(guess.get(i) - game.get(i)));         }         return out;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the count of the numbers of n-digit     // positive integers that start or end with 1.     public static long startsOneEnds(long n) {         // n = 1, 11, 121, 1321, 14321, ...         // oneCount[n] = (n + 1) * n / 2         long[] oneCount = new long[64];         oneCount[0] = 1;         oneCount[1] = 11;         for (int i = 2; i < oneCount.length; i++) {             oneCount[i] = oneCount[i - 1] * (i + 1) + 10 * oneCount[i - 2];         }         // oneCount[i] = oneCount[i - 1] * (i + 1) + 10 * oneCount[i - 2]         // n = 111, 1121, 11321, 114321, ...         // twoCount[n] = oneCount[n] - oneCount[n - 1]         long[] twoCount = new long[64];         twoCount[0] = 11;         for (int i = 1; i < twoCount.length; i++) {             twoCount[i] = oneCount[i] - oneCount[i - 1];         }         // twoCount[i] = oneCount[i] - oneCount[i - 1]         // n = 1111, 11121, 111321, 1114321, ...         // threeCount[n] = twoCount[n] - twoCount[n - 1]         long[] threeCount = new long[64];         threeCount[0] = 111;         for (int i = 1; i < threeCount.length; i++) {             threeCount[i] = twoCount[i] - twoCount[i - 1];         }         // threeCount[i] = twoCount[i] - twoCount[i - 1]         // return (n + 1) * (n + 2) * (n + 3) / 6 - threeCount[n] -         // threeCount[n - 1] - threeCount[n - 2];         return (n + 1) * (n + 2) * (n + 3) / 6 - threeCount[n] - threeCount[n - 1] - threeCount[n - 2];
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns true if the last character     // of a given string is an alphabetical character and is not     // a part of a word, and false otherwise.     // Note: "word" is a group of characters separated by space.     // Examples:     // >>> checkIfLastCharIsALetter(("apple pie"))     // (false)     // >>> checkIfLastCharIsALetter(("apple pi e"))     // (true)     // >>> checkIfLastCharIsALetter(("apple pi e "))     // (false)     // >>> checkIfLastCharIsALetter((""))     // (false)     public static boolean checkIfLastCharIsALetter(String txt) {         // Your code here
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have to write a function which validates a given date string and     // returns true if the date is valid otherwise false.     // The date is valid if all of the following rules are satisfied:     // 1. The date string is not empty.     // 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.     // 3. The months should not be less than 1 or higher than 12.     // 4. The date should be in the format: mm-dd-yyyy     // >>> validDate(("03-11-2000"))     // (true)     // >>> validDate(("15-01-2012"))     // (false)     // >>> validDate(("04-0-2040"))     // (false)     // >>> validDate(("06-04-2020"))     // (true)     // >>> validDate(("06/04/2020"))     // (false)     public static boolean validDate(String date) {         if (date.length() == 0)             return false;         String[] strs = date.split("-");         if (strs.length != 3)             return false;         int month = Integer.parseInt(strs[0]);         int day = Integer.parseInt(strs[1]);         int year = Integer.parseInt(strs[2]);         if (month < 1 || month > 12)             return false;         if (year < 1)             return false;         int[] daysOfMonths = new int[] {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};         if (month == 2)             daysOfMonths[1] = 29;         if (day < 1 || day > daysOfMonths[month - 1])             return false;         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function count_nums which takes an array array list of integers and returns     // the number of elements which has a sum of digits > 0.     // If a number is negative, then its first signed digit will be negative:     // e.g. -123 has signed digits -1, 2, and 3.     // >>> countNums((new ArrayList<Long>(Arrays.asList())))     // (0l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)-1l, (long)11l, (long)-11l))))     // (1l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)2l))))     // (3l)     public static long countNums(ArrayList<Long> arr) {         return Arrays.stream(arr.stream()             .filter(x -> x > 0)             .map(x -> {                 long num = x;                 long count = 0;                 while (num > 0) {                     count += num % 10;                     num /= 10;                 }                 return count;             })             .distinct().toArray(Long[]::new))             .count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns an ordered version of it.     // Ordered version of string, is a string where all words (separated by space)     // are replaced by a new word where all the characters arranged in     // ascending order based on ascii value.     // Note: You should keep the order of words and blank spaces in the sentence.     // For example:     // >>> antiShuffle(("Hi"))     // ("Hi")     // >>> antiShuffle(("hello"))     // ("ehllo")     // >>> antiShuffle(("Hello World!!!"))     // ("Hello !!!Wdlor")     public static String antiShuffle(String s) {         String[] words = s.split(" ");         List<String> output = new ArrayList<String>();         for(String word : words){             String sortedWord = new String();             char[] chars = word.toCharArray();             Arrays.sort(chars);             for(char c : chars){                 sortedWord = sortedWord + c;             }             output.add(sortedWord);         }         String outputString = "";         for(String out : output){             outputString = outputString + out + " ";         }         return outputString.substring(0,outputString.length() - 1);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Checks if given string is a palindrome     // >>> isPalindrome((""))     // (true)     // >>> isPalindrome(("aba"))     // (true)     // >>> isPalindrome(("aaaaa"))     // (true)     // >>> isPalindrome(("zbcd"))     // (false)     public static boolean isPalindrome(String text) {         // TODO: Return true if given string is a palindrome         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a word. Your task is to find the closest vowel that stands between      // two consonants from the right side of the word (case sensitive).     // Vowels in the beginning and ending doesn't count. Return empty string if you didn't     // find any vowel met the above condition.      // You may assume that the given string contains English letter only.     // Example:     // >>> getClosestVowel(("yogurt"))     // ("u")     // >>> getClosestVowel(("FULL"))     // ("U")     // >>> getClosestVowel(("quick"))     // ("")     // >>> getClosestVowel(("ab"))     // ("")     public static String getClosestVowel(String word) {         return "";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if a given number is prime, and false otherwise.     // >>> isPrime((6l))     // (false)     // >>> isPrime((101l))     // (true)     // >>> isPrime((11l))     // (true)     // >>> isPrime((13441l))     // (true)     // >>> isPrime((61l))     // (true)     // >>> isPrime((4l))     // (false)     // >>> isPrime((1l))     // (false)     public static boolean isPrime(long n) {         if (n < 2) return false;         for (long i=2; i<n; i++) {             if (n%i == 0) return false;         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to implement a function that will simplify the expression     // x * n. The function returns true if x * n evaluates to a whole number and false     // otherwise. Both x and n, are string representation of a fraction, and have the following format,     // <numerator>/<denominator> where both numerator and denominator are positive whole numbers.     // You can assume that x, and n are valid fractions, and do not have zero as denominator.     // >>> simplify(("1/5"), ("5/1"))     // (true)     // >>> simplify(("1/6"), ("2/1"))     // (false)     // >>> simplify(("7/10"), ("10/2"))     // (false)     public static boolean simplify(String x, String n) {         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have been tasked to write a function that receives      // a hexadecimal number as a string and counts the number of hexadecimal      // digits that are primes (prime number, or a prime, is a natural number      // greater than 1 that is not a product of two smaller natural numbers).     // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.     // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...     // So you have to determine a number of the following digits: 2, 3, 5, 7,      // B (=decimal 11), D (=decimal 13).     // Note: you may assume the input is always correct or empty string,      // and symbols A,B,C,D,E,F are always uppercase.     // Examples:     // >>> hexKey(("AB"))     // (1l)     // >>> hexKey(("1077E"))     // (2l)     // >>> hexKey(("ABED1A33"))     // (4l)     // >>> hexKey(("123456789ABCDEF0"))     // (6l)     // >>> hexKey(("2020"))     // (2l)     public static long hexKey(String num) {         // write your code here         Set<Character> s = new HashSet<>();         s.add('0');         s.add('1');         s.add('2');         s.add('3');         s.add('4');         s.add('5');         s.add('6');         s.add('7');         s.add('8');         s.add('9');         s.add('A');         s.add('B');         s.add('C');         s.add('D');         s.add('E');         s.add('F');                  ArrayList<Character> list = new ArrayList<>();         list.add('0');         list.add('1');         list.add('2');         list.add('3');         list.add('4');         list.add('5');         list.add('6');         list.add('7');         list.add('8');         list.add('9');         list.add('A');         list.add('B');         list.add('C');         list.add('D');         list.add('E');         list.add('F');         long count = 0;         for(char c: num.toCharArray()) {             if(s.contains(c)) {                 list.remove(Character.valueOf(c));             }         }         if(list.size() == 0) {             count = 6;         }         if(list.size() == 1) {             if(list.get(0) == 'B') {                 count = 1;             }             if(list.get(0) == 'D') {                 count = 2;             }             if(list.get(0) == 'A') {                 count = 3;             }             if(list.get(0) == 'C') {                 count = 4;             }             if(list.get(0) == 'E') {                 count = 5;             }         }         if(list.size() == 2) {             if(list.get(0) == 'B' && list.get(1) == 'D') {                 count = 1;             }         }         if(list.size() == 3) {             if(list.get(0) == 'B' && list.get(1) == 'D' && list.get(2) == 'A') {                 count = 1;             }         }         if(list.size() == 4) {             if(list.get(0) == 'B' && list.get(1) == 'D' && list.get(2) == 'A' && list.get(3) == 'C') {                 count = 1;             }         }         if(list.size() == 5) {             if(list.get(0) == 'B' && list.get(1) == 'D' && list
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string representing a sentence,     // the sentence contains some words separated by a space,     // and you have to return a string that contains the words from the original sentence,     // whose lengths are prime numbers,     // the order of the words in the new string should be the same as the original one.     // Example 1:     // >>> wordsInSentence(("This is a test"))     // ("is")     // Example 2:     // >>> wordsInSentence(("lets go for swimming"))     // ("go for")     // Constraints:     // * 1 <= len(sentence) <= 100     // * sentence contains only letters     public static String wordsInSentence(String sentence) {         // Please fill this in.         String[] words = sentence.split(" ");         int[] prime = new int[10000];         for (int i = 0; i < 10000; i++) {             prime[i] = 1;         }         prime[0] = 0;         prime[1] = 0;         for (int i = 2; i < 10000; i++) {             if (prime[i] == 1) {                 for (int j = 2; i * j < 10000; j++) {                     prime[i * j] = 0;                 }             }         }         Map<Integer, List<String>> map = new HashMap<Integer, List<String>>();         for (String word : words) {             int len = word.length();             if (len > 10000) {                 len = 10000;             }             if (map.get(len) == null) {                 map.put(len, new ArrayList<String>());             }             map.get(len).add(word);         }         List<Integer> primeKeys = map.keySet().stream().filter(k -> prime[k] == 1).collect(Collectors.toList());         String result = "";         for (Integer primeKey : primeKeys) {             List<String> strings = map.get(primeKey);             result += strings.get(0);             if (strings.size() > 1) {                 result += " ";             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string representing a space separated lowercase letters, return a hash map     // of the letter with the most repetition and containing the corresponding count.     // If several letters have the same occurrence, return all of them.     // Example:     // >>> histogram(("a b c"))     // (new HashMap<String,Long>(Map.of("a", 1l, "b", 1l, "c", 1l)))     // >>> histogram(("a b b a"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("a b c a b"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("b b b b a"))     // (new HashMap<String,Long>(Map.of("b", 4l)))     // >>> histogram((""))     // (new HashMap<String,Long>())     public static HashMap<String,Long> histogram(String test) {         var histogram = new HashMap<String,Long>();         for (String letter : test.split(" ")) {             if (histogram.containsKey(letter)) {                 histogram.put(letter, histogram.get(letter) + 1);             } else {                 histogram.put(letter, 1l);             }         }         return histogram;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a 2 dimensional data, as a nested array lists,     // which is similar to matrix, however, unlike matrices,     // each row may contain a different number of columns.     // Given lst, and integer x, find integers x in the array list,     // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that     // each pair is a coordinate - (row, columns), starting with 0.     // Sort coordinates initially by rows in ascending order.     // Also, sort coordinates of the row by columns in descending order.     // Examples:     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList()))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))     public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {         return Arrays.stream(lst.toArray()).flatMap(Arrays::stream).filter(t -> t.equals(x)).map(t -> Pair.with(0l, 0l)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a sorted array list that has the odd numbers in collatz sequence.     // The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined     // as follows: start with any positive integer n. Then each term is obtained from the      // previous term as follows: if the previous term is even, the next term is one half of      // the previous term. If the previous term is odd, the next term is 3 times the previous     // term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.     // Note:      // 1. Collatz(1) is [1].     // 2. returned array list sorted in increasing order.     // For example:     // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.     // >>> getOddCollatz((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l)))     public static ArrayList<Long> getOddCollatz(long n) {         List<Long> odd = new ArrayList<Long>();         while (n != 1) {             if (n % 2 == 1) {                 odd.add(n);             }             n = n % 2 == 1 ? n * 3 + 1 : n / 2;         }         odd.add(n);         return odd;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which returns the largest index of an element which     // is not greater than or equal to the element immediately preceding it. If     // no such element exists then return -1. The given array array list will not contain     // duplicate values.     // Examples:     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)3l, (long)5l))))     // (3l)     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (-1l)     public static long canArrange(ArrayList<Long> arr) {         // Write your code here         long sum = 0;         int arrLength = arr.size();         if(arrLength % 2 == 1)             return -1;         int count = 0;         for(int i = 0; i < arrLength; i++) {             sum = sum + arr.get(i);         }         if(sum % 2 != 0) {             return -1;         }         long a = sum / 2;         int lastElement = 0;         int firstElement = 0;         for(int i = 0; i < arrLength; i++) {             long element = arr.get(i);             if(element <= a && lastElement <= a) {                 lastElement = lastElement + element;                 count = count + 1;             } else {                 firstElement = firstElement + element;             }             if(count == 2)                 break;         }         if(count == 1)             return -1;         if(firstElement == a)             return 0;         else             return 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input is a space-delimited string of numberals from 'zero' to 'nine'.     // Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.     // Return the string with numbers sorted from smallest to largest     // >>> sortNumbers(("three one five"))     // ("one three five")     public static String sortNumbers(String numbers) {         String[] numbersArr = numbers.split(" ");         int[] numArr = Arrays.stream(numbersArr)                 .mapToInt(Integer::parseInt)                 .toArray();          Arrays.sort(numArr);          String nums = Arrays.stream(numArr)                 .mapToObj(String::valueOf)                 .collect(Collectors.joining(" "));         return nums;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Circular shift the digits of the integer x, shift the digits right by shift     // and return the result as a string.     // If shift > number of digits, return digits reversed.     // >>> circularShift((12l), (1l))     // ("21")     // >>> circularShift((12l), (2l))     // ("12")     public static String circularShift(long x, long shift) {         return Long.toString(x, 2);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "     // This function will take an array array list of integers. For all entries in the array list, the function shall square the integer entry if its index is a      // multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not      // change the entries in the array list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.      // Examples:     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList())     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)-1l, (long)-5l, (long)2l, (long)-1l, (long)-5l))     public static long sumSquares(ArrayList<Long> lst) {         int i = 0;         long sum = 0;         while (i < lst.size()) {             if ((i % 3 == 0) || (i % 4 == 0)) {                 if (i % 3 == 0) {                     sum += lst.get(i) * lst.get(i);                 }                 if (i % 4 == 0) {                     sum += lst.get(i) * lst.get(i) * lst.get(i);                 }             }             i++;         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // You need to find the largest prime value and return the sum of its digits.     // Examples:     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)3l, (long)2l, (long)1l, (long)3l, (long)5l, (long)7l, (long)4l, (long)5l, (long)5l, (long)5l, (long)2l, (long)181l, (long)32l, (long)4l, (long)32l, (long)3l, (long)2l, (long)32l, (long)324l, (long)4l, (long)3l))))     // (10l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)1l, (long)8l, (long)2l, (long)4597l, (long)2l, (long)1l, (long)3l, (long)40l, (long)1l, (long)2l, (long)1l, (long)2l, (long)4l, (long)2l, (long)5l, (long)1l))))     // (25l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)1l, (long)32l, (long)5107l, (long)34l, (long)83278l, (long)109l, (long)163l, (long)23l, (long)2323l, (long)32l, (long)30l, (long)1l, (long)9l, (long)3l))))     // (13l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)724l, (long)32l, (long)71l, (long)99l, (long)32l, (long)6l, (long)0l, (long)5l, (long)91l, (long)83l, (long)0l, (long)5l, (long)6l))))     // (11l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)81l, (long)12l, (long)3l, (long)1l, (long)21l))))     // (3l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)8l, (long)1l, (long)2l, (long)1l, (long)7l))))     // (7l)     public static long skjkasdkd(ArrayList<Long> lst) {         long max = 0l;         for(long i = 0;i < lst.size();i++) {             if(max < lst.get(i))                 max = lst.get(i);         }         if(max == 0l)             return 0l;         else {             List<Long> list = new ArrayList<Long>();             while(max > 0l) {                 list.add(max % 10l);                 max /= 10l;             }             long sum = 0l;             for(long i = 0;i < list.size();i++) {                 sum += list.get(i);             }             return sum;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of integers, return a pair consisting of a sum and a product of all the integers in an array array list.     // Empty sum should be equal to 0 and empty product should be equal to 1.     // >>> sumProduct((new ArrayList<Long>(Arrays.asList())))     // (Pair.with(0l, 1l))     // >>> sumProduct((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (Pair.with(10l, 24l))     public static Pair<Long, Long> sumProduct(ArrayList<Long> numbers) {         long product = 1;         long sum = 0;         for (long number : numbers) {             product *= number;             sum += number;         }         return Pair.with(sum, product);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes two positive numbers x and y and returns the     // biggest even integer number that is in the range [x, y] inclusive. If      // there's no such number, then the function should return -1.     // For example:     // >>> chooseNum((12l), (15l))     // (14l)     // >>> chooseNum((13l), (12l))     // (-1l)     public static long chooseNum(long x, long y) {         if (x % 2 == 0) {             if (y % 2 == 0) {                 return Math.max(x, y);             } else {                 return y - 1;             }         } else if (y % 2 == 0) {             return x + 1;         } else {             return Math.max(x, y - 1);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns a pair (a, b), where 'a' is     // the largest of negative integers, and 'b' is the smallest     // of positive integers in an array array list.     // If there is no negative or positive integers, return them as null.     // Examples:     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l, (long)7l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(1l))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList())))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     public static Pair<Optional<Long>, Optional<Long>> largestSmallestIntegers(ArrayList<Long> lst) {         // ...
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string, find out how many distinct characters (regardless of case) does it consist of     // >>> countDistinctCharacters(("xyzXYZ"))     // (3l)     // >>> countDistinctCharacters(("Jerry"))     // (4l)     public static long countDistinctCharacters(String string) {         Set<Character> set = new HashSet<Character>();         for (int i = 0; i < string.length(); i++) {             set.add(string.charAt(i));         }         return set.size();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, you have to make a pile of n levels of stones.     // The first level has n stones.     // The number of stones in the next level is:     // - the next odd number if n is odd.     // - the next even number if n is even.     // Return the number of stones in each level in an array array list, where element at index     // i represents the number of stones in the level (i+1).     // Examples:     // >>> makeAPile((3l))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)7l)))     public static ArrayList<Long> makeAPile(long n) {         ArrayList<Long> result = new ArrayList<Long>();         result.add(n);         while (n != 1) {             if (n % 2 == 1) {                 n = n * 3 + 1;             } else {                 n = n / 2;             }             result.add(n);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list arr of integers and you need to return     // sum of magnitudes of integers multiplied by product of all signs     // of each number in the array array list, represented by 1, -1 or 0.     // Note: return null for empty arr.     // Example:     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)-4l))))     // Optional.of(9l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l))))     // Optional.of(0l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     public static Optional<Long> prodSigns(ArrayList<Long> arr) {         return prodSigns(arr.stream().mapToLong(l->l).boxed().collect(Collectors.toList()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers nums, find the minimum sum of any non-empty sub-array array list     // of nums.     // Example     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l, (long)1l, (long)2l, (long)4l))))     // (1l)     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l))))     // (-6l)     public static long minSubArraySum(ArrayList<Long> nums) {         long sum = 0;         long min = Long.MAX_VALUE;         for(int i = 0; i < nums.size(); i++) {             sum += nums.get(i);             if(sum < min)                 min = sum;             if(sum < 0)                 sum = 0;         }         if(min == Long.MAX_VALUE)             return 0;         return min;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a string containing space-delimited numbers starting from 0 upto n inclusive.     // >>> stringSequence((0l))     // ("0")     // >>> stringSequence((5l))     // ("0 1 2 3 4 5")     public static String stringSequence(long n) {         List<String> str_list = new ArrayList<>();         for (int i = 0; i <= n; i++) {             str_list.add(Long.toString(i));         }         return String.join(" ", str_list);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word     // >>> cycpatternCheck(("abcd"), ("abd"))     // (false)     // >>> cycpatternCheck(("hello"), ("ell"))     // (true)     // >>> cycpatternCheck(("whassup"), ("psus"))     // (false)     // >>> cycpatternCheck(("abab"), ("baa"))     // (true)     // >>> cycpatternCheck(("efef"), ("eeff"))     // (false)     // >>> cycpatternCheck(("himenss"), ("simen"))     // (true)     public static boolean cycpatternCheck(String a, String b) {         return (a.contains(b) || a.contains(b.substring(1)) || a.contains(b.substring(2)) || a.contains(b.substring(3)));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true is array list elements are monotonically increasing or decreasing.     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)20l))))     // (true)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))))     // (false)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)0l, (long)-10l))))     // (true)     public static boolean monotonic(ArrayList<Long> l) {         // Note: Could be done with a single traversal of the list, as in a single pass         // through the array.         int length = l.size();         long val = l.get(0);         boolean increasing = (val - l.get(1)) < 0;         for (int i = 1; i < length; i++) {             long val2 = l.get(i);             if (val2 > val) {                 if (!increasing) return false;                 val = val2;             } else if (val2 < val) {                 if (increasing) return false;                 val = val2;             } else {                 val = val2;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Out of array list of strings, return the longest one. Return the first one in case of multiple     // strings of the same length. Return null in case the input array list is empty.     // >>> longest((new ArrayList<String>(Arrays.asList())))     // Optional.empty()     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // Optional.of("a")     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"bb", (String)"ccc"))))     // Optional.of("ccc")     public static Optional<String> longest(ArrayList<String> strings) {         if (strings.size() == 0)             return Optional.empty();         return strings.stream().max((str1, str2) -> str1.length() - str2.length());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if all numbers in the array list l are below threshold t.     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)10l))), (100l))     // (true)     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))), (5l))     // (false)     public static boolean belowThreshold(ArrayList<Long> l, long t) {         return l.stream().allMatch(n -> n < t);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the given number is the multiplication of 3 prime numbers     // and false otherwise.     // Knowing that (a) is less then 100.      // Example:     // >>> isMultiplyPrime((30l))     // (true)     // 30 = 2 * 3 * 5     public static boolean isMultiplyPrime(long a) {         // Fill up this function
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return only positive numbers in the array list.     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)-1l, (long)2l, (long)-4l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)6l)))     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)3l, (long)9l, (long)123l, (long)1l)))     public static ArrayList<Long> getPositive(ArrayList<Long> l) {         return l.stream().filter(x -> x > 0).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal     // to the values of the corresponding indicies of l, but sorted.     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)5l)))     public static ArrayList<Long> sortThird(ArrayList<Long> l) {         List<Long> result = new ArrayList<>();         int idx = 0;         for(Long val : l) {             if(idx % 3 == 0) {                 result.add(val);             }             idx += 1;         }         return new ArrayList<Long>(result);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.     // For each of the group, output the deepest level of nesting of parentheses.     // E.g. (()()) has maximum two levels of nesting while ((())) has three.     // >>> parseNestedParens(("(()()) ((())) () ((())()())"))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))     public static ArrayList<Long> parseNestedParens(String paren_string) {         Stack<Character> stack = new Stack<Character>();         ArrayList<Long> result = new ArrayList<Long>();         long max = 0;         int index = 0;         for (Character c : paren_string.toCharArray()) {             if (c == '(') {                 stack.push(c);             }             if (c == ')') {                 stack.pop();                 result.add(Long.valueOf(stack.size()));                 if (stack.size() > max) {                     max = stack.size();                 }             }             index++;         }         result.add(max);         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given length of a side and high return area for a triangle.     // >>> triangleArea((5l), (3l))     // (7.5f)     public static float triangleArea(long a, long h) {         return (a * h) / 2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Complete the function that takes two integers and returns      // the product of their unit digits.     // Assume the input is always valid.     // Examples:     // >>> multiply((148l), (412l))     // (16l)     // >>> multiply((19l), (28l))     // (72l)     // >>> multiply((2020l), (1851l))     // (0l)     // >>> multiply((14l), (-15l))     // (20l)     public static long multiply(long a, long b) {         long result = 0;         List<Integer> aDigits = getUnitDigits(a);         List<Integer> bDigits = getUnitDigits(b);         for (int i = 0; i < aDigits.size(); i++) {             result += aDigits.get(i) * bDigits.get(i);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of input numbers, calculate Mean Absolute Deviation     // around the mean of this dataset.     // Mean Absolute Deviation is the average absolute difference between each     // element and a centerpoint (mean in this case):     // MAD = average | x - x_mean |     // >>> meanAbsoluteDeviation((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f))))     // (1.0f)     public static float meanAbsoluteDeviation(ArrayList<Float> numbers) {         float sum = 0.0f;         float mean = 0.0f;         float diff = 0.0f;         float meanAbsoluteDeviation = 0.0f;          for (Float number : numbers) {             sum += number;         }         mean = sum / (float)numbers.size();          for (Float number : numbers) {             diff = Math.abs(mean - number);             meanAbsoluteDeviation += diff;         }         meanAbsoluteDeviation = meanAbsoluteDeviation / (float)numbers.size();          return meanAbsoluteDeviation;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique common elements for two array lists.     // >>> common((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l, (long)34l, (long)653l, (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)1l, (long)5l, (long)9l, (long)653l, (long)121l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)653l)))     // >>> common((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     public static ArrayList<Long> common(ArrayList<Long> l1, ArrayList<Long> l2) {         ArrayList<Long> result = new ArrayList<Long>();         for (long num : l1) {             if (l2.contains(num)) {                 result.add(num);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer, obtain its roman numeral equivalent as a string,     // and return it in lowercase.     // Restrictions: 1 <= num <= 1000     // Examples:     // >>> intToMiniRoman((19l))     // ("xix")     // >>> intToMiniRoman((152l))     // ("clii")     // >>> intToMiniRoman((426l))     // ("cdxxvi")     public static String intToMiniRoman(long number) {         long[] vals = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};         String[] syms = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};         StringBuilder sb = new StringBuilder();         for (int i = 0; i < vals.length; i++) {             while (number >= vals[i]) {                 sb.append(syms[i]);                 number -= vals[i];             }         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this task, you will be given a string that represents a number of apples and oranges      // that are distributed in a basket of fruit this basket contains      // apples, oranges, and mango fruits. Given the string that represents the total number of      // the oranges and apples and an integer that represent the total number of the fruits      // in the basket return the number of the mango fruits in the basket.     // for examble:     // >>> fruitDistribution(("5 apples and 6 oranges"), (19l))     // (8l)     // >>> fruitDistribution(("0 apples and 1 oranges"), (3l))     // (2l)     // >>> fruitDistribution(("2 apples and 3 oranges"), (100l))     // (95l)     // >>> fruitDistribution(("100 apples and 1 oranges"), (120l))     // (19l)     public static long fruitDistribution(String s, long n) {         long count = 0;         String[] arr = s.split(" ");         int a = Integer.parseInt(arr[0].split("apple")[0]);         int o = Integer.parseInt(arr[2].split("orange")[0]);         if (n - a - o >= 0) {             count = n - a - o;         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c     // then check if the result string is palindrome.     // A string is called palindrome if it reads the same backward as forward.     // You should return a pair containing the result string and true/false for the check.     // Example     // >>> reverseDelete(("abcde"), ("ae"))     // (Pair.with("bcd", false))     // >>> reverseDelete(("abcdef"), ("b"))     // (Pair.with("acdef", false))     // >>> reverseDelete(("abcdedcba"), ("ab"))     // (Pair.with("cdedc", true))     public static Pair<String, Boolean> reverseDelete(String s, String c) {         // Write your code here         List<Character> cList = new ArrayList<>();         for (char ch: c.toCharArray()) cList.add(ch);         StringBuilder sb = new StringBuilder();         for (char ch: s.toCharArray()) {             if (!cList.contains(ch)) sb.append(ch);         }         String ss = sb.toString();         return Pair.with(ss, ss.equals(new StringBuilder(ss).reverse().toString()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a greatest common divisor of two integers a and b     // >>> greatestCommonDivisor((3l), (5l))     // (1l)     // >>> greatestCommonDivisor((25l), (15l))     // (5l)     public static long greatestCommonDivisor(long a, long b) {         long m = 0;         long n = 0;         if (a > b) {             m = a;             n = b;         } else {             m = b;             n = a;         }         while (n != 0) {             long temp = n;             n = m % n;             m = temp;         }         return m;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this Kata, you have to sort an array array list of non-negative integers according to     // number of ones in their binary representation in ascending order.     // For similar number of ones, sort based on decimal value.     // It must be implemented like this:     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)-2l, (long)-3l, (long)-4l, (long)-5l, (long)-6l))))     // (new ArrayList<Long>(Arrays.asList((long)-6l, (long)-5l, (long)-4l, (long)-3l, (long)-2l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l)))     public static ArrayList<Long> sortArray(ArrayList<Long> arr) {         arr.sort(Comparator.comparing(Long::bitCount).thenComparing(a -> a));         return arr;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Concatenate array list of strings into a single string     // >>> concatenate((new ArrayList<String>(Arrays.asList())))     // ("")     // >>> concatenate((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // ("abc")     public static String concatenate(ArrayList<String> strings) {         return String.join("", strings);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings as a parameter,     // deletes the strings that have odd lengths from it,     // and returns the resulted array list with a sorted order,     // The array list is always an array array list of strings and never an array array list of numbers,     // and it may contain duplicates.     // The order of the array list should be ascending by length of each word, and you     // should return the array list sorted by that rule.     // If two words have the same length, sort the array list alphabetically.     // The function should return an array array list of strings in sorted order.     // You may assume that all words will have the same length.     // For example:     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"aa", (String)"a", (String)"aaa"))))     // (new ArrayList<String>(Arrays.asList((String)"aa")))     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"ab", (String)"a", (String)"aaa", (String)"cd"))))     // (new ArrayList<String>(Arrays.asList((String)"ab", (String)"cd")))     public static ArrayList<String> sortedListSum(ArrayList<String> lst) {         // write your code here         return lst.stream().sorted(Comparator.comparing(String::length).thenComparing(s -> s)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that contain given substring     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"array")))     public static ArrayList<String> filterBySubstring(ArrayList<String> strings, String substring) {         List<String> s = strings.stream().filter(str -> str.contains(substring)).collect(Collectors.toList());         return new ArrayList<String>(s);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a value (string) representing a number     // and returns the closest integer to it. If the number is equidistant     // from two integers, round it away from zero.     // Examples     // >>> closestInteger(("10"))     // (10l)     // >>> closestInteger(("15.3"))     // (15l)     // Note:     // Rounding away from zero means that if the given number is equidistant     // from two integers, the one you should return is the one that is the     // farthest from zero. For example closest_integer("14.5") should     // return 15 and closest_integer("-14.5") should return -15.     public static long closestInteger(String value) {         // your code here         return Long.parseLong(new BigDecimal(value).setScale(0, RoundingMode.HALF_UP).toPlainString());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function vowels_count which takes a string representing     // a word as input and returns the number of vowels in the string.     // Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a     // vowel, but only when it is at the end of the given word.     // Example:     // >>> vowelsCount(("abcde"))     // (2l)     // >>> vowelsCount(("ACEDY"))     // (3l)     public static long vowelsCount(String s) {         s = s.toLowerCase();         return s.chars().filter(ch -> ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'y')                 .count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings.     // The array list contains different words. Return the word with maximum number     // of unique characters. If multiple strings have maximum number of unique     // characters, return the one which comes first in lexicographical order.     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"of", (String)"string"))))     // ("string")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"enam", (String)"game"))))     // ("enam")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"aaaaaaa", (String)"bb", (String)"cc"))))     // ("aaaaaaa")     public static String findMax(ArrayList<String> words) {         String s1 = "";         int count = 0;         for(int i=0; i<words.size(); i++){             int[] arr = new int[26];             for(int j=0; j<words.get(i).length(); j++) {                 arr[words.get(i).charAt(j)-'a'] += 1;             }             for(int j=0; j<26; j++){                 if(arr[j] > count) {                     s1 = words.get(i);                     count = arr[j];                 }             }         }         return s1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string 'text', return its md5 hash equivalent string.     // If 'text' is an empty string, return null.     // >>> stringToMd5(("Hello world"))     // Optional.of("3e25960a79dbc69b674cd4ec67a72c62")     public static Optional<String> stringToMd5(String text) {         if (text == null || text.isEmpty()) {             return Optional.empty();         }          try {             MessageDigest md = MessageDigest.getInstance("MD5");             md.update(text.getBytes());             BigInteger hash = new BigInteger(1, md.digest());             return Optional.of(hash.toString(16));         } catch (NoSuchAlgorithmException e) {             return Optional.empty();         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Change numerical base of input number x to base.     // return string representation after the conversion.     // base numbers are less than 10.     // >>> changeBase((8l), (3l))     // ("22")     // >>> changeBase((8l), (2l))     // ("1000")     // >>> changeBase((7l), (2l))     // ("111")     public static String changeBase(long x, long base) {         String s = Long.toString(x, (int) base);         return s;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return true if the three     // sides form a right-angled triangle, false otherwise.     // A right-angled triangle is a triangle in which one angle is right angle or      // 90 degree.     // Example:     // >>> rightAngleTriangle((3l), (4l), (5l))     // (true)     // >>> rightAngleTriangle((1l), (2l), (3l))     // (false)     public static boolean rightAngleTriangle(long a, long b, long c) {         // Fill this in.         return a**2 + b**2 == c**2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // It is the last week of the semester and the teacher has to give the grades     // to students. The teacher has been making her own algorithm for grading.     // The only problem is, she has lost the code she used for grading.     // She has given you an array array list of GPAs for some students and you have to write      // a function that can output an array array list of letter grades using the following table:     // GPA       |    Letter grade     // 4.0                A+     // > 3.7                A      // > 3.3                A-      // > 3.0                B+     // > 2.7                B      // > 2.3                B-     // > 2.0                C+     // > 1.7                C     // > 1.3                C-     // > 1.0                D+      // > 0.7                D      // > 0.0                D-     // 0.0                E     // Example:     // >>> gradeEquation((new ArrayList<Float>(Arrays.asList((float)4.0f, (float)3l, (float)1.7f, (float)2l, (float)3.5f))))     // (new ArrayList<String>(Arrays.asList((String)"A+", (String)"B", (String)"C-", (String)"C", (String)"A-")))     public static ArrayList<String> numericalLetterGrade(ArrayList<Float> grades) {         return grades.stream()                 .map(Problem::numericalLetterGrade)                 .collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Insert a number 'delimeter' between every two consecutive elements of input array list `numbers'     // >>> intersperse((new ArrayList<Long>(Arrays.asList())), (4l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> intersperse((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))), (4l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)4l, (long)3l)))     public static ArrayList<Long> intersperse(ArrayList<Long> numbers, long delimeter) {         ArrayList<Long> res = new ArrayList<>();         for (int i=0; i < numbers.size(); i++) {             res.add(numbers.get(i));             if (i < numbers.size() - 1) res.add(delimeter);         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an array array list of numbers as input and returns      // the number of elements in the array array list that are greater than 10 and both      // first and last digits of a number are odd (1, 3, 5, 7, 9).     // For example:     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)15l, (long)-73l, (long)14l, (long)-15l))))     // (1l)     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)33l, (long)-2l, (long)-3l, (long)45l, (long)21l, (long)109l))))     // (2l)     public static long specialFilter(ArrayList<Long> nums) {         // Fill this in.         Stream<Long> s1 = nums.stream().filter(n -> n>10).filter(n -> n%10%2 !=0).filter(n -> n%100%10%2 != 0);         return s1.count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // sum_to_n is a function that sums numbers from 1 to n.     // >>> sumToN((30l))     // (465l)     // >>> sumToN((100l))     // (5050l)     // >>> sumToN((5l))     // (15l)     // >>> sumToN((10l))     // (55l)     // >>> sumToN((1l))     // (1l)     public static long sumToN(long n) {         return n * (n+1) / 2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From an array array list of integers, remove all elements that occur more than once.     // Keep order of elements left the same as in the input.     // >>> removeDuplicates((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)4l)))     public static ArrayList<Long> removeDuplicates(ArrayList<Long> numbers) {         ArrayList<Long> answer = new ArrayList<Long>();         for (Long number : numbers) {             if (answer.contains(number)) {                 answer.remove(number);             } else {                 answer.add(number);             }         }         return answer;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two positive integers a and b, return the even digits between a     // and b, in ascending order.     // For example:     // >>> generateIntegers((2l), (8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((8l), (2l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((10l), (14l))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> generateIntegers(long a, long b) {         if (a % 2 != 0) {             a++;         }         if (b % 2 != 0) {             b--;         }         return IntStream.rangeClosed((int) a, (int) b).filter(i -> i % 2 == 0).boxed().collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a given array list of integers, generate an array array list of rolling maximum element found until given moment     // in the sequence.     // >>> rollingMax((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)3l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l)))     public static ArrayList<Long> rollingMax(ArrayList<Long> numbers) {         ArrayList<Long> output = new ArrayList<Long>(numbers.size());         output.add(numbers.get(0));         int current_index = 1;         long current_max = output.get(0);         while (current_index < numbers.size()) {             long current_number = numbers.get(current_index);             if (current_number > current_max) {                 current_max = current_number;             }             output.add(current_max);             current_index = current_index + 1;         }         return output;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're given an array array list of deposit and withdrawal operations on a bank account that starts with     // zero balance. Your task is to detect if at any point the balance of account fallls below zero, and     // at that point function should return true. Otherwise it should return false.     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (false)     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)-4l, (long)5l))))     // (true)     public static boolean belowZero(ArrayList<Long> operations) {         // Write your code here         long bal = 0l;         for (long l : operations) bal += l;         return bal < 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a non-empty array list of positive integers. Return the greatest integer that is greater than      // zero, and has a frequency greater than or equal to the value of the integer itself.      // The frequency of an integer is the number of times it appears in the array list.     // If no such a value exist, return -1.     // Examples:     // >>> search((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)2l, (long)2l, (long)3l, (long)1l))))     // (2l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l, (long)4l))))     // (3l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)4l, (long)4l, (long)4l))))     // (-1l)     public static long search(ArrayList<Long> lst) {         long largest = -1l;         for (long num : lst) {             if (num > 0l && (num == largest || largest == -1l))                 largest = num;             else if (num > 0l)                 return num;         }         return largest;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "(" and ")".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("("))     // (false)     // >>> correctBracketing(("()"))     // (true)     // >>> correctBracketing(("(()())"))     // (true)     // >>> correctBracketing((")(()"))     // (false)     public static boolean correctBracketing(String brackets) {         // return (brackets.contains("(") && brackets.contains(")")) ? (         // (brackets.replace("(", "") + brackets.replace(")", "")).contains("")) : false;         int left, right;         left = brackets.indexOf("(");         right = brackets.lastIndexOf(")");         while (left >= 0 && right >= 0 && left < right) {             brackets = brackets.substring(0, left) + brackets.substring(left + 1);             left = brackets.indexOf("(");             right = brackets.lastIndexOf(")");         }         return (left < 0 && right < 0) ? true : false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the odd indicies, while its values at the even indicies are equal     // to the values of the even indicies of l, but sorted.     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)6l, (long)5l, (long)4l)))     public static ArrayList<Long> sortEven(ArrayList<Long> l) {         return l.stream().map(i -> i % 2 == 0 ? i : LongStream.of(l.get(l.indexOf(i) + 1).intValue(), i.intValue()).min().getAsLong()).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if two words have the same characters.     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddeddabc"))     // (true)     // >>> sameChars(("abcd"), ("dddddddabc"))     // (true)     // >>> sameChars(("dddddddabc"), ("abcd"))     // (true)     // >>> sameChars(("eabcd"), ("dddddddabc"))     // (false)     // >>> sameChars(("abcd"), ("dddddddabce"))     // (false)     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddddabc"))     // (false)     public static boolean sameChars(String s0, String s1) {         return new HashSet<>(s0.split("")).equals(new HashSet<>(s1.split("")));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "<" and ">".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("<"))     // (false)     // >>> correctBracketing(("<>"))     // (true)     // >>> correctBracketing(("<<><>>"))     // (true)     // >>> correctBracketing(("><<>"))     // (false)     public static boolean correctBracketing(String brackets) {         Stack<Character> stack = new Stack<>();         for (int i = 0; i < brackets.length(); i++) {             char c = brackets.charAt(i);             if (c == '<') {                 stack.push(c);             } else if (c == '>') {                 if (stack.isEmpty()) {                     return false;                 }                 stack.pop();             }         }         return stack.isEmpty();
