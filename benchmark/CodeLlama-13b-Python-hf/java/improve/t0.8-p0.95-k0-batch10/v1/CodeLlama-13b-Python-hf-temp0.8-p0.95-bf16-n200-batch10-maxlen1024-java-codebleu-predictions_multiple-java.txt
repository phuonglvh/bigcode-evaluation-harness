import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return length of given string     // >>> stringLength((""))     // (0l)     // >>> stringLength(("abc"))     // (3l)     public static long strlen(String string) {         return (long)string.length();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function encrypt that takes a string as an argument and     // returns a string encrypted with the alphabet being rotated.      // The alphabet should be rotated in a manner such that the letters      // shift down by two multiplied to two places.     // For example:     // >>> encrypt(("hi"))     // ("lm")     // >>> encrypt(("asdfghjkl"))     // ("ewhjklnop")     // >>> encrypt(("gf"))     // ("kj")     // >>> encrypt(("et"))     // ("ix")     public static String encrypt(String s) {         String l = "abcdefghijklmnopqrstuvwxyz";         StringBuilder sb = new StringBuilder();         for (int i = 0; i < s.length(); i++) {             if (l.indexOf(s.charAt(i)) < l.length() - 2 * 2)                 sb.append(l.charAt(l.indexOf(s.charAt(i)) + 2 * 2));             else                 sb.append(l.charAt(l.indexOf(s.charAt(i)) - 26 + 2 * 2));         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a hash map, return true if all keys are strings in lower      // case or all keys are strings in upper case, else return false.     // The function should return false is the given hash map is empty.     // Examples:     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "b", "banana"))))     // (true)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "A", "banana", "B", "banana"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", 8l, "banana", "a", "apple"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("Name", "John", "Age", "36", "City", "Houston"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("STATE", "NC", "ZIP", "12345"))))     // (true)     public static boolean checkDictCase(HashMap<String,String> dict) {         if (dict.size() == 0)             return false;         int counter = 0;         for (String s : dict.values()) {             if (s.matches("[a-z]+"))                 counter++;             if (s.matches("[A-Z]+"))                 counter--;         }         return counter == 0 || counter == -dict.size();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers lst. add the even elements that are at odd indices..     // Examples:     // >>> add((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)6l, (long)7l))))     // (2l)     public static long add(ArrayList<Long> lst) {         long sum = 0;         for (int i = 0; i < lst.size(); i += 2) {             sum += lst.get(i);         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string text, replace all spaces in it with underscores,      // and if a string has more than 2 consecutive spaces,      // then replace all consecutive spaces with -      // >>> fixSpaces((" Example"))     // ("Example")     // >>> fixSpaces((" Example 1"))     // ("Example_1")     // >>> fixSpaces((" Example 2"))     // ("_Example_2")     // >>> fixSpaces((" Example 3"))     // ("_Example-3")     public static String fixSpaces(String text) {         int consecutive = 0;         String finalString = "";         for (int i = 0; i < text.length(); i++) {             if (text.charAt(i) == ' ') {                 if (++consecutive == 2) {                     finalString += "-";                     consecutive = 0;                 }                 else if (consecutive == 1) {                     finalString += "_";                 }             }             else {                 finalString += text.charAt(i);                 consecutive = 0;             }         }         return finalString;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fibfib(0) == 0     // fibfib(1) == 0     // fibfib(2) == 1     // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).     // Please write a function to efficiently compute the n-th element of the fibfib number sequence.     // >>> fibfib((1l))     // (0l)     // >>> fibfib((5l))     // (4l)     // >>> fibfib((8l))     // (24l)     public static long fibfib(long n) {         if(n == 0 || n == 1)             return 0;         if(n == 2)             return 1;         long prev1 = 0;         long prev2 = 1;         long prev3 = 1;         long curr = 2;         while(curr <= n) {             prev3 = prev2;             prev2 = prev1;             prev1 = curr;             curr = prev1 + prev2 + prev3;         }         return curr - n;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return the sum of squares of the numbers     // in the array list that are odd. Ignore numbers that are negative or not integers.     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)0l))))     // (10l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)-1l, (long)-2l, (long)0l))))     // (0l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)9l, (long)-2l))))     // (81l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)0l))))     // (0l)     // If the input array list is empty, return 0.     public static long doubleTheDifference(ArrayList<Float> lst) {         // Write your code here.         return 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter given array list of any javathon values only for integers     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList((String)"a", (String)3.14f, (String)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList(1l, 2l, 3l, "abc", new HashMap<Long,Long>(Map.of()), new ArrayList<Long>(Arrays.asList())))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     public static ArrayList<Long> filterIntegers(ArrayList<Object> values) {         ArrayList<Long> integers = new ArrayList<Long>();         for(Object object : values){             if(object instanceof Integer || object instanceof Long || object instanceof Byte || object instanceof Short || object instanceof Double || object instanceof Float){                 integers.add((long)object);             }         }         return integers;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Imagine a road that's a perfectly straight infinitely long line.     // n cars are driving left to right;  simultaneously, a different set of n cars     // are driving right to left.   The two sets of cars start out being very far from     // each other.  All cars move in the same speed.  Two cars are said to collide     // when a car that's moving left to right hits a car that's moving right to left.     // However, the cars are infinitely sturdy and strong; as a result, they continue moving     // in their trajectory as if they did not collide.     // This function outputs the number of such collisions.     public static long carRaceCollision(long n) {         if (n < 2) {             return 0;         }         // solve with 2 and recurse         return 1 + carRaceCollision(n - 1) + carRaceCollision(n - 2);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string representing musical notes in a special ASCII format.     // Your task is to parse this string and return array list of integers corresponding to how many beats does each     // not last.     // Here is a legend:     // 'o' - whole note, lasts four beats     // 'o|' - half note, lasts two beats     // '.|' - quater note, lasts one beat     // >>> parseMusic(("o o| .| o| o| .| .| .| .| o o"))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)1l, (long)2l, (long)2l, (long)1l, (long)1l, (long)1l, (long)1l, (long)4l, (long)4l)))     public static ArrayList<Long> parseMusic(String music_string) {         ArrayList<Long> result = new ArrayList<>();         String[] notes = music_string.split(" ");         for (int i = 0; i < notes.length; i++) {             switch (notes[i]) {                 case "o":                     result.add(4l);                     break;                 case "o|":                     result.add(2l);                     break;                 case ".|":                     result.add(1l);                     break;             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a number in decimal form and your task is to convert it to     // binary format. The function should return a string, with each character representing a binary     // number. Each character in the string will be '0' or '1'.     // There will be an extra couple of characters 'db' at the beginning and at the end of the string.     // The extra characters are there to help with the format.     // Examples:     // >>> decimalToBinary((15l))     // ("db1111db")     // >>> decimalToBinary((32l))     // ("db100000db")     public static String decimalToBinary(long decimal) {         String result = "";         while (decimal != 0) {             long rem = decimal % 2;             result = (char) ('0' + rem) + result;             decimal = decimal / 2;         }         result = "db" + result + "db";         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of all prefixes from shortest to longest of the input string     // >>> allPrefixes(("abc"))     // (new ArrayList<String>(Arrays.asList((String)"a", (String)"ab", (String)"abc")))     public static ArrayList<String> allPrefixes(String string) {         ArrayList<String> returnArrayList = new ArrayList<String>();         for (int i = 0; i < string.length(); i++) {             returnArrayList.add(string.substring(0, i + 1));         }         return returnArrayList;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Add two numbers x and y     // >>> add((2l), (3l))     // (5l)     // >>> add((5l), (7l))     // (12l)     public static long add(long x, long y) {         return x+y;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're a hungry rabbit, and you already have eaten a certain number of carrots,     // but now you need to eat more carrots to complete the day's meals.     // you should return an array array list of [ total number of eaten carrots after your meals,     // the number of carrots left after your meals ]     // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.     // Example:     // >>> eat((5l), (6l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)4l)))     // >>> eat((4l), (8l), (9l))     // (new ArrayList<Long>(Arrays.asList((long)12l, (long)1l)))     // >>> eat((1l), (10l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)0l)))     // >>> eat((2l), (11l), (5l))     // (new ArrayList<Long>(Arrays.asList((long)7l, (long)0l)))     // Variables:     // @number : integer     // the number of carrots that you have eaten.     // @need : integer     // the number of carrots that you need to eat.     // @remaining : integer     // the number of remaining carrots thet exist in stock     // Constrain:     // * 0 <= number <= 1000     // * 0 <= need <= 1000     // * 0 <= remaining <= 1000     // Have fun :)     public static ArrayList<Long> eat(long number, long need, long remaining) {         ArrayList<Long> list = new ArrayList<Long>();         list.add(number+need);         list.add(remaining-need);         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a rectangular grid of wells. Each row represents a single well,     // and each 1 in a row represents a single unit of water.     // Each well has a corresponding bucket that can be used to extract water from it,      // and all buckets have the same capacity.     // Your task is to use the buckets to empty the wells.     // Output the number of times you need to lower the buckets.     // Example 1:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l))))), (1l))     // (6l)     // Example 2:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)1l, (long)1l))))), (2l))     // (5l)     // Example 3:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l))))), (5l))     // (0l)     // Constraints:     // * all wells have the same length     // * 1 <= grid.length <= 10^2     // * 1 <= grid[:,1].length <= 10^2     // * grid[i][j] -> 0 | 1     // * 1 <= capacity <= 10     public static long maxFill(ArrayList<ArrayList<Long>> grid, long capacity) {         // Use a 2D array to represent the grid. 1 in grid[i][j] means that there is water in well i at depth j,         // 0 otherwise. For every well i, we can only remove water from depth 0 until capacity.         // To find the maximum number of water removed, we have to find the maximum total number of 1s in the grid.         // Notice that, if we choose to remove water from depth j in well i, the number of 1s in the well i         // decreases by 1.         int rows = grid.size();         int cols = grid.get(0).size();         ArrayList<ArrayList<Long>> results = new ArrayList<ArrayList<Long>>();         for (int r = 0; r < rows; r++) {             ArrayList<Long> row = new ArrayList<Long>();             results.add(row);             for (int c = 0; c < cols; c++) {                 if (grid.get(r).get(c) != 0L) {                     row.add(capacity);                 } else {                     row.add(0L);                 }             }         }         int maxWater = 0;         while (true) {             int water = 0;             boolean change = false;             for (int r
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two array lists operator, and operand. The first array list has basic algebra operations, and      // the second array list is an array array list of integers. Use the two given array lists to build the algebric      // expression and return the evaluation of this expression.     // The basic algebra operations:     // Addition ( + )      // Subtraction ( - )      // Multiplication ( * )      // Floor division ( // )      // Exponentiation ( ** )      // Example:     // operator['+', '*', '-']     // array array list = [2, 3, 4, 5]     // result = 2 + 3 * 4 - 5     // => result = 9     // Note:     // The length of operator array list is equal to the length of operand array list minus one.     // Operand is an array array list of of non-negative integers.     // Operator array list has at least one operator, and operand array list has at least two operands.     public static long doAlgebra(ArrayList<String> op, ArrayList<Long> operand) {         String operator = op.get(0);         int operatorIndex = op.indexOf(operator);         long result = operand.get(0);         for (int i = 1; i < operand.size() - 1; i++) {             long operand1 = result;             operator = op.get(operatorIndex++);             long operand2 = operand.get(i);             if (operator.equals("+")) {                 result += operand2;             } else if (operator.equals("-")) {                 result -= operand2;             } else if (operator.equals("*")) {                 result *= operand2;             } else if (operator.equals("//")) {                 result /= operand2;             } else if (operator.equals("**")) {                 result = Math.pow(result, operand2);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given string, flip lowercase characters to uppercase and uppercase to lowercase.     // >>> flipCase(("Hello"))     // ("hELLO")     public static String flipCase(String string) {         return string.chars().mapToObj(i -> (char)(i > 96 && i < 123 ? i - 32 : i < 91 && i > 64 ? i + 32 : (char)i)).collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers, sort the integers that are between 1 and 9 inclusive,     // reverse the resulting array array list, and then replace each digit by its corresponding name from     // "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".     // For example:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l, (long)1l, (long)4l, (long)5l, (long)8l, (long)2l, (long)3l))))     // (new ArrayList<String>(Arrays.asList((String)"Eight", (String)"Five", (String)"Four", (String)"Three", (String)"Two", (String)"Two", (String)"One", (String)"One")))     // If the array array list is empty, return an empty array array list:     // >>> byLength((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // If the array array list has any strange number ignore it:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)55l))))     // (new ArrayList<String>(Arrays.asList((String)"One")))     public static ArrayList<String> byLength(ArrayList<Long> arr) {         ArrayList<String> newArrayList = new ArrayList<String>();         ArrayList<String> ignoreArrayList = new ArrayList<String>();         ArrayList<String> numbers = new ArrayList<String>(Arrays.asList("One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"));         for(Long x : arr){             if(x >= 1 && x <= 9){                 newArrayList.add(numbers.get(x.intValue() - 1));             } else {                 ignoreArrayList.add(numbers.get(x.intValue() - 1));             }         }         return newArrayList;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of prime factors of given integer in the order from smallest to largest.     // Each of the factors should be array listed number of times corresponding to how many times it appeares in factorization.     // Input number should be equal to the product of all factors     // >>> factorize((8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)2l)))     // >>> factorize((25l))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l)))     // >>> factorize((70l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)7l)))     public static ArrayList<Long> factorize(long n) {         ArrayList<Long> list = new ArrayList<Long>();         ArrayList<Long> fact = new ArrayList<Long>();         long i = 2;         while(i * i <= n) {             if(n % i == 0) {                 n = n / i;                 fact.add(i);             } else {                 i++;             }         }         fact.add(n);         for(int j = 0; j < fact.size(); j++) {             long count = 0;             long num = fact.get(j);             while(n % num == 0) {                 n = n / num;                 count++;             }             list.add(num);             while(count > 1) {                 list.add(num);                 count--;             }         }         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement a function that takes an non-negative integer and returns an array array list of the first n     // integers that are prime numbers and less than n.     // for example:     // >>> countUpTo((5l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     // >>> countUpTo((11l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l)))     // >>> countUpTo((0l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((20l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l, (long)19l)))     // >>> countUpTo((1l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((18l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l)))     public static ArrayList<Long> countUpTo(long n) {         ArrayList<Long> list = new ArrayList<Long>();         if(n <= 1) {             return list;         }         list.add(2l);         for(long i = 3; i < n; i += 2) {             boolean prime = true;             for(long j = 2; j < i; j++) {                 if(i % j == 0) {                     prime = false;                     break;                 }             }             if(prime) {                 list.add(i);             }         }         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique elements in an array array list     // >>> unique((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)2l, (long)3l, (long)5l, (long)9l, (long)123l)))     public static ArrayList<Long> unique(ArrayList<Long> l) {         ArrayList<Long> a = new ArrayList<Long>(new TreeSet<>(l));         return a;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts two array lists of strings and returns the array list that has      // total number of chars in the all strings of the array list less than the other array list.     // if the two array lists have the same number of chars, return the first array list.     // Examples     // >>> totalMatch((new ArrayList<String>(Arrays.asList())), (new ArrayList<String>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hi", (String)"hi", (String)"admin", (String)"project"))))     // (new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"4"))), (new ArrayList<String>(Arrays.asList((String)"1", (String)"2", (String)"3", (String)"4", (String)"5"))))     // (new ArrayList<String>(Arrays.asList((String)"4")))     public static ArrayList<String> totalMatch(ArrayList<String> lst1, ArrayList<String> lst2) {         ArrayList<String> arr = new ArrayList<String>();         int i = 0;         int j = 0;         int n = 0;         int m = 0;         if(lst1.size()<lst2.size()) {             n = lst1.size();             m = lst2.size();         }         else {             n = lst2.size();             m = lst1.size();         }         while(i<n && j<m) {             if(lst1.get(i).length()<lst2.get(j).length()) {                 arr.add(lst1.get(i));                 i++;             }             else if(lst1.get(i).length()>lst2.get(j).length()) {                 arr.add(lst2.get(j));                 j++;             }             else {                 arr.add(lst1.get(i));                 i++;                 j++;             }         }         if(lst1.size()<lst2.size()) {             while(j<lst2.size()) {                 arr.add(lst2.get(j));                 j++;             }         }         else {             while(i<lst1.size()) {                 arr.add(lst1.get(i));                 i++;             }         }         return arr;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return maximum element in the array list.     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (3l)     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (123l)     public static long maxElement(ArrayList<Long> l) {         long result = -1;         for (long i : l) {             result = Math.max(result, i);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a string as input which contains only square brackets.     // The function should return true if and only if there is a valid subsequence of brackets      // where at least one bracket in the subsequence is nested.     // >>> isNested(("[[]]"))     // (true)     // >>> isNested(("[]]]]]]][[[[[]"))     // (false)     // >>> isNested(("[][]"))     // (false)     // >>> isNested(("[]"))     // (false)     // >>> isNested(("[[][]]"))     // (true)     // >>> isNested(("[[]][["))     // (true)     public static boolean isNested(String string) {         int[] brackets = new int[string.length()];         int counter = 0;         for (int i = 0; i < string.length(); i++) {             if (string.charAt(i) == '[') {                 brackets[counter] = i;                 counter++;             }         }         int flag = 0;         for (int i = 0; i < counter; i++) {             if (brackets[i] > brackets[i+1]) {                 flag = 1;             }         }         if (flag == 1) {             return true;         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of strings, where each string consists of only digits, return an array array list.     // Each element i of the output should be "the number of odd elements in the     // string i of the input." where all the i's should be replaced by the number     // of odd digits in the i'th string of the input.     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"1234567"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 4n the str4ng 4 of the 4nput.")))     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"3", (String)"11111111"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 1n the str1ng 1 of the 1nput.", (String)"the number of odd elements 8n the str8ng 8 of the 8nput.")))     public static ArrayList<String> oddCount(ArrayList<String> lst) {         ArrayList<String> retList = new ArrayList<String>();         int[] num = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};         for (int i = 0; i < lst.size(); i++) {             int count = 0;             for (int j = 0; j < lst.get(i).length(); j++) {                 if (lst.get(i).charAt(j) == '1' || lst.get(i).charAt(j) == '3' || lst.get(i).charAt(j) == '5' || lst.get(i).charAt(j) == '7' || lst.get(i).charAt(j) == '9') {                     count++;                 }             }             if (count % 2 == 0) {                 retList.add("the number of odd elements " + num[i] + "n the str" + num[i] + "ng " + num[i] + " of the " + num[i] + "nput.");             } else {                 retList.add("the number of odd elements " + num[i] + "n the str" + num[i] + "ng " + num[i] + " of the " + num[i] + "nput.");             }         }         return retList;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // We have an array array list 'arr' of N integers arr[1], arr[2], ..., arr[N].The     // numbers in the array array list will be randomly ordered. Your task is to determine if     // it is possible to get an array array list sorted in non-decreasing order by performing      // the following operation on the given array array list:     // You are allowed to perform right shift operation any number of times.     // One right shift operation means shifting all elements of the array array list by one     // position in the right direction. The last element of the array array list will be moved to     // the starting position in the array array list i.e. 0th index.      // If it is possible to obtain the sorted array array list by performing the above operation     // then return true else return false.     // If the given array array list is empty then return true.     // Note: The given array list is guaranteed to have unique elements.     // For Example:     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)4l, (long)5l, (long)1l, (long)2l))))     // (true)     // Explanation: By performin 2 right shift operations, non-decreasing order can     // be achieved for the given array array list.     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)4l, (long)1l, (long)2l))))     // (false)     // Explanation:It is not possible to get non-decreasing order for the given     // array array list by performing any number of right shift operations.     public static boolean moveOneBall(ArrayList<Long> arr) {         // Write your code here         int N = arr.size();         int pos = N-1;         while(pos != 0 && arr.get(pos) >= arr.get(pos-1)) --pos;         if(pos == 0) return true;         int i = pos;         while(i+1 < N && arr.get(i) > arr.get(i+1)) ++i;         if(i+1 == N) return true;         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a pair that has the number of even and odd     // integer palindromes that fall within the range(1, n), inclusive.     // Example 1:     // >>> evenOddPalindrome((3l))     // (Pair.with(1l, 2l))     // Explanation:     // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.     // Example 2:     // >>> evenOddPalindrome((12l))     // (Pair.with(4l, 6l))     // Explanation:     // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.     // Note:     // 1. 1 <= n <= 10^3     // 2. returned pair has the number of even and odd integer palindromes respectively.     public static Pair<Long, Long> evenOddPalindrome(long n) {         long count_even = 0;         long count_odd = 0;         for (long i = 0; i <= n; i++) {             String i_str = Long.toString(i);             String reverse_i_str = new StringBuilder(i_str).reverse().toString();             long reverse_i = Long.valueOf(reverse_i_str);             if (i == reverse_i && i % 2 == 0) {                 count_even++;             } else if (i == reverse_i && i % 2 != 0) {                 count_odd++;             }         }         return Pair.with(count_even, count_odd);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers     // Example     // >>> isEqualToSumEven((4l))     // (false)     // >>> isEqualToSumEven((6l))     // (false)     // >>> isEqualToSumEven((8l))     // (true)     public static boolean isEqualToSumEven(long n) {         long sum = 0l;         for(int i = 1; i <= n; i++) {             if(i % 2 == 0) {                 sum += i;             }         }         return sum == n;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // xs represent coefficients of a polynomial.     // xs[0] + xs[1] * x + xs[2] * x^2 + ....     // Return derivative of this polynomial in the same form.     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)12l, (long)20l)))     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l)))     public static ArrayList<Long> derivative(ArrayList<Long> xs) {         return new ArrayList<Long>(             xs.stream()                 .limit(xs.size()-1)                 .map(x -> x * (xs.size()-1))                 .skip(1)                 .collect(Collectors.toList()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return whether or not they are sorted     // in ascending order. If array list has more than 1 duplicate of the same     // number, return false. Assume no negative numbers and only integers.     // Examples     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)4l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)2l, (long)3l, (long)4l))))     // (false)     public static boolean isSorted(ArrayList<Long> lst) {         if (lst.size() <= 1)             return true;         for (int i = 1; i < lst.size(); i++) {             if (lst.get(i) < lst.get(i - 1)) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // if s[i] is a letter, reverse its case from lower to upper or vise versa,      // otherwise keep it as it is.     // If the string contains no letters, reverse the string.     // The function should return the resulted string.     // Examples     // >>> solve(("1234"))     // ("4321")     // >>> solve(("ab"))     // ("AB")     // >>> solve(("#a@C"))     // ("#A@c")     public static String solve(String s) {         for(int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if(Character.isLetter(c)) {                 if(Character.isUpperCase(c)) {                     s = s.replace(c, Character.toLowerCase(c));                 } else if(Character.isLowerCase(c)) {                     s = s.replace(c, Character.toUpperCase(c));                 }                 return s;             }         }         return new StringBuilder(s).reverse().toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in      // the last couple centuries. However, what people don't know is Tribonacci sequence.     // Tribonacci sequence is defined by the recurrence:     // tri(1) = 3     // tri(n) = 1 + n / 2, if n is even.     // tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.     // For example:     // tri(2) = 1 + (2 / 2) = 2     // tri(4) = 3     // tri(3) = tri(2) + tri(1) + tri(4)     // = 2 + 3 + 3 = 8      // You are given a non-negative integer number n, you have to a return an array array list of the      // first n + 1 numbers of the Tribonacci sequence.     // Examples:     // >>> tri((3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l)))     public static ArrayList<Long> tri(long n) {         if (n == 0) {             ArrayList<Long> a = new ArrayList<Long>();             a.add(0l);             return a;         } else if (n == 1) {             ArrayList<Long> a = new ArrayList<Long>();             a.add(0l);             a.add(3l);             return a;         } else {             ArrayList<Long> a = new ArrayList<Long>();             a.add(0l);             a.add(3l);             a.add(2l);             for (int i = 3; i <= n; i++) {                 a.add(i % 2 == 0 ? (long) (1 + (i / 2)) : (long) (a.get((int) i - 1) + a.get((int) i - 2) + a.get((int) i + 1)));             }             return a;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.     // >>> fizzBuzz((50l))     // (0l)     // >>> fizzBuzz((78l))     // (2l)     // >>> fizzBuzz((79l))     // (3l)     public static long fizzBuzz(long n) {         return Stream.iterate(1L, x -> x + 1L)                 .limit(n - 1)                 .filter(x -> x % 11L == 0L || x % 13L == 0L)                 .filter(x -> String.valueOf(x).contains("7"))                 .count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that start with a given prefix.     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bcd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"array")))     public static ArrayList<String> filterByPrefix(ArrayList<String> strings, String prefix) {         return strings.stream().filter(s -> s.startsWith(prefix)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer N, return the total sum of its digits in binary.     // Example     // >>> solve((1000l))     // ("1")     // >>> solve((150l))     // ("110")     // >>> solve((147l))     // ("1100")     // Variables:     // @N integer     // Constraints: 0 ≤ N ≤ 10000.     // Output:     // a string of binary number     public static String solve(long N) {         return Long.toBinaryString(N).replace("0b", "");
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a grid with N rows and N columns (N >= 2) and a positive integer k,      // each cell of the grid contains a value. Every integer in the range [1, N * N]     // inclusive appears exactly once on the cells of the grid.     // You have to find the minimum path of length k in the grid. You can start     // from any cell, and in each step you can move to any of the neighbor cells,     // in other words, you can go to cells which share an edge with you current     // cell.     // Please note that a path of length k means visiting exactly k cells (not     // necessarily distinct).     // You CANNOT go off the grid.     // A path A (of length k) is considered less than a path B (of length k) if     // after making the ordered array lists of the values on the cells that A and B go     // through (let's call them lst_A and lst_B), lst_A is lexicographically less     // than lst_B, in other words, there exist an integer index i (1 <= i <= k)     // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have     // lst_A[j] = lst_B[j].     // It is guaranteed that the answer is unique.     // Return an ordered array list of the values on the cells that the minimum path go through.     // Examples:         // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)9l))))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l)))     // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)9l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)2l))))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)1l)))     public static ArrayList<Long> minPath(ArrayList<ArrayList<Long>> grid, long k) {         class State {             ArrayList<Long> path;             State(ArrayList<Long> path) { this.path = path; }             public boolean equals(Object other) {                 if (this == other) return true;                 if (other == null) return false;                 if (!(other instanceof State)) return false;                 return ((State) other).path.equals(this.path);             }             public int hashCode() {                 return this.path.hashCode();             }             public String toString() {                 return this.path.toString();             }         }         class Path implements Comparable<Path> {             ArrayList<Long> path;             long len;             public Path(ArrayList<Long> path, long len) {                 this.path = path;                 this.len = len;             }             public int compareTo(Path other) {                 return Long.compare(this.len, other.len);             }         }         ArrayList<ArrayList<Long>> visited = new ArrayList<ArrayList<Long>>();         class StackEntry {             int i, j;             int len;             public StackEntry(int i, int j, int len) {                 this.i = i; this.j = j; this.len = len;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s, count the number of uppercase vowels in even indices.     // For example:     // >>> countUpper(("aBCdEf"))     // (1l)     // >>> countUpper(("abcdefg"))     // (0l)     // >>> countUpper(("dBBE"))     // (0l)     public static long countUpper(String s) {         long res = 0;         int i = 0;         for(char c : s.toCharArray()) {             if(Character.isUpperCase(c) && "AEIOU".indexOf(c) >= 0 && i % 2 == 0) {                 res++;             }             i++;         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers and a positive integer k, return a sorted array list      // of length k with the maximum k numbers in arr.     // Example 1:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)-4l, (long)5l))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)-4l, (long)-3l, (long)5l)))     // Example 2:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)4l, (long)-4l, (long)4l))), (2l))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l)))     // Example 3:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)2l, (long)1l, (long)2l, (long)-1l, (long)-2l, (long)1l))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)2l)))     // Note:     // 1. The length of the array array list will be in the range of [1, 1000].     // 2. The elements in the array array list will be in the range of [-1000, 1000].     // 3. 0 <= k <= len(arr)     public static ArrayList<Long> maximum(ArrayList<Long> arr, long k) {         class Stack<T> {             private List<T> _list = new ArrayList<>();             public void push(T item) {                 _list.add(item);             }             public T pop() {                 if (_list.size() > 0) {                     T item = _list.get(_list.size() - 1);                     _list.remove(item);                     return item;                 } else {                     return null;                 }             }             public void clear() {                 _list.clear();             }             public boolean isEmpty() {                 return _list.isEmpty();             }             public T peek() {                 if (_list.size() > 0) {                     return _list.get(_list.size() - 1);                 } else {                     return null;                 }             }             public List<T> items() {                 return _list;             }         }         Stack<Long> stack = new Stack<Long>();         for (long i : arr) {             if (stack.isEmpty()) {                 stack.push(i);             } else {                 if (i >= stack.peek()) {                     if (stack.size() == k) {                         stack.pop();                     }                     stack.push(i);                 }             }         }         return new ArrayList<Long>(stack.items());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given number n, find the largest number that divides n evenly, smaller than n     // >>> largestDivisor((15l))     // (5l)     public static long largestDivisor(long n) {         // Your code here         return n > 0l ? n / 2 : 0l;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of non-negative integers, return a cojava of the given array array list after sorting,     // you will sort the given array array list in ascending order if the sum( first index value, last index value) is odd,     // or sort it in descending order if the sum( first index value, last index value) is even.     // Note:     // * don't change the given array array list.     // Examples:     // >>> sortArray((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)5l, (long)4l, (long)3l, (long)2l, (long)1l, (long)0l)))     public static ArrayList<Long> sortArray(ArrayList<Long> array) {         if (array == null || array.size() == 0) {             return array;         }         if (array.size() == 1) {             return array;         }         int sum = array.get(0) + array.get(array.size() - 1);         ArrayList<Long> sorted = new ArrayList<>();         if (sum % 2 == 0) {             sorted = new ArrayList<>(array);             Collections.reverse(sorted);         } else {             sorted = new ArrayList<>(array);         }         return sorted;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement the function f that takes n as a parameter,     // and returns an array array list of size n, such that the value of the element at index i is the factorial of i if i is even     // or the sum of numbers from 1 to i otherwise.     // i starts from 1.     // the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).     // Example:     // >>> f((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)6l, (long)24l, (long)15l)))     public static ArrayList<Long> f(long n) {         ArrayList<Long> result = new ArrayList<Long>();         for (int i = 1; i <= n; i++) {             if (i % 2 == 0) {                 result.add((long)i);                 long temp = 1;                 for (int j = i; j > 0; j--) {                     temp = temp * j;                 }                 result.set(result.size() - 1, temp);             } else {                 long sum = 0;                 for (int j = 1; j <= i; j++) {                     sum = sum + j;                 }                 result.add(sum);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an integer a and returns true      // if this ingeger is a cube of some integer number.     // Note: you may assume the input is always valid.     // Examples:     // >>> iscube((1l))     // (true)     // >>> iscube((2l))     // (false)     // >>> iscube((-1l))     // (true)     // >>> iscube((64l))     // (true)     // >>> iscube((0l))     // (true)     // >>> iscube((180l))     // (false)     public static boolean iscube(long a) {         long temp = (long) Math.cbrt(a);         return temp * temp * temp == a;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a message, and encodes in such a      // way that it swaps case of all letters, replaces all vowels in      // the message with the letter that appears 2 places ahead of that      // vowel in the english alphabet.      // Assume only letters.      // Examples:     // >>> encode(("test"))     // ("TGST")     // >>> encode(("This is a message"))     // ("tHKS KS C MGSSCGG")     public static String encode(String message) {     String result = "";     for (int i = 0; i < message.length(); i++) {       char ch = message.charAt(i);       if (Character.isUpperCase(ch)) {         result += (char) ('A' + (ch - 'A' + 2) % 26);       } else {         result += (char) ('a' + (ch - 'a' + 2) % 26);       }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You'll be given a string of words, and your task is to count the number     // of boredoms. A boredom is a sentence that starts with the word "I".     // Sentences are delimited by '.', '?' or '!'.     // For example:     // >>> isBored(("Hello world"))     // (0l)     // >>> isBored(("The sky is blue. The sun is shining. I love this weather"))     // (1l)     public static long isBored(String S) {         long counter = 0;         for (String s : S.split("[.?!]")) {             if (s.trim().startsWith("I"))                 counter++;         }         return counter;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // pairs_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are two distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)5l, (long)7l))))     // (true)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean pairsSumToZero(ArrayList<Long> l) {         HashMap<Long, Integer> map = new HashMap<Long, Integer>();         for (long i: l) {             if (map.containsKey(i)) {                 map.put(i, map.get(i) + 1);             } else {                 map.put(i, 1);             }         }         int twoSum = 0;         for (Long key: map.keySet()) {             long value = map.get(key);             if (map.containsKey(-key) && map.get(-key) != 1) {                 twoSum++;                 map.put(-key, map.get(-key) - 1);             }         }         return twoSum >= 2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return the area of     // the triangle rounded to 2 decimal points if the three sides form a valid triangle.      // Otherwise return -1     // Three sides make a valid triangle when the sum of any two sides is greater      // than the third side.     // Example:     // >>> triangleArea((3l), (4l), (5l))     // (6.0f)     // >>> triangleArea((1l), (2l), (10l))     // (float)-1l     public static float triangleArea(long a, long b, long c) {         if (a + b <= c || b + c <= a || a + c <= b)             return -1;         float s = (a + b + c) / 2;         float area = (float) Math.sqrt(s * (s - a) * (s - b) * (s - c));         return area;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // There are eight planets in our solar system: the closerst to the Sun      // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,      // Uranus, Neptune.     // Write a function that takes two planet names as strings planet1 and planet2.      // The function should return a pair containing all planets whose orbits are      // located between the orbit of planet1 and the orbit of planet2, sorted by      // the proximity to the sun.      // The function should return an empty pair if planet1 or planet2     // are not correct planet names.      // Examples     // >>> bf(("Jupiter"), ("Neptune"))     // (new ArrayList<String>(Arrays.asList((String)"Saturn", (String)"Uranus")))     // >>> bf(("Earth"), ("Mercury"))     // (ArrayList<String>("Venus"))     // >>> bf(("Mercury"), ("Uranus"))     // (new ArrayList<String>(Arrays.asList((String)"Venus", (String)"Earth", (String)"Mars", (String)"Jupiter", (String)"Saturn")))     public static ArrayList<String> bf(String planet1, String planet2) {         String[] planets = {"Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};         ArrayList<String> al = new ArrayList<String>();         int i1 = 0;         int i2 = 0;         int i = 0;         for(String s: planets) {             if(s.equals(planet1)) {                 i1 = i;             }             if(s.equals(planet2)) {                 i2 = i;             }             i++;         }         if(i1 > i2) {             int tmp = i1;             i1 = i2;             i2 = tmp;         }         for(int j = i1; j < i2; j++) {             al.add(planets[j]);         }         return al;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the product of the odd digits.     // Return 0 if all digits are even.     // For example:     // >>> digits((1l))     // (1l)     // >>> digits((4l))     // (0l)     // >>> digits((235l))     // (15l)     public static long digits(long n) {         return Stream.of(n).map(i -> i % 10).filter(i -> i % 2 != 0).fold(0l, (acc, e) -> acc * e);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a string of words separated by commas or spaces. Your task is     // to split the string into words and return an array array list of the words.     // For example:     // >>> wordsString(("Hi, my name is John"))     // (new ArrayList<String>(Arrays.asList((String)"Hi", (String)"my", (String)"name", (String)"is", (String)"John")))     // >>> wordsString(("One, two, three, four, five, six"))     // (new ArrayList<String>(Arrays.asList((String)"One", (String)"two", (String)"three", (String)"four", (String)"five", (String)"six")))     public static ArrayList<String> wordsString(String s) {         String[] words = s.split("[ ,]");         ArrayList<String> res = new ArrayList<String>(Arrays.asList(words));         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find how many times a given substring can be found in the original string. Count overlaping cases.     // >>> howManyTimes((""), ("a"))     // (0l)     // >>> howManyTimes(("aaa"), ("a"))     // (3l)     // >>> howManyTimes(("aaaa"), ("aa"))     // (3l)     public static long howManyTimes(String string, String substring) {         long count = 0;         for (int i = 0; i <= string.length() - substring.length(); i++) {             String s = string.substring(i, i + substring.length());             if (s.equals(substring)) {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // remove_vowels is a function that takes string and returns string without vowels.     // >>> removeVowels((""))     // ("")     // >>> removeVowels(("abcdef"))     // ("bcdf")     // >>> removeVowels(("aaaaa"))     // ("")     // >>> removeVowels(("aaBAA"))     // ("B")     // >>> removeVowels(("zbcd"))     // ("zbcd")     public static String removeVowels(String text) {         StringBuilder sb = new StringBuilder();         for(char c : text.toCharArray()) {             if("aeiou".indexOf(c) == -1)                 sb.append(c);         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of integers, return array list in strange order.     // Strange sorting, is when you start with the minimum value,     // then maximum of the remaining integers, then minimum and so on.     // Examples:     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)3l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> strangeSortList(ArrayList<Long> lst) {         ArrayList<Long> sorted = lst.stream().sorted().collect(Collectors.toCollection(ArrayList::new));         ArrayList<Long> result = new ArrayList<Long>();         for(int i = 0; i < lst.size(); i++) {             if(i % 2 == 0) {                 result.add(sorted.get(0));                 sorted.remove(0);             } else {                 result.add(sorted.get(sorted.size() - 1));                 sorted.remove(sorted.size() - 1);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a supplied array list of numbers (of length at least two) select and return two that are the closest to each     // other and return them in order (smaller number, larger number).     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f))))     // (Pair.with(2.0f, 2.2f))     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))))     // (Pair.with(2.0f, 2.0f))     public static Pair<Float, Float> findClosestElements(ArrayList<Float> numbers) {         float smallestDistance = -1;         float left = -1;         float right = -1;         int size = numbers.size();         for (int i = 0; i < size - 1; i++) {             for (int j = i + 1; j < size; j++) {                 float distance = Math.abs(numbers.get(i) - numbers.get(j));                 if (smallestDistance == -1 || distance < smallestDistance) {                     smallestDistance = distance;                     left = numbers.get(i);                     right = numbers.get(j);                 }             }         }         return Pair.with(left, right);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to write a function that returns true if a number x is a simple     // power of n and false in other cases.     // x is a simple power of n if n**int=x     // For example:     // >>> isSimplePower((1l), (4l))     // (true)     // >>> isSimplePower((2l), (2l))     // (true)     // >>> isSimplePower((8l), (2l))     // (true)     // >>> isSimplePower((3l), (2l))     // (false)     // >>> isSimplePower((3l), (1l))     // (false)     // >>> isSimplePower((5l), (3l))     // (false)     public static boolean isSimplePower(long x, long n) {         long t = (long) (Math.log10(x)/Math.log10(n));         if(Math.pow(n, t)==x)             return true;         else             return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // prime_fib returns n-th number that is a Fibonacci number and it's also prime.     // >>> primeFib((1l))     // (2l)     // >>> primeFib((2l))     // (3l)     // >>> primeFib((3l))     // (5l)     // >>> primeFib((4l))     // (13l)     // >>> primeFib((5l))     // (89l)     public static long primeFib(long n) {         int[] f = {1, 1};         int index = 0;         long p = 2;         while(index < n){             f[1] += f[0];             index += (f[1] % p == 0) ? 0 : 1;             f[0] = f[1] - f[0];             if(f[1] % p == 0)                 f[1] /= p;             p = getNextPrime(p);         }         return f[1];
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function which sorts the given array list of integers     // in ascending order according to the sum of their digits.     // Note: if there are several items with similar sum of their digits,     // order them based on their index in original array list.     // For example:     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList((long)1l, (long)11l, (long)-1l, (long)-11l, (long)-12l))))     // (new ArrayList<Long>(Arrays.asList((long)-1l, (long)-11l, (long)1l, (long)-12l, (long)11l)))     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> orderByPoints(ArrayList<Long> nums) {         return nums.stream()             .sorted((x, y) -> Integer.compare(                 sumOfDigits(x) + (nums.indexOf(x)),                 sumOfDigits(y) + (nums.indexOf(y))))             .collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if in given array list of numbers, are any two numbers closer to each other than     // given threshold.     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))), (0.5f))     // (false)     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))), (0.3f))     // (true)     public static boolean hasCloseElements(ArrayList<Float> numbers, float threshold) {         numbers.sort(null);         float i = 0;         int len = numbers.size();         for (i = 0; i < len - 1; i++)             if (numbers.get(i + 1) - numbers.get(i) <= threshold)                 return true;         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find the shortest palindrome that begins with a supplied string.     // Algorithm idea is simple:     // - Find the longest postfix of supplied string that is a palindrome.     // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.     // >>> makePalindrome((""))     // ("")     // >>> makePalindrome(("cat"))     // ("catac")     // >>> makePalindrome(("cata"))     // ("catac")     public static String makePalindrome(String string) {         int i = 1;         int n = string.length();         while (i < n && string.charAt(n - i) == string.charAt(n - i - 1))             i++;         return string + new StringBuilder(string).reverse();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input are two strings a and b consisting only of 1s and 0s.     // Perform binary XOR on these inputs and return result also as a string.     // >>> stringXor(("010"), ("110"))     // ("100")     public static String stringXor(String a, String b) {         int aLength = a.length();         int bLength = b.length();          StringBuilder sb = new StringBuilder();         for (int i = 0; i < Math.max(aLength, bLength); i++) {             char aChar = '0';             char bChar = '0';              if (i < aLength) {                 aChar = a.charAt(i);             }             if (i < bLength) {                 bChar = b.charAt(i);             }              sb.append(xor(aChar, bChar));         }          return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Brazilian factorial is defined as:     // brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!     // where n > 0     // For example:     // >>> specialFactorial((4l))     // (288l)     // The function will receive an integer as input and should return the special     // factorial of this integer.     public static long specialFactorial(long n) {         if (n < 0 || n > 100l) {             throw new IllegalArgumentException();         }         return n == 0 ? 1 : n * specialFactorial(n - 1);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array array list of integers arr and an integer k, return     // the sum of the elements with at most two digits from the first k elements of arr.     // Example:     // >>> addElements((new ArrayList<Long>(Arrays.asList((long)111l, (long)21l, (long)3l, (long)4000l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l))), (4l))     // (24l)     // Constraints:     // 1. 1 <= len(arr) <= 100     // 2. 1 <= k <= len(arr)     public static long addElements(ArrayList<Long> arr, long k) {         long res = 0l;         for(long i : arr.subList(0, (int)k)) {             int v = (int)(i % 100l);             res += v;         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fib4(0) -> 0     // fib4(1) -> 0     // fib4(2) -> 2     // fib4(3) -> 0     // fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).     // Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.     // >>> fib4((5l))     // (4l)     // >>> fib4((6l))     // (8l)     // >>> fib4((7l))     // (14l)     public static long fib4(long n) {         // Write your code here         long[] fib4 = {0, 0, 2, 0};         for (long i = 4; i <= n; i++) {             fib4[0] = fib4[1];             fib4[1] = fib4[2];             fib4[2] = fib4[3];             fib4[3] = fib4[0] + fib4[1] + fib4[2] + fib4[3];         }         return n > 3 ? fib4[3] : fib4[(int) n];
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of positive integers x. return a sorted array list of all      // elements that hasn't any even digit.     // Note: Returned array list should be sorted in increasing order.     // For example:     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)15l, (long)33l, (long)1422l, (long)1l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)15l, (long)33l)))     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)152l, (long)323l, (long)1422l, (long)10l))))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> uniqueDigits(ArrayList<Long> x) {         return x.stream().filter(i -> i.toString().chars().anyMatch(c -> c % 2 != 0)).sorted().collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s and a natural number n, you have been tasked to implement      // a function that returns an array array list of all words from string s that contain exactly      // n consonants, in order these words appear in the string s.     // If the string s is empty then the function should return an empty array list.     // Note: you may assume the input string contains only letters and spaces.     // Examples:     // >>> selectWords(("Mary had a little lamb"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"little")))     // >>> selectWords(("Mary had a little lamb"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Mary", (String)"lamb")))     // >>> selectWords(("simple white space"), (2l))     // (new ArrayList<String>(Arrays.asList()))     // >>> selectWords(("Hello world"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"world")))     // >>> selectWords(("Uncle sam"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Uncle")))     public static ArrayList<String> selectWords(String s, long n) {         if (s.isEmpty()) {             return new ArrayList<String>();         } else {             ArrayList<String> words = new ArrayList<String>();             String[] tokens = s.split(" ");             for (String word : tokens) {                 char[] charArray = word.toCharArray();                 int count = 0;                 for (int i = 0; i < charArray.length; i++) {                     if (charArray[i] != 'a' && charArray[i] != 'e' && charArray[i] != 'i' && charArray[i] != 'o' && charArray[i] != 'u') {                         count++;                     }                 }                 if (count == n) {                     words.add(word);                 }             }             return words;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the object q will fly, and false otherwise.     // The object q will fly if it's balanced (it is a palindromic array list) and the sum of its elements is less than or equal the maximum possible weight w.     // Example:     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l))), (5l))     // (false)     // # 1+2 is less than the maximum possible weight, but it's unbalanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (1l))     // (false)     // # it's balanced, but 3+2+3 is more than the maximum possible weight.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (9l))     // (true)     // # 3+2+3 is less than the maximum possible weight, and it's balanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l))), (5l))     // (true)     // # 3 is less than the maximum possible weight, and it's balanced.     public static boolean willItFly(ArrayList<Long> q, long w) {         if(q.size() == 0){             return false;         }         if(q.size() == 1){             return true;         }         boolean balanced = isBalanced(q);         if(balanced){             long sum = sum(q);             if(sum < w){                 return true;             }else{                 return false;             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return n-th Fibonacci number.     // >>> fib((10l))     // (55l)     // >>> fib((1l))     // (1l)     // >>> fib((8l))     // (21l)     public static long fib(long n) {         if(n == 1) return 1;         else if(n == 2) return 2;         else return fib(n-1) + fib(n-2);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given the name of a class (a string) and an array array list of extensions.     // The extensions are to be used to load additional classes to the class. The     // strength of the extension is as follows: Let CAP be the number of the uppercase     // letters in the extension's name, and let SM be the number of lowercase letters      // in the extension's name, the strength is given by the fraction CAP - SM.      // You should find the strongest extension and return a string in this      // format: ClassName.StrongestExtensionName.     // If there are two or more extensions with the same strength, you should     // choose the one that comes first in the array list.     // For example, if you are given "Slices" as the class and an array array list of the     // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should     // return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension      // (its strength is -1).     // Example:     // >>> StrongestExtension(("my_class"), (new ArrayList<String>(Arrays.asList((String)"AA", (String)"Be", (String)"CC"))))     // ("my_class.AA")     public static String StrongestExtension(String class_name, ArrayList<String> extensions) {       String strongest = "";       int max = -9999;       for (String extension : extensions) {         int strength = 0;         for (int i = 0; i < extension.length(); i++) {           if (extension.charAt(i) >= 'A' && extension.charAt(i) <= 'Z') {             strength += 1;           } else if (extension.charAt(i) >= 'a' && extension.charAt(i) <= 'z') {             strength -= 1;           }         }         if (strength > max) {           max = strength;           strongest = extension;         }       }       return class_name + "." + strongest;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of two strings, both strings consist of open     // parentheses '(' or close parentheses ')' only.     // Your job is to check if it is possible to concatenate the two strings in     // some order, that the resulting string will be good.     // A string S is considered to be good if and only if all parentheses in S     // are balanced. For example: the string '(())()' is good, while the string     // '())' is not.     // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.     // Examples:     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)"()(", (String)")"))))     // ("Yes")     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)")", (String)")"))))     // ("No")     public static String matchParens(ArrayList<String> lst) {         // Write your code here         int str1 = lst.get(0).length();         int str2 = lst.get(1).length();         if (str1 == 0 && str2 == 0) {             return "Yes";         }         if (str1 % 2 == 1 || str2 % 2 == 1) {             return "No";         }         str1 = str1 / 2;         str2 = str2 / 2;         if (str1 == 0) {             if (lst.get(1).charAt(str2) == '(') {                 return "No";             }             for (int i = str2 - 1; i >= 0; i--) {                 if (lst.get(1).charAt(i) == ')') {                     return "No";                 }             }             return "Yes";         }         if (str2 == 0) {             if (lst.get(0).charAt(str1) == ')') {                 return "No";             }             for (int i = str1 - 1; i >= 0; i--) {                 if (lst.get(0).charAt(i) == '(') {                     return "No";                 }             }             return "Yes";         }         for (int i = str1 - 1; i >= 0; i--) {             if (lst.get(0).charAt(i) == ')') {                 return "No";             }         }         for (int i = str2 - 1; i >= 0; i--) {             if (lst.get(1).charAt(i) == '(') {                 return "No";             }         }         return "Yes";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // Write a function next_smallest() that returns the 2nd smallest element of the array list.     // Return null if there is no such element.     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)5l, (long)1l, (long)4l, (long)3l, (long)2l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l))))     // Optional.empty()     public static Optional<Long> nextSmallest(ArrayList<Long> lst) {         Optional<Long> ret = Optional.empty();         if(lst.size() > 0){             List<Long> list = new ArrayList<Long>(lst);             Collections.sort(list);             ret = Optional.of(list.get(0));             for(int i=1; i<list.size(); i++){                 if(list.get(i) > list.get(0)){                     ret = Optional.of(list.get(i));                     break;                 }             }         }         return ret;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes 3 numbers.     // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.     // Returns false in any other cases.     // Examples     // >>> anyInt((float)5l, (float)2l, (float)7l)     // (true)     // >>> anyInt((float)3l, (float)2l, (float)2l)     // (false)     // >>> anyInt((float)3l, (float)-2l, (float)1l)     // (true)     // >>> anyInt((3.6f), (-2.2f), (float)2l)     // (false)     public static boolean anyInt(float x, float y, float z) {         float sum = x + y;         if (x == sum && x == z) return true;         if (y == sum && y == z) return true;         if (z == sum && z == x) return true;         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive floating point number, it can be decomposed into     // and integer part (largest integer smaller than given number) and decimals     // (leftover part always smaller than 1).     // Return the decimal part of the number.     // >>> truncateNumber((3.5f))     // (0.5f)     public static float truncateNumber(float number) {       float decimal = number - (int) number;       return decimal;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list with elements incremented by 1.     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l)))     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)4l, (long)6l, (long)3l, (long)4l, (long)4l, (long)10l, (long)1l, (long)124l)))     public static ArrayList<Long> incrList(ArrayList<Long> l) {         return new ArrayList<>(l.stream().map(i -> i + 1L).collect(Collectors.toList()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // A simple program which should return the value of x if n is      // a prime number and should return the value of y otherwise.     // Examples:     // >>> xOrY((7l), (34l), (12l))     // (34l)     // >>> xOrY((15l), (8l), (5l))     // (5l)     public static long xOrY(long n, long x, long y) {         if(isPrime(n)){             return x;         }         else{             return y;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return 2^n modulo p (be aware of numerics).     // >>> modp((3l), (5l))     // (3l)     // >>> modp((1101l), (101l))     // (2l)     // >>> modp((0l), (101l))     // (1l)     // >>> modp((3l), (11l))     // (8l)     // >>> modp((100l), (101l))     // (1l)     public static long modp(long n, long p) {       long res = 1;       for (long i = 0; i < n; i++) {         res *= 2;         if (res >= p) {           res -= p;         }       }       return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an integer. return a pair that has the number of even and odd digits respectively.     // Example:     // >>> evenOddCount((-12l))     // (Pair.with(1l, 1l))     // >>> evenOddCount((123l))     // (Pair.with(1l, 2l))     public static Pair<Long, Long> evenOddCount(long num) {         int even = 0;         int odd = 0;         char[] arr = String.valueOf(num).toCharArray();         for (int i = 0; i < arr.length; i++) {             if (arr[i] % 2 == 0) {                 even++;             } else {                 odd++;             }         }         return new Pair<Long, Long>((long) even, (long) odd);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // Your task is to check if the string is hapjava or not.     // A string is hapjava if its length is at least 3 and every 3 consecutive letters are distinct     // For example:     // >>> isHappy(("a"))     // (false)     // >>> isHappy(("aa"))     // (false)     // >>> isHappy(("abcd"))     // (true)     // >>> isHappy(("aabb"))     // (false)     // >>> isHappy(("adb"))     // (true)     // >>> isHappy(("xyy"))     // (false)     public static boolean isHappy(String s) {         int i = 0;         while (i < s.length()) {             if (s.charAt(i) == s.charAt(i+1) && s.charAt(i) == s.charAt(i+2)) {                 return false;             }             i += 3;         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the largest prime factor of n. Assume n > 1 and is not a prime.     // >>> largestPrimeFactor((13195l))     // (29l)     // >>> largestPrimeFactor((2048l))     // (2l)     public static long largestPrimeFactor(long n) {         // check if n is prime         if (isPrime(n))             return n;         // find largest prime factor         long largestFactor = 0;         for (long factor = 2; factor * factor <= n; factor++) {             if (n % factor == 0) {                 n /= factor;                 largestFactor = factor;             }         }         if (largestFactor == 0)             return n;         return largestFactor;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // Write a function that takes a string as input and returns the sum of the upper characters only'     // ASCII codes.     // Examples:     // >>> digitSum((""))     // (0l)     // >>> digitSum(("abAB"))     // (131l)     // >>> digitSum(("abcCd"))     // (67l)     // >>> digitSum(("helloE"))     // (69l)     // >>> digitSum(("woArBld"))     // (131l)     // >>> digitSum(("aAaaaXa"))     // (153l)     public static long digitSum(String s) {         long ans=0;         for(int i=0;i<s.length();i++){             char c=s.charAt(i);             if(Character.isUpperCase(c)){                 ans+=c;             }         }         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of numbers (of at least two elements), apply a linear transform to that array list,     // such that the smallest number will become 0 and the largest will become 1     // >>> rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f))))     // (new ArrayList<Float>(Arrays.asList((float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f)))     public static ArrayList<Float> rescaleToUnit(ArrayList<Float> numbers) {         float max = Collections.max(numbers);         float min = Collections.min(numbers);         float scale = 1 / (max - min);         for (int i = 0; i < numbers.size(); i++) {             float num = numbers.get(i);             num = (num - min) * scale;             numbers.set(i, num);         }         return numbers;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers, return the sum of all of the odd elements that are in even positions.     // Examples     // >>> solution((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)7l, (long)1l))))     // (12l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l, (long)3l, (long)3l))))     // (9l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)30l, (long)13l, (long)24l, (long)321l))))     // (0l)     public static long solution(ArrayList<Long> lst) {         int odds = 0;         int evenSum = 0;         for (int i = 0; i < lst.size(); i++) {             if (lst.get(i) % 2 == 1 && i % 2 == 0) {                 odds++;                 evenSum += lst.get(i);             }         }         if (odds == 0) {             return 0;         } else {             return evenSum;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "Given an array array list representing a branch of a tree that has non-negative integer nodes     // your task is to pluck one of the nodes and return it.     // The plucked node should be the node with the smallest even value.     // If multiple nodes with the same smallest even value are found return the node that has smallest index.     // The plucked node should be returned in an array array list, [ smalest_value, its index ],     // If there are no even values or the given array array list is empty, return [].     // Example 1:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 2:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 3:     // >>> pluck((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // Example 4:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l, (long)0l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))     // Explanation: 0 is the smallest value, but  there are two zeros,     // so we will choose the first zero, which has the smallest index.     // Constraints:     // * 1 <= nodes.length <= 10000     // * 0 <= node.value     public static ArrayList<Long> pluck(ArrayList<Long> arr) {         ArrayList<Long> res = new ArrayList<Long>();         if(arr.isEmpty())             return res;         long even = Long.MAX_VALUE;         int index = -1;         for(int i = 0; i < arr.size(); i++) {             if(arr.get(i) % 2 == 0) {                 if(arr.get(i) < even) {                     even = arr.get(i);                     index = i;                 }             }         }         if(index == -1)             return res;         res.add(even);         res.add((long)index);         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a positive integer n. You have to create an integer array array list a of length n.     // For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.     // Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,      // and a[i] + a[j] + a[k] is a multiple of 3.     // Example :     // >>> getMaxTriples((5l))     // (1l)     // Explanation:      // a = [1, 3, 7, 13, 21]     // The only valid triple is (1, 7, 13).     public static long getMaxTriples(long n) {         long[] a = new long[(int)n];         for(int i=0;i<a.length;i++) a[i] = i*i - i + 1;         long cnt = 0;         for(int i=0;i<a.length;i++) {             for(int j=i+1;j<a.length;j++) {                 for(int k=j+1;k<a.length;k++) {                     long x = a[i] + a[j] + a[k];                     if(x % 3 == 0) cnt++;                 }             }         }         return cnt;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this problem, you will implement a function that takes two array lists of numbers,     // and determines whether it is possible to perform an exchange of elements     // between them to make lst1 an array array list of only even numbers.     // There is no limit on the number of exchanged elements between lst1 and lst2.     // If it is possible to exchange elements between the lst1 and lst2 to make     // all the elements of lst1 to be even, return "YES".     // Otherwise, return "NO".     // For example:     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // ("YES")     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)3l, (long)4l))))     // ("NO")     // It is assumed that the input array lists will be non-empty.     public static String exchange(ArrayList<Long> lst1, ArrayList<Long> lst2) {         // write your code here         for(int i=0;i<lst1.size();i++){             if(lst1.get(i)%2!=0){                 for(int j=0;j<lst2.size();j++){                     if(lst2.get(j)%2==0){                         long temp=lst1.get(i);                         lst1.set(i,lst2.get(j));                         lst2.set(j,temp);                         break;                     }                 }             }         }         for(int i=0;i<lst1.size();i++){             if(lst1.get(i)%2!=0){                 return "NO";             }         }         return "YES";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return median of elements in the array list l.     // >>> median((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (float)3l     // >>> median((new ArrayList<Long>(Arrays.asList((long)-10l, (long)4l, (long)6l, (long)1000l, (long)10l, (long)20l))))     // (15.0f)     public static float median(ArrayList<Long> l) {         if(l.size() == 0) {             return 0;         }         if(l.size() == 1) {             return l.get(0);         }         Collections.sort(l);         if(l.size() % 2 == 0) {             return (float)(l.get(l.size()/2-1) + l.get(l.size()/2))/2;         }         else {             return l.get(l.size()/2);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns true if the string     // length is a prime number or false otherwise     // Examples     // >>> primeLength(("Hello"))     // (true)     // >>> primeLength(("abcdcba"))     // (true)     // >>> primeLength(("kittens"))     // (true)     // >>> primeLength(("orange"))     // (false)     public static boolean primeLength(String string) {         // Write your code here         int len = string.length();         if(len == 0 || len == 1) return false;         else {             for(int i = 2; i <= Math.sqrt(len); i++) {                 if(len % i == 0) return false;             }             return true;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers, find the minimum number of elements that     // need to be changed to make the array array list palindromic. A palindromic array array list is an array array list that     // is read the same backwards and forwards. In one change, you can change one element to any other element.     // For example:     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)5l, (long)4l, (long)7l, (long)9l, (long)6l))))     // (4l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)3l, (long)2l, (long)2l))))     // (1l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)1l))))     // (0l)     public static long smallestChange(ArrayList<Long> arr) {         int n = arr.size();         // Find all subarrays of arr that is palindromic         List<Integer> indices = new ArrayList<Integer>();         for (int i = 0; i < n; i++) {             int j = 0;             while (i + j < n && (i - j) >= 0 && arr.get(i + j) == arr.get(i - j)) {                 j += 1;             }             if (i + j - 1 == i) {                 indices.add(i);             }         }         int numChanges = 0;         for (int i = 0; i < indices.size() - 1; i++) {             numChanges += Math.abs(indices.get(i) - indices.get(i + 1)) - 1;         }         return numChanges;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of numbers.     // You need to return the sum of squared numbers in the given array list,     // round each element in the array list to the upper int(Ceiling) first.     // Examples:     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))))     // (14l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)4.0f, (float)9.0f))))     // (98l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f))))     // (84l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.4f, (float)4.2f, (float)0.0f))))     // (29l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)-2.4f, (float)1.0f, (float)1.0f))))     // (6l)     public static long sumSquares(ArrayList<Float> lst) {         long sum = 0;         for (Float f : lst) {             int rounded = (int)Math.ceil(f);             sum += Math.pow(rounded, 2);         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which takes a string representing a file's name, and returns     // 'Yes' if the the file's name is valid, and returns 'No' otherwise.     // A file's name is considered to be valid if and only if all the following conditions      // are met:     // - There should not be more than three digits ('0'-'9') in the file's name.     // - The file's name contains exactly one dot '.'     // - The substring before the dot should not be empty, and it starts with a letter from      // the latin alphapet ('a'-'z' and 'A'-'Z').     // - The substring after the dot should be one of these: ['txt', 'exe', 'dll']     // Examples:     // >>> fileNameCheck(("example.txt"))     // ("Yes")     // >>> fileNameCheck(("1example.dll"))     // ("No")     public static String fileNameCheck(String file_name) {     // Write your code here     String[] ar = file_name.split("[.]");     String name = ar[0];     String ext = ar[1];     if(name.length() == 0 || name.charAt(0) < 'A' || name.charAt(0) > 'z')     return "No";     int c = 0;     for(int i = 0; i < name.length(); i++)     {         if(name.charAt(i) >= '0' && name.charAt(i) <= '9')         c++;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // triples_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are three distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)9l, (long)7l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean triplesSumToZero(ArrayList<Long> l) {         if(l.size() < 3)             return false;         else {             // First, we need to get a list of the pairs of elements that sum to 0.             // To do this, we'll iterate through the list, and add each pair to a             // new list.             ArrayList<ArrayList<Long>> pairs = new ArrayList<ArrayList<Long>>();             for (int i = 0; i < l.size() - 1; i++) {                 for (int j = i + 1; j < l.size(); j++) {                     if (l.get(i) + l.get(j) == 0L) {                         ArrayList<Long> pair = new ArrayList<Long>();                         pair.add(l.get(i));                         pair.add(l.get(j));                         pairs.add(pair);                     }                 }             }             // Now, iterate through the new list of pairs and ensure that there are no             // duplicates in it.             Set<ArrayList<Long>> uniquePairs = new HashSet<ArrayList<Long>>(pairs);             for (ArrayList<Long> pair: uniquePairs) {                 // For each pair, we'll find every element that isn't part of it, and add                 // them to a new list.                 ArrayList<Long> elements = new ArrayList<Long>();                 for (Long e: l) {                     if (!pair.contains(e)) {                         elements.add(e);                     }                 }                 // Then, we'll iterate through this list and ensure that no element                 // appears more than once.                 Set<Long> uniqueElements = new HashSet<Long>(elements);                 for (Long e: uniqueElements) {                     if (elements.indexOf(e) != elements.lastIndexOf(e)) {                         return true;                     }                 }             }             return false;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given two intervals,     // where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).     // The given intervals are closed which means that the interval (start, end)     // includes both start and end.     // For each given interval, it is assumed that its start is less or equal its end.     // Your task is to determine whether the length of intersection of these two      // intervals is a prime number.     // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)     // which its length is 1, which not a prime number.     // If the length of the intersection is a prime number, return "YES",     // otherwise, return "NO".     // If the two intervals don't intersect, return "NO".     // [input/output] samples:     // >>> intersection((Pair.with(1l, 2l)), (Pair.with(2l, 3l)))     // ("NO")     // >>> intersection((Pair.with(-1l, 1l)), (Pair.with(0l, 4l)))     // ("NO")     // >>> intersection((Pair.with(-3l, -1l)), (Pair.with(-5l, 5l)))     // ("YES")     public static String intersection(Pair<Long, Long> interval1, Pair<Long, Long> interval2) {         long start1 = interval1.getValue0();         long end1 = interval1.getValue1();         long start2 = interval2.getValue0();         long end2 = interval2.getValue1();         long len = (start1 > start2 ? start1 : start2) - (end1 < end2 ? end1 : end2) - 1;         if(len < 0) return "NO";         if(len == 0) return "YES";         if(len == 1) return "NO";         if(isPrime((int)len)) return "YES";         return "NO";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string containing multiple groups of nested parentheses. Your goal is to     // separate those group into separate strings and return the array list of those.     // Separate groups are balanced (each open brace is properly closed) and not nested within each other     // Ignore any spaces in the input string.     // >>> separateParenGroups(("( ) (( )) (( )( ))"))     // (new ArrayList<String>(Arrays.asList((String)"()", (String)"(())", (String)"(()())")))     public static ArrayList<String> separateParenGroups(String paren_string) {     Stack<Character> stack = new Stack<Character>(); 	for(int i=0; i<paren_string.length(); i++){ 	    char c = paren_string.charAt(i); 	    if(c == '('){ 		stack.push(c); 	    }else if(c == ')'){ 		stack.pop(); 	    } 	} 	if(!stack.isEmpty()){ 	    throw new IllegalArgumentException("Invalid parenthesis string: "+paren_string); 	} 	return separateParenGroups(paren_string, 0, paren_string.length(), "");
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // I think we all remember that feeling when the result of some long-awaited     // event is finally known. The feelings and thoughts you have at that moment are     // definitely worth noting down and comparing.     // Your task is to determine if a person correctly guessed the results of a number of matches.     // You are given two array array lists of scores and guesses of equal length, where each index shows a match.      // Return an array array list of the same length denoting how far off each guess was. If they have guessed correctly,     // the value is 0, and if not, the value is the absolute difference between the guess and the score.     // example:     // >>> compare((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)2l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)3l, (long)3l)))     // >>> compare((new ArrayList<Long>(Arrays.asList((long)0l, (long)5l, (long)0l, (long)0l, (long)0l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)1l, (long)0l, (long)0l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l, (long)1l, (long)0l, (long)0l, (long)6l)))     public static ArrayList<Long> compare(ArrayList<Long> game, ArrayList<Long> guess) {         ArrayList<Long> ans = new ArrayList<>();         for (int i = 0; i < game.size(); i++) {             if (game.get(i) == guess.get(i)) {                 ans.add(0L);             } else {                 ans.add(Math.abs(game.get(i) - guess.get(i)));             }         }         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the count of the numbers of n-digit     // positive integers that start or end with 1.     public static long startsOneEnds(long n) {         // Write your code here         int counter = 0;         for (int i = 1; i <= n; i++) {             for (int j = 1; j <= 9; j++) {                 if (j == 1) {                     long temp = (long) Math.pow(10, n - 1);                     counter += temp;                 }                 long start = (long) Math.pow(10, n - 1);                 long end = (long) Math.pow(10, n) - 1;                 long one = (long) Math.pow(10, n - 1);                 if ((i * j >= start) && (i * j <= end)) {                     if (i * j == one) {                         counter += 1;                     }                     counter += 1;                 }             }         }         return counter;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns true if the last character     // of a given string is an alphabetical character and is not     // a part of a word, and false otherwise.     // Note: "word" is a group of characters separated by space.     // Examples:     // >>> checkIfLastCharIsALetter(("apple pie"))     // (false)     // >>> checkIfLastCharIsALetter(("apple pi e"))     // (true)     // >>> checkIfLastCharIsALetter(("apple pi e "))     // (false)     // >>> checkIfLastCharIsALetter((""))     // (false)     public static boolean checkIfLastCharIsALetter(String txt) {         String[] s = txt.split(" ");         if(s.length == 0 || s[s.length - 1].length() == 0) return false;         else {             char a = s[s.length - 1].charAt(s[s.length - 1].length() - 1);             if((a >= 'a' && a <= 'z') || (a >= 'A' && a <= 'Z')) return true;             else return false;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have to write a function which validates a given date string and     // returns true if the date is valid otherwise false.     // The date is valid if all of the following rules are satisfied:     // 1. The date string is not empty.     // 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.     // 3. The months should not be less than 1 or higher than 12.     // 4. The date should be in the format: mm-dd-yyyy     // >>> validDate(("03-11-2000"))     // (true)     // >>> validDate(("15-01-2012"))     // (false)     // >>> validDate(("04-0-2040"))     // (false)     // >>> validDate(("06-04-2020"))     // (true)     // >>> validDate(("06/04/2020"))     // (false)     public static boolean validDate(String date) {         // Write your code here         String[] date_array = date.split("-");         String month = date_array[0];         String day = date_array[1];         String year = date_array[2];         if (day.length() != 2 || month.length() != 2 || year.length() != 4){             return false;         }         int day_num = Integer.parseInt(day);         int month_num = Integer.parseInt(month);         int year_num = Integer.parseInt(year);         if (month_num < 1 || month_num > 12 || day_num < 1 || day_num > 31 || year_num < 1900 || year_num > 2099){             return false;         }         if (day_num > 30 || day_num < 1){             return false;         }         if (day_num > 29 || day_num < 1){             return false;         }         if (day_num > 31 || day_num < 1){             return false;         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function count_nums which takes an array array list of integers and returns     // the number of elements which has a sum of digits > 0.     // If a number is negative, then its first signed digit will be negative:     // e.g. -123 has signed digits -1, 2, and 3.     // >>> countNums((new ArrayList<Long>(Arrays.asList())))     // (0l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)-1l, (long)11l, (long)-11l))))     // (1l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)2l))))     // (3l)     public static long countNums(ArrayList<Long> arr) {         long counter = 0;         for (long num : arr) {             if (num >= 0) {                 if (num == 0) {                     counter++;                     continue;                 }                 long digits = 0;                 long div = num;                 while (div != 0) {                     digits += div % 10;                     div /= 10;                 }                 if (digits > 0)                     counter++;             } else {                 long div = num;                 long digits = 0;                 while (div != 0) {                     digits += Math.abs(div % 10);                     div /= 10;                 }                 if (digits > 0)                     counter++;             }         }         return counter;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns an ordered version of it.     // Ordered version of string, is a string where all words (separated by space)     // are replaced by a new word where all the characters arranged in     // ascending order based on ascii value.     // Note: You should keep the order of words and blank spaces in the sentence.     // For example:     // >>> antiShuffle(("Hi"))     // ("Hi")     // >>> antiShuffle(("hello"))     // ("ehllo")     // >>> antiShuffle(("Hello World!!!"))     // ("Hello !!!Wdlor")     public static String antiShuffle(String s) {         String[] split = s.split(" ");         StringBuilder result = new StringBuilder();         for (String word : split) {             char[] wordArray = word.toCharArray();             Arrays.sort(wordArray);             for (char c : wordArray)                 result.append(c);             result.append(" ");         }         return result.toString().trim();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Checks if given string is a palindrome     // >>> isPalindrome((""))     // (true)     // >>> isPalindrome(("aba"))     // (true)     // >>> isPalindrome(("aaaaa"))     // (true)     // >>> isPalindrome(("zbcd"))     // (false)     public static boolean isPalindrome(String text) {         return text.equals(new StringBuilder(text).reverse().toString());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a word. Your task is to find the closest vowel that stands between      // two consonants from the right side of the word (case sensitive).     // Vowels in the beginning and ending doesn't count. Return empty string if you didn't     // find any vowel met the above condition.      // You may assume that the given string contains English letter only.     // Example:     // >>> getClosestVowel(("yogurt"))     // ("u")     // >>> getClosestVowel(("FULL"))     // ("U")     // >>> getClosestVowel(("quick"))     // ("")     // >>> getClosestVowel(("ab"))     // ("")     public static String getClosestVowel(String word) {         for(int i = word.length() - 1; i > 0; i--) {             char c = word.charAt(i);             if(isVowel(c)) {                 return Character.toString(c);             }         }         return "";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if a given number is prime, and false otherwise.     // >>> isPrime((6l))     // (false)     // >>> isPrime((101l))     // (true)     // >>> isPrime((11l))     // (true)     // >>> isPrime((13441l))     // (true)     // >>> isPrime((61l))     // (true)     // >>> isPrime((4l))     // (false)     // >>> isPrime((1l))     // (false)     public static boolean isPrime(long n) {         if (n < 2l) {             return false;         }         for (long i = 2l; i < n; i++) {             if (n % i == 0l) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to implement a function that will simplify the expression     // x * n. The function returns true if x * n evaluates to a whole number and false     // otherwise. Both x and n, are string representation of a fraction, and have the following format,     // <numerator>/<denominator> where both numerator and denominator are positive whole numbers.     // You can assume that x, and n are valid fractions, and do not have zero as denominator.     // >>> simplify(("1/5"), ("5/1"))     // (true)     // >>> simplify(("1/6"), ("2/1"))     // (false)     // >>> simplify(("7/10"), ("10/2"))     // (false)     public static boolean simplify(String x, String n) {         BigInteger ix = new BigInteger(x.substring(0, x.indexOf('/')));         BigInteger dx = new BigInteger(x.substring(x.indexOf('/') + 1));         BigInteger in = new BigInteger(n.substring(0, n.indexOf('/')));         BigInteger dn = new BigInteger(n.substring(n.indexOf('/') + 1));         BigInteger res = ix.multiply(dn).divide(dx).multiply(in);         BigInteger[] div = res.divideAndRemainder(dn);         return div[1].compareTo(BigInteger.ZERO) == 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have been tasked to write a function that receives      // a hexadecimal number as a string and counts the number of hexadecimal      // digits that are primes (prime number, or a prime, is a natural number      // greater than 1 that is not a product of two smaller natural numbers).     // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.     // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...     // So you have to determine a number of the following digits: 2, 3, 5, 7,      // B (=decimal 11), D (=decimal 13).     // Note: you may assume the input is always correct or empty string,      // and symbols A,B,C,D,E,F are always uppercase.     // Examples:     // >>> hexKey(("AB"))     // (1l)     // >>> hexKey(("1077E"))     // (2l)     // >>> hexKey(("ABED1A33"))     // (4l)     // >>> hexKey(("123456789ABCDEF0"))     // (6l)     // >>> hexKey(("2020"))     // (2l)     public static long hexKey(String num) {         int[] A = {2, 3, 5, 7, 11, 13};         int sum = 0;         for (int i = 0; i < num.length(); i++) {             if (num.charAt(i) >= '0' && num.charAt(i) <= '9') {                 if (A[0] % (num.charAt(i) - '0') == 0 || A[1] % (num.charAt(i) - '0') == 0 || A[2] % (num.charAt(i) - '0') == 0 || A[3] % (num.charAt(i) - '0') == 0 || A[4] % (num.charAt(i) - '0') == 0 || A[5] % (num.charAt(i) - '0') == 0)                     sum++;             } else {                 if (A[0] % (num.charAt(i) - 55) == 0 || A[1] % (num.charAt(i) - 55) == 0 || A[2] % (num.charAt(i) - 55) == 0 || A[3] % (num.charAt(i) - 55) == 0 || A[4] % (num.charAt(i) - 55) == 0 || A[5] % (num.charAt(i) - 55) == 0)                     sum++;             }         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string representing a sentence,     // the sentence contains some words separated by a space,     // and you have to return a string that contains the words from the original sentence,     // whose lengths are prime numbers,     // the order of the words in the new string should be the same as the original one.     // Example 1:     // >>> wordsInSentence(("This is a test"))     // ("is")     // Example 2:     // >>> wordsInSentence(("lets go for swimming"))     // ("go for")     // Constraints:     // * 1 <= len(sentence) <= 100     // * sentence contains only letters     public static String wordsInSentence(String sentence) {         String[] word = sentence.split("\\s");         List<String> output = new ArrayList<String>();         for (String a : word) {             if(isPrime(a.length()))             {                 output.add(a);             }         }         return String.join(" ", output);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string representing a space separated lowercase letters, return a hash map     // of the letter with the most repetition and containing the corresponding count.     // If several letters have the same occurrence, return all of them.     // Example:     // >>> histogram(("a b c"))     // (new HashMap<String,Long>(Map.of("a", 1l, "b", 1l, "c", 1l)))     // >>> histogram(("a b b a"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("a b c a b"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("b b b b a"))     // (new HashMap<String,Long>(Map.of("b", 4l)))     // >>> histogram((""))     // (new HashMap<String,Long>())     public static HashMap<String,Long> histogram(String test) {         HashMap<String,Long> map = new HashMap<>();         int len = test.length();         for(int i = 0; i < len; i++) {             char c = test.charAt(i);             if(map.containsKey(c + "")) map.put(c+"", map.get(c + "") + 1);             else map.put(c+"", 1l);         }         return map;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a 2 dimensional data, as a nested array lists,     // which is similar to matrix, however, unlike matrices,     // each row may contain a different number of columns.     // Given lst, and integer x, find integers x in the array list,     // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that     // each pair is a coordinate - (row, columns), starting with 0.     // Sort coordinates initially by rows in ascending order.     // Also, sort coordinates of the row by columns in descending order.     // Examples:     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList()))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))     public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {         ArrayList<Pair<Long, Long>> result = new ArrayList<>();         for (int i = 0; i < lst.size(); i++) {             for (int j = lst.get(i).size() - 1; j >= 0; j--) {                 if (lst.get(i).get(j) == x) {                     result.add(Pair.with((long)i, (long)j));                 }             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a sorted array list that has the odd numbers in collatz sequence.     // The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined     // as follows: start with any positive integer n. Then each term is obtained from the      // previous term as follows: if the previous term is even, the next term is one half of      // the previous term. If the previous term is odd, the next term is 3 times the previous     // term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.     // Note:      // 1. Collatz(1) is [1].     // 2. returned array list sorted in increasing order.     // For example:     // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.     // >>> getOddCollatz((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l)))     public static ArrayList<Long> getOddCollatz(long n) {         ArrayList<Long> result = new ArrayList<Long>();         while (n != 1l) {             result.add(n);             if ((n & 1) == 1) {                 n = (n * 3l) + 1l;             } else {                 n /= 2l;             }         }         result.add(n);         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which returns the largest index of an element which     // is not greater than or equal to the element immediately preceding it. If     // no such element exists then return -1. The given array array list will not contain     // duplicate values.     // Examples:     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)3l, (long)5l))))     // (3l)     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (-1l)     public static long canArrange(ArrayList<Long> arr) {         for(int i = arr.size() - 1; i >= 0; i--){             long l = arr.get(i);             if(arr.get(i) < arr.get(i - 1)){                 return i;             }         }         return -1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input is a space-delimited string of numberals from 'zero' to 'nine'.     // Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.     // Return the string with numbers sorted from smallest to largest     // >>> sortNumbers(("three one five"))     // ("one three five")     public static String sortNumbers(String numbers) {         return "";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Circular shift the digits of the integer x, shift the digits right by shift     // and return the result as a string.     // If shift > number of digits, return digits reversed.     // >>> circularShift((12l), (1l))     // ("21")     // >>> circularShift((12l), (2l))     // ("12")     public static String circularShift(long x, long shift) {         final int digits = (int)Math.log10(x);         final int reversedShift = (int)(Math.pow(10, digits) - shift);         if(shift > digits) {             return circularShift(x, reversedShift);         }         return Long.toString(x / Math.pow(10, shift) + x % Math.pow(10, shift) * Math.pow(10, digits - shift));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "     // This function will take an array array list of integers. For all entries in the array list, the function shall square the integer entry if its index is a      // multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not      // change the entries in the array list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.      // Examples:     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList())     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)-1l, (long)-5l, (long)2l, (long)-1l, (long)-5l))     public static long sumSquares(ArrayList<Long> lst) {         long sum = 0;         for (int i = 0; i < lst.size(); i++) {             if (i % 3 == 0)                 lst.set(i, lst.get(i) * lst.get(i));             if (i % 4 == 0 && i % 3 != 0)                 lst.set(i, lst.get(i) * lst.get(i) * lst.get(i));             sum += lst.get(i);         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // You need to find the largest prime value and return the sum of its digits.     // Examples:     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)3l, (long)2l, (long)1l, (long)3l, (long)5l, (long)7l, (long)4l, (long)5l, (long)5l, (long)5l, (long)2l, (long)181l, (long)32l, (long)4l, (long)32l, (long)3l, (long)2l, (long)32l, (long)324l, (long)4l, (long)3l))))     // (10l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)1l, (long)8l, (long)2l, (long)4597l, (long)2l, (long)1l, (long)3l, (long)40l, (long)1l, (long)2l, (long)1l, (long)2l, (long)4l, (long)2l, (long)5l, (long)1l))))     // (25l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)1l, (long)32l, (long)5107l, (long)34l, (long)83278l, (long)109l, (long)163l, (long)23l, (long)2323l, (long)32l, (long)30l, (long)1l, (long)9l, (long)3l))))     // (13l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)724l, (long)32l, (long)71l, (long)99l, (long)32l, (long)6l, (long)0l, (long)5l, (long)91l, (long)83l, (long)0l, (long)5l, (long)6l))))     // (11l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)81l, (long)12l, (long)3l, (long)1l, (long)21l))))     // (3l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)8l, (long)1l, (long)2l, (long)1l, (long)7l))))     // (7l)     public static long skjkasdkd(ArrayList<Long> lst) {         long sum = 0;         int index = 0;         int length = lst.size();         for (int i = 0; i < length; i++) {             long l = lst.get(i);             if (isPrime(l)) {                 index = i;                 break;             }         }         for (int i = index; i < length; i++) {             long l = lst.get(i);             sum += (l % 10);         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of integers, return a pair consisting of a sum and a product of all the integers in an array array list.     // Empty sum should be equal to 0 and empty product should be equal to 1.     // >>> sumProduct((new ArrayList<Long>(Arrays.asList())))     // (Pair.with(0l, 1l))     // >>> sumProduct((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (Pair.with(10l, 24l))     public static Pair<Long, Long> sumProduct(ArrayList<Long> numbers) {         long product = 1;         long sum = 0;         for(long number : numbers) {             sum += number;             product *= number;         }         return Pair.with(sum, product);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes two positive numbers x and y and returns the     // biggest even integer number that is in the range [x, y] inclusive. If      // there's no such number, then the function should return -1.     // For example:     // >>> chooseNum((12l), (15l))     // (14l)     // >>> chooseNum((13l), (12l))     // (-1l)     public static long chooseNum(long x, long y) {         long result = 0;         for (long i = x; i <= y; i++) {             if (i % 2 == 0) {                 result = i;             }         }         if (result != 0) {             return result;         }         return -1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns a pair (a, b), where 'a' is     // the largest of negative integers, and 'b' is the smallest     // of positive integers in an array array list.     // If there is no negative or positive integers, return them as null.     // Examples:     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l, (long)7l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(1l))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList())))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     public static Pair<Optional<Long>, Optional<Long>> largestSmallestIntegers(ArrayList<Long> lst) {         long max = lst.stream().filter(l -> l < 0).max(Comparator.naturalOrder()).orElse(null);         long min = lst.stream().filter(l -> l > 0).min(Comparator.naturalOrder()).orElse(null);         return Pair.with(Optional.of(Optional.ofNullable(max)), Optional.of(Optional.ofNullable(min)));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string, find out how many distinct characters (regardless of case) does it consist of     // >>> countDistinctCharacters(("xyzXYZ"))     // (3l)     // >>> countDistinctCharacters(("Jerry"))     // (4l)     public static long countDistinctCharacters(String string) {         HashSet<Character> distinctCharacters = new HashSet<>();         for (char c : string.toLowerCase().toCharArray()) {             distinctCharacters.add(c);         }         return distinctCharacters.size();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, you have to make a pile of n levels of stones.     // The first level has n stones.     // The number of stones in the next level is:     // - the next odd number if n is odd.     // - the next even number if n is even.     // Return the number of stones in each level in an array array list, where element at index     // i represents the number of stones in the level (i+1).     // Examples:     // >>> makeAPile((3l))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)7l)))     public static ArrayList<Long> makeAPile(long n) {         ArrayList<Long> pile = new ArrayList<Long>();         for(int i = 0; i < n; i++) {             if(i == 0) pile.add(n);             else {                 if(pile.get(i-1) % 2 == 0) pile.add(pile.get(i-1) + 1);                 else pile.add(pile.get(i-1) + 2);             }         }         return pile;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list arr of integers and you need to return     // sum of magnitudes of integers multiplied by product of all signs     // of each number in the array array list, represented by 1, -1 or 0.     // Note: return null for empty arr.     // Example:     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)-4l))))     // Optional.of(9l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l))))     // Optional.of(0l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     public static Optional<Long> prodSigns(ArrayList<Long> arr) {         if (arr.size() == 0) {             return Optional.empty();         }         long prod = 1;         long sum = 0;         for (int i = 0; i < arr.size(); i++) {             long num = arr.get(i);             prod *= Math.signum(num);             sum += Math.abs(num);         }         return Optional.of(prod * sum);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers nums, find the minimum sum of any non-empty sub-array array list     // of nums.     // Example     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l, (long)1l, (long)2l, (long)4l))))     // (1l)     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l))))     // (-6l)     public static long minSubArraySum(ArrayList<Long> nums) {         // Write your code here         long min = Long.MAX_VALUE;         int start = 0, end = 0;         while(end < nums.size()){             long sum = 0;             for(int i = start; i <= end; i++)                 sum += nums.get(i);             if(sum < min){                 min = sum;             }             end++;         }         return min;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a string containing space-delimited numbers starting from 0 upto n inclusive.     // >>> stringSequence((0l))     // ("0")     // >>> stringSequence((5l))     // ("0 1 2 3 4 5")     public static String stringSequence(long n) {         return IntStream.rangeClosed(0, (int) n).mapToObj(Integer::toString).collect(Collectors.joining(" ", "", ""));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word     // >>> cycpatternCheck(("abcd"), ("abd"))     // (false)     // >>> cycpatternCheck(("hello"), ("ell"))     // (true)     // >>> cycpatternCheck(("whassup"), ("psus"))     // (false)     // >>> cycpatternCheck(("abab"), ("baa"))     // (true)     // >>> cycpatternCheck(("efef"), ("eeff"))     // (false)     // >>> cycpatternCheck(("himenss"), ("simen"))     // (true)     public static boolean cycpatternCheck(String a, String b) {         int aLen = a.length();         int bLen = b.length();         if (aLen == 0 || bLen == 0) {             return false;         }         int[][] mat = new int[aLen][aLen];         for (int i = 0; i < aLen; i++) {             for (int j = 0; j < aLen; j++) {                 if (i == j) {                     mat[i][j] = 0;                 } else {                     mat[i][j] = -1;                 }             }         }         for (int i = 0; i < aLen; i++) {             for (int j = i + 1; j < aLen; j++) {                 if (a.charAt(i) == a.charAt(j)) {                     mat[i][j] = 0;                 } else {                     int min = Math.min(i, j);                     int max = Math.max(i, j);                     for (int k = min; k < max; k++) {                         if (a.charAt(k) == a.charAt(i)) {                             mat[i][j] = mat[k][j] + 1;                             break;                         } else if (a.charAt(k) == a.charAt(j)) {                             mat[i][j] = mat[i][k] + 1;                             break;                         }                     }                 }             }         }         int[][] rotMat = new int[bLen][bLen];         for (int i = 0; i < bLen; i++) {             for (int j = 0; j < bLen; j++) {                 if (i == j) {                     rotMat[i][j] = 0;                 } else {                     rotMat[i][j] = -1;                 }             }         }         for (int i = 0; i < bLen; i++) {             for (int j = i + 1; j < bLen; j++) {                 if (b.charAt(i) == b.charAt(j)) {                     rotMat[i][j] = 0;                 } else {                     int min = Math.min(i, j);                     int max = Math.max(i, j);                     for (int k = min; k < max; k++) {                         if (b.charAt(k) == b.charAt(i)) {                             rotMat[i][j] = rotMat[k][j] + 1;                             break;                         } else if (b.charAt(k) == b.charAt(j)) {                             rotMat[i][j] = rotMat[i][k] + 1;                             break;                         }                     }                 }             }         }         int[][] finalMat = new int[bLen][bLen];         for (int i = 0; i < bLen; i++) {             for (int j = 0; j < bLen; j++) {                 finalMat[i][j] = Math.max
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true is array list elements are monotonically increasing or decreasing.     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)20l))))     // (true)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))))     // (false)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)0l, (long)-10l))))     // (true)     public static boolean monotonic(ArrayList<Long> l) {         if (l.size() <= 1) return true;         boolean isIncreasing = l.get(0) < l.get(1);         for (int i = 1; i < l.size() - 1; i++) {             if (isIncreasing) {                 if (l.get(i) < l.get(i + 1)) {                     continue;                 } else {                     isIncreasing = false;                     if (l.get(i) > l.get(i + 1)) {                         return false;                     }                 }             } else {                 if (l.get(i) > l.get(i + 1)) {                     continue;                 } else {                     isIncreasing = true;                     if (l.get(i) < l.get(i + 1)) {                         return false;                     }                 }             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Out of array list of strings, return the longest one. Return the first one in case of multiple     // strings of the same length. Return null in case the input array list is empty.     // >>> longest((new ArrayList<String>(Arrays.asList())))     // Optional.empty()     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // Optional.of("a")     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"bb", (String)"ccc"))))     // Optional.of("ccc")     public static Optional<String> longest(ArrayList<String> strings) {         return strings.stream().max(Comparator.comparing(String::length));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if all numbers in the array list l are below threshold t.     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)10l))), (100l))     // (true)     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))), (5l))     // (false)     public static boolean belowThreshold(ArrayList<Long> l, long t) {         for (long value : l) {             if (value > t) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the given number is the multiplication of 3 prime numbers     // and false otherwise.     // Knowing that (a) is less then 100.      // Example:     // >>> isMultiplyPrime((30l))     // (true)     // 30 = 2 * 3 * 5     public static boolean isMultiplyPrime(long a) {         // write your code here         for(int i = 2; i < a; i++){             if(a%i==0 && isPrime(i))                  return true;         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return only positive numbers in the array list.     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)-1l, (long)2l, (long)-4l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)6l)))     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)3l, (long)9l, (long)123l, (long)1l)))     public static ArrayList<Long> getPositive(ArrayList<Long> l) {         ArrayList<Long> positive = new ArrayList<Long>();         for (long e : l) {             if (e > 0) positive.add(e);         }         return positive;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal     // to the values of the corresponding indicies of l, but sorted.     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)5l)))     public static ArrayList<Long> sortThird(ArrayList<Long> l) {         ArrayList<Long> sorted = new ArrayList<Long>(l.stream().sorted().collect(Collectors.toList()));         ArrayList<Long> out = new ArrayList<Long>();         for(int i = 0; i < l.size(); i++) {             if(i % 3 == 0) {                 out.add(sorted.get(i / 3));             } else {                 out.add(l.get(i));             }         }         return out;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.     // For each of the group, output the deepest level of nesting of parentheses.     // E.g. (()()) has maximum two levels of nesting while ((())) has three.     // >>> parseNestedParens(("(()()) ((())) () ((())()())"))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))     public static ArrayList<Long> parseNestedParens(String paren_string) {         ArrayList<String> split_paren_string = new ArrayList<>(Arrays.asList(paren_string.split(" ")));         ArrayList<Long> max_nesting_levels = new ArrayList<>();         for (int i = 0; i < split_paren_string.size(); i++) {             max_nesting_levels.add(getMaxNestingLevel(split_paren_string.get(i)));         }         return max_nesting_levels;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given length of a side and high return area for a triangle.     // >>> triangleArea((5l), (3l))     // (7.5f)     public static float triangleArea(long a, long h) {         return (a * h / 2f);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Complete the function that takes two integers and returns      // the product of their unit digits.     // Assume the input is always valid.     // Examples:     // >>> multiply((148l), (412l))     // (16l)     // >>> multiply((19l), (28l))     // (72l)     // >>> multiply((2020l), (1851l))     // (0l)     // >>> multiply((14l), (-15l))     // (20l)     public static long multiply(long a, long b) {         int sum = 1;         while (a > 0 || b > 0) {             sum *= (a % 10) * (b % 10);             a /= 10;             b /= 10;         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of input numbers, calculate Mean Absolute Deviation     // around the mean of this dataset.     // Mean Absolute Deviation is the average absolute difference between each     // element and a centerpoint (mean in this case):     // MAD = average | x - x_mean |     // >>> meanAbsoluteDeviation((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f))))     // (1.0f)     public static float meanAbsoluteDeviation(ArrayList<Float> numbers) {         float mean = 0.0f;         float mad = 0.0f;         for (Float i : numbers) {             mean += i;         }         mean /= (float)numbers.size();         for (Float i : numbers) {             mad += Math.abs(i - mean);         }         return mad / (float)numbers.size();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique common elements for two array lists.     // >>> common((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l, (long)34l, (long)653l, (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)1l, (long)5l, (long)9l, (long)653l, (long)121l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)653l)))     // >>> common((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     public static ArrayList<Long> common(ArrayList<Long> l1, ArrayList<Long> l2) {         ArrayList<Long> uniqueCommonElements = new ArrayList<Long>();         for (int i = 0; i < l1.size(); i++) {             if (l2.contains(l1.get(i)) && !uniqueCommonElements.contains(l1.get(i))) {                 uniqueCommonElements.add(l1.get(i));             }         }         return uniqueCommonElements.stream().sorted().collect(Collectors.toCollection(ArrayList<Long>::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer, obtain its roman numeral equivalent as a string,     // and return it in lowercase.     // Restrictions: 1 <= num <= 1000     // Examples:     // >>> intToMiniRoman((19l))     // ("xix")     // >>> intToMiniRoman((152l))     // ("clii")     // >>> intToMiniRoman((426l))     // ("cdxxvi")     public static String intToMiniRoman(long number) {         if (number <= 0) {             return "";         }         StringBuilder sb = new StringBuilder();         if (number >= 1000) {             int times = (int)(number / 1000);             sb.append("m".repeat(times));             number %= 1000;         }         if (number >= 900) {             sb.append("cm");             number -= 900;         } else if (number >= 500) {             sb.append("d");             number -= 500;         } else if (number >= 400) {             sb.append("cd");             number -= 400;         }         if (number >= 100) {             int times = (int)(number / 100);             sb.append("c".repeat(times));             number %= 100;         }         if (number >= 90) {             sb.append("xc");             number -= 90;         } else if (number >= 50) {             sb.append("l");             number -= 50;         } else if (number >= 40) {             sb.append("xl");             number -= 40;         }         if (number >= 10) {             int times = (int)(number / 10);             sb.append("x".repeat(times));             number %= 10;         }         if (number >= 9) {             sb.append("ix");             number -= 9;         } else if (number >= 5) {             sb.append("v");             number -= 5;         } else if (number >= 4) {             sb.append("iv");             number -= 4;         }         if (number >= 1) {             int times = (int)(number / 1);             sb.append("i".repeat(times));             number %= 1;         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this task, you will be given a string that represents a number of apples and oranges      // that are distributed in a basket of fruit this basket contains      // apples, oranges, and mango fruits. Given the string that represents the total number of      // the oranges and apples and an integer that represent the total number of the fruits      // in the basket return the number of the mango fruits in the basket.     // for examble:     // >>> fruitDistribution(("5 apples and 6 oranges"), (19l))     // (8l)     // >>> fruitDistribution(("0 apples and 1 oranges"), (3l))     // (2l)     // >>> fruitDistribution(("2 apples and 3 oranges"), (100l))     // (95l)     // >>> fruitDistribution(("100 apples and 1 oranges"), (120l))     // (19l)     public static long fruitDistribution(String s, long n) {         // write your code here         String[] arr = s.split(" ");         long apples = Long.parseLong(arr[0]);         long oranges = Long.parseLong(arr[2]);         return n - apples - oranges;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c     // then check if the result string is palindrome.     // A string is called palindrome if it reads the same backward as forward.     // You should return a pair containing the result string and true/false for the check.     // Example     // >>> reverseDelete(("abcde"), ("ae"))     // (Pair.with("bcd", false))     // >>> reverseDelete(("abcdef"), ("b"))     // (Pair.with("acdef", false))     // >>> reverseDelete(("abcdedcba"), ("ab"))     // (Pair.with("cdedc", true))     public static Pair<String, Boolean> reverseDelete(String s, String c) {         char[] charArray = s.toCharArray();         StringBuilder sb = new StringBuilder();         for (int i = 0; i < s.length(); i++) {             char ch = charArray[i];             if (!c.contains(String.valueOf(ch))) {                 sb.append(ch);             }         }         if (sb.toString().equals(sb.reverse().toString())) {             return new Pair(sb.toString(), true);         }         return new Pair(sb.toString(), false);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a greatest common divisor of two integers a and b     // >>> greatestCommonDivisor((3l), (5l))     // (1l)     // >>> greatestCommonDivisor((25l), (15l))     // (5l)     public static long greatestCommonDivisor(long a, long b) {         if (b == 0) return a;         else return greatestCommonDivisor(b, a % b);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this Kata, you have to sort an array array list of non-negative integers according to     // number of ones in their binary representation in ascending order.     // For similar number of ones, sort based on decimal value.     // It must be implemented like this:     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)-2l, (long)-3l, (long)-4l, (long)-5l, (long)-6l))))     // (new ArrayList<Long>(Arrays.asList((long)-6l, (long)-5l, (long)-4l, (long)-3l, (long)-2l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l)))     public static ArrayList<Long> sortArray(ArrayList<Long> arr) {         return arr.stream().sorted((a,b) -> Integer.valueOf(Integer.toBinaryString(a.intValue()).replace("0b","").replace("0","").length())                 .compareTo(Integer.valueOf(Integer.toBinaryString(b.intValue()).replace("0b","").replace("0","").length()))).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Concatenate array list of strings into a single string     // >>> concatenate((new ArrayList<String>(Arrays.asList())))     // ("")     // >>> concatenate((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // ("abc")     public static String concatenate(ArrayList<String> strings) {         String s = "";         for (String str : strings)             s += str;         return s;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings as a parameter,     // deletes the strings that have odd lengths from it,     // and returns the resulted array list with a sorted order,     // The array list is always an array array list of strings and never an array array list of numbers,     // and it may contain duplicates.     // The order of the array list should be ascending by length of each word, and you     // should return the array list sorted by that rule.     // If two words have the same length, sort the array list alphabetically.     // The function should return an array array list of strings in sorted order.     // You may assume that all words will have the same length.     // For example:     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"aa", (String)"a", (String)"aaa"))))     // (new ArrayList<String>(Arrays.asList((String)"aa")))     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"ab", (String)"a", (String)"aaa", (String)"cd"))))     // (new ArrayList<String>(Arrays.asList((String)"ab", (String)"cd")))     public static ArrayList<String> sortedListSum(ArrayList<String> lst) {         ArrayList<String> arrayList = new ArrayList<String>();         for (String s: lst) {             if (s.length() % 2 == 0) {                 arrayList.add(s);             }         }         arrayList.sort(new Comparator<String>() {             @Override             public int compare(String o1, String o2) {                 int length = o1.length() - o2.length();                 if (length == 0) {                     return o1.compareTo(o2);                 }                 return length;             }         });         return arrayList;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that contain given substring     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"array")))     public static ArrayList<String> filterBySubstring(ArrayList<String> strings, String substring) {         return strings.stream().filter(string -> string.contains(substring)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a value (string) representing a number     // and returns the closest integer to it. If the number is equidistant     // from two integers, round it away from zero.     // Examples     // >>> closestInteger(("10"))     // (10l)     // >>> closestInteger(("15.3"))     // (15l)     // Note:     // Rounding away from zero means that if the given number is equidistant     // from two integers, the one you should return is the one that is the     // farthest from zero. For example closest_integer("14.5") should     // return 15 and closest_integer("-14.5") should return -15.     public static long closestInteger(String value) {         return Double.valueOf(value).longValue();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function vowels_count which takes a string representing     // a word as input and returns the number of vowels in the string.     // Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a     // vowel, but only when it is at the end of the given word.     // Example:     // >>> vowelsCount(("abcde"))     // (2l)     // >>> vowelsCount(("ACEDY"))     // (3l)     public static long vowelsCount(String s) {         long count = 0;         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == 'a' || s.charAt(i) == 'e' || s.charAt(i) == 'i' || s.charAt(i) == 'o' || s.charAt(i) == 'u') count++;             else if (s.charAt(i) == 'y' && i == s.length() - 1) count++;         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings.     // The array list contains different words. Return the word with maximum number     // of unique characters. If multiple strings have maximum number of unique     // characters, return the one which comes first in lexicographical order.     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"of", (String)"string"))))     // ("string")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"enam", (String)"game"))))     // ("enam")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"aaaaaaa", (String)"bb", (String)"cc"))))     // ("aaaaaaa")     public static String findMax(ArrayList<String> words) {         String max = "";         for (String word : words) {             String thisWord = word;             Set<Character> characters = new HashSet<Character>();             while (thisWord.length() > 0) {                 characters.add(thisWord.charAt(0));                 thisWord = thisWord.substring(1);             }             if (characters.size() > max.length()) {                 max = word;             } else if (characters.size() == max.length()) {                 if (word.compareTo(max) < 0) {                     max = word;                 }             }         }         return max;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string 'text', return its md5 hash equivalent string.     // If 'text' is an empty string, return null.     // >>> stringToMd5(("Hello world"))     // Optional.of("3e25960a79dbc69b674cd4ec67a72c62")     public static Optional<String> stringToMd5(String text) {         return Optional.ofNullable(text).map(s -> s.isEmpty() ? null : String.valueOf(MessageDigest.getInstance("MD5").digest(s.getBytes())));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Change numerical base of input number x to base.     // return string representation after the conversion.     // base numbers are less than 10.     // >>> changeBase((8l), (3l))     // ("22")     // >>> changeBase((8l), (2l))     // ("1000")     // >>> changeBase((7l), (2l))     // ("111")     public static String changeBase(long x, long base) {         if (base < 1 || base > 10) {             throw new IllegalArgumentException("invalid base");         }         if (x < 0) {             throw new IllegalArgumentException("negative number");         }         String str = "";         while (x != 0) {             long r = x % base;             str = r + str;             x = x / base;         }         return str;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return true if the three     // sides form a right-angled triangle, false otherwise.     // A right-angled triangle is a triangle in which one angle is right angle or      // 90 degree.     // Example:     // >>> rightAngleTriangle((3l), (4l), (5l))     // (true)     // >>> rightAngleTriangle((1l), (2l), (3l))     // (false)     public static boolean rightAngleTriangle(long a, long b, long c) {         return a*a + b*b == c*c || a*a + c*c == b*b || b*b + c*c == a*a;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // It is the last week of the semester and the teacher has to give the grades     // to students. The teacher has been making her own algorithm for grading.     // The only problem is, she has lost the code she used for grading.     // She has given you an array array list of GPAs for some students and you have to write      // a function that can output an array array list of letter grades using the following table:     // GPA       |    Letter grade     // 4.0                A+     // > 3.7                A      // > 3.3                A-      // > 3.0                B+     // > 2.7                B      // > 2.3                B-     // > 2.0                C+     // > 1.7                C     // > 1.3                C-     // > 1.0                D+      // > 0.7                D      // > 0.0                D-     // 0.0                E     // Example:     // >>> gradeEquation((new ArrayList<Float>(Arrays.asList((float)4.0f, (float)3l, (float)1.7f, (float)2l, (float)3.5f))))     // (new ArrayList<String>(Arrays.asList((String)"A+", (String)"B", (String)"C-", (String)"C", (String)"A-")))     public static ArrayList<String> numericalLetterGrade(ArrayList<Float> grades) {         ArrayList<String> output = new ArrayList<String>();         for (Float grade : grades) {             if (grade > 4)                 output.add("A+");             else if (grade > 3.7)                 output.add("A");             else if (grade > 3.3)                 output.add("A-");             else if (grade > 3)                 output.add("B+");             else if (grade > 2.7)                 output.add("B");             else if (grade > 2.3)                 output.add("B-");             else if (grade > 2)                 output.add("C+");             else if (grade > 1.7)                 output.add("C");             else if (grade > 1.3)                 output.add("C-");             else if (grade > 1)                 output.add("D+");             else if (grade > 0.7)                 output.add("D");             else if (grade > 0)                 output.add("D-");             else                 output.add("E");         }         return output;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Insert a number 'delimeter' between every two consecutive elements of input array list `numbers'     // >>> intersperse((new ArrayList<Long>(Arrays.asList())), (4l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> intersperse((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))), (4l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)4l, (long)3l)))     public static ArrayList<Long> intersperse(ArrayList<Long> numbers, long delimeter) {         ArrayList<Long> ans = new ArrayList<Long>();         if (numbers.size() == 0) {             return ans;         } else if (numbers.size() == 1) {             ans.add(numbers.get(0));             return ans;         } else if (numbers.size() == 2) {             ans.add(numbers.get(0));             ans.add(numbers.get(1));             return ans;         }         ArrayList<Long> temp = intersperse(numbers.subList(0, numbers.size()-1), delimeter);         ans.addAll(temp);         ans.add(delimeter);         ans.add(numbers.get(numbers.size()-1));         return ans;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an array array list of numbers as input and returns      // the number of elements in the array array list that are greater than 10 and both      // first and last digits of a number are odd (1, 3, 5, 7, 9).     // For example:     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)15l, (long)-73l, (long)14l, (long)-15l))))     // (1l)     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)33l, (long)-2l, (long)-3l, (long)45l, (long)21l, (long)109l))))     // (2l)     public static long specialFilter(ArrayList<Long> nums) {         int cnt = 0;         for(long x : nums) {             if(x > 10L && (x % 10) % 2 == 1 && x / 10 % 2 == 1) cnt++;         }         return cnt;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // sum_to_n is a function that sums numbers from 1 to n.     // >>> sumToN((30l))     // (465l)     // >>> sumToN((100l))     // (5050l)     // >>> sumToN((5l))     // (15l)     // >>> sumToN((10l))     // (55l)     // >>> sumToN((1l))     // (1l)     public static long sumToN(long n) {         long res = 0l;         for (long i = 1l; i <= n; i = i + 1l) {             res = res + i;         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From an array array list of integers, remove all elements that occur more than once.     // Keep order of elements left the same as in the input.     // >>> removeDuplicates((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)4l)))     public static ArrayList<Long> removeDuplicates(ArrayList<Long> numbers) {         return numbers.stream().filter(new HashSet<Long>()::add).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two positive integers a and b, return the even digits between a     // and b, in ascending order.     // For example:     // >>> generateIntegers((2l), (8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((8l), (2l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((10l), (14l))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> generateIntegers(long a, long b) {         ArrayList<Long> list = new ArrayList<Long>();         for (long i = a; i <= b; i++) {             String s = i + "";             String d = "";             for (int j = 0; j < s.length(); j++) {                 if (s.charAt(j) % 2 == 0) {                     d += s.charAt(j);                 }             }             if (!d.equals("")) {                 list.add(Long.parseLong(d));             }         }         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a given array list of integers, generate an array array list of rolling maximum element found until given moment     // in the sequence.     // >>> rollingMax((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)3l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l)))     public static ArrayList<Long> rollingMax(ArrayList<Long> numbers) {         ArrayList<Long> rollingMax = new ArrayList<Long>(numbers.size());         for(int i = 0; i < numbers.size(); i++) {             rollingMax.add((long)1);         }         for(int i = 1; i < numbers.size(); i++) {             rollingMax.set(i, numbers.get(i));             for(int j = i; j >= 0; j--) {                 if(rollingMax.get(j) < numbers.get(i)) {                     rollingMax.set(j, numbers.get(i));                 }             }         }         return rollingMax;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're given an array array list of deposit and withdrawal operations on a bank account that starts with     // zero balance. Your task is to detect if at any point the balance of account fallls below zero, and     // at that point function should return true. Otherwise it should return false.     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (false)     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)-4l, (long)5l))))     // (true)     public static boolean belowZero(ArrayList<Long> operations) {         if(operations.size() == 0) return false;         long balance = 0;         for (Long op : operations){             if(op > 0)                 balance += op;             else{                 if(balance + op < 0)                     return true;                 else                     balance += op;             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a non-empty array list of positive integers. Return the greatest integer that is greater than      // zero, and has a frequency greater than or equal to the value of the integer itself.      // The frequency of an integer is the number of times it appears in the array list.     // If no such a value exist, return -1.     // Examples:     // >>> search((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)2l, (long)2l, (long)3l, (long)1l))))     // (2l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l, (long)4l))))     // (3l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)4l, (long)4l, (long)4l))))     // (-1l)     public static long search(ArrayList<Long> lst) {         if(lst.size() == 1) return -1;         Long[] arr = lst.toArray(new Long[0]);         int freq = 0;         int num = 0;         for(int i = 0; i < arr.length; i++) {             int temp = 0;             for(int j = 0; j < arr.length; j++) {                 if(arr[i] == arr[j]) temp += 1;             }             if(arr[i] != 0 && arr[i] > temp) {                 freq = temp;                 num = arr[i];             }         }         return freq >= num ? num : -1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "(" and ")".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("("))     // (false)     // >>> correctBracketing(("()"))     // (true)     // >>> correctBracketing(("(()())"))     // (true)     // >>> correctBracketing((")(()"))     // (false)     public static boolean correctBracketing(String brackets) {         LinkedList<Character> ll = new LinkedList<Character>();         for (char c : brackets.toCharArray()) {             if (c == '(') {                 ll.addLast(c);             } else if (c == ')') {                 if (ll.size() > 0 && ll.getLast() == '(') {                     ll.removeLast();                 } else {                     return false;                 }             }         }         return ll.size() == 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the odd indicies, while its values at the even indicies are equal     // to the values of the even indicies of l, but sorted.     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)6l, (long)5l, (long)4l)))     public static ArrayList<Long> sortEven(ArrayList<Long> l) {         ArrayList<Long> list = new ArrayList<>();         for(int i = 0; i < l.size(); i++) {             if(i % 2 == 0) {                 list.add(l.get(i));             }         }         ArrayList<Long> list1 = new ArrayList<>();         for(int i = 0; i < list.size(); i++) {             list1.add(list.get(i));         }         ArrayList<Long> list2 = new ArrayList<>();         for(int i = 0; i < list1.size(); i++) {             for(int j = 0; j < list1.size(); j++) {                 if(list1.get(i) > list1.get(j)) {                     list2.add(list1.get(j));                     list1.remove(j);                     list1.add(list1.get(j));                     j = 0;                 }             }         }         for(int i = 0; i < list2.size(); i++) {             list.add(list2.get(i));         }         return list;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if two words have the same characters.     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddeddabc"))     // (true)     // >>> sameChars(("abcd"), ("dddddddabc"))     // (true)     // >>> sameChars(("dddddddabc"), ("abcd"))     // (true)     // >>> sameChars(("eabcd"), ("dddddddabc"))     // (false)     // >>> sameChars(("abcd"), ("dddddddabce"))     // (false)     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddddabc"))     // (false)     public static boolean sameChars(String s0, String s1) {         // return s0.chars().distinct().sorted().toString().equals(s1.chars().distinct().sorted().toString());         return new HashSet(s0.chars().distinct().sorted().toArray()).equals(new HashSet(s1.chars().distinct().sorted().toArray()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "<" and ">".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("<"))     // (false)     // >>> correctBracketing(("<>"))     // (true)     // >>> correctBracketing(("<<><>>"))     // (true)     // >>> correctBracketing(("><<>"))     // (false)     public static boolean correctBracketing(String brackets) {         Stack<Character> stack = new Stack<>();         for(int i = 0; i < brackets.length(); i++) {             char c = brackets.charAt(i);             if(c == '>') {                 if(stack.isEmpty()) return false;                 if(stack.pop() != '<') return false;             } else {                 stack.push(c);             }         }         return stack.isEmpty();
