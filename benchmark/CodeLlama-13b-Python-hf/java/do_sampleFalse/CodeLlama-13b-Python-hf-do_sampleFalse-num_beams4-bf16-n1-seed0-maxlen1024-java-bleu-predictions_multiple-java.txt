import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return length of given string     // >>> stringLength((""))     // (0l)     // >>> stringLength(("abc"))     // (3l)     public static long strlen(String string) {         return string.length();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function encrypt that takes a string as an argument and     // returns a string encrypted with the alphabet being rotated.      // The alphabet should be rotated in a manner such that the letters      // shift down by two multiplied to two places.     // For example:     // >>> encrypt(("hi"))     // ("lm")     // >>> encrypt(("asdfghjkl"))     // ("ewhjklnop")     // >>> encrypt(("gf"))     // ("kj")     // >>> encrypt(("et"))     // ("ix")     public static String encrypt(String s) {         char[] chars = s.toCharArray();         for (int i = 0; i < chars.length; i++) {             if (chars[i] >= 'a' && chars[i] <= 'z') {                 chars[i] += 2;                 if (chars[i] > 'z') {                     chars[i] -= 26;                 }             } else if (chars[i] >= 'A' && chars[i] <= 'Z') {                 chars[i] += 2;                 if (chars[i] > 'Z') {                     chars[i] -= 26;                 }             }         }         return new String(chars);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a hash map, return true if all keys are strings in lower      // case or all keys are strings in upper case, else return false.     // The function should return false is the given hash map is empty.     // Examples:     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "b", "banana"))))     // (true)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", "A", "banana", "B", "banana"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("a", "apple", 8l, "banana", "a", "apple"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("Name", "John", "Age", "36", "City", "Houston"))))     // (false)     // >>> checkDictCase((new HashMap<String,String>(Map.of("STATE", "NC", "ZIP", "12345"))))     // (true)     public static boolean checkDictCase(HashMap<String,String> dict) {         if (dict.size() == 0) {             return false;         }         boolean isUpper = true;         boolean isLower = true;         for (String key : dict.keySet()) {             if (Character.isUpperCase(key.charAt(0))) {                 isLower = false;             } else if (Character.isLowerCase(key.charAt(0))) {                 isUpper = false;             } else {                 return false;             }         }         return isUpper || isLower;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers lst. add the even elements that are at odd indices..     // Examples:     // >>> add((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)6l, (long)7l))))     // (2l)     public static long add(ArrayList<Long> lst) {         long sum = 0;         for (int i = 1; i < lst.size(); i += 2) {             sum += lst.get(i);         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string text, replace all spaces in it with underscores,      // and if a string has more than 2 consecutive spaces,      // then replace all consecutive spaces with -      // >>> fixSpaces((" Example"))     // ("Example")     // >>> fixSpaces((" Example 1"))     // ("Example_1")     // >>> fixSpaces((" Example 2"))     // ("_Example_2")     // >>> fixSpaces((" Example 3"))     // ("_Example-3")     public static String fixSpaces(String text) {         StringBuilder sb = new StringBuilder();         int count = 0;         for (int i = 0; i < text.length(); i++) {             if (text.charAt(i) == ' ') {                 count++;             } else {                 if (count == 0) {                     sb.append(text.charAt(i));                 } else if (count == 1) {                     sb.append('_');                     sb.append(text.charAt(i));                 } else {                     sb.append('-');                     sb.append(text.charAt(i));                 }                 count = 0;             }         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fibfib(0) == 0     // fibfib(1) == 0     // fibfib(2) == 1     // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).     // Please write a function to efficiently compute the n-th element of the fibfib number sequence.     // >>> fibfib((1l))     // (0l)     // >>> fibfib((5l))     // (4l)     // >>> fibfib((8l))     // (24l)     public static long fibfib(long n) {         if (n == 0) {             return 0;         }         if (n == 1) {             return 0;         }         if (n == 2) {             return 1;         }         return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return the sum of squares of the numbers     // in the array list that are odd. Ignore numbers that are negative or not integers.     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)0l))))     // (10l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)-1l, (long)-2l, (long)0l))))     // (0l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)9l, (long)-2l))))     // (81l)     // >>> doubleTheDifference((new ArrayList<Float>(Arrays.asList((long)0l))))     // (0l)     // If the input array list is empty, return 0.     public static long doubleTheDifference(ArrayList<Float> lst) {         long sum = 0;         for (int i = 0; i < lst.size(); i++) {             if (Math.floor(lst.get(i)) == lst.get(i) && lst.get(i) % 2 != 0) {                 sum += lst.get(i) * lst.get(i);             }         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter given array list of any javathon values only for integers     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList((String)"a", (String)3.14f, (String)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> filterIntegers((new ArrayList<Object>(Arrays.asList(1l, 2l, 3l, "abc", new HashMap<Long,Long>(Map.of()), new ArrayList<Long>(Arrays.asList())))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     public static ArrayList<Long> filterIntegers(ArrayList<Object> values) {         ArrayList<Long> result = new ArrayList<Long>();         for (Object value : values) {             if (value instanceof Integer || value instanceof Long || value instanceof Short || value instanceof Byte) {                 result.add((Long) value);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Imagine a road that's a perfectly straight infinitely long line.     // n cars are driving left to right;  simultaneously, a different set of n cars     // are driving right to left.   The two sets of cars start out being very far from     // each other.  All cars move in the same speed.  Two cars are said to collide     // when a car that's moving left to right hits a car that's moving right to left.     // However, the cars are infinitely sturdy and strong; as a result, they continue moving     // in their trajectory as if they did not collide.     // This function outputs the number of such collisions.     public static long carRaceCollision(long n) {         return n * (n - 1) / 2;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string representing musical notes in a special ASCII format.     // Your task is to parse this string and return array list of integers corresponding to how many beats does each     // not last.     // Here is a legend:     // 'o' - whole note, lasts four beats     // 'o|' - half note, lasts two beats     // '.|' - quater note, lasts one beat     // >>> parseMusic(("o o| .| o| o| .| .| .| .| o o"))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)1l, (long)2l, (long)2l, (long)1l, (long)1l, (long)1l, (long)1l, (long)4l, (long)4l)))     public static ArrayList<Long> parseMusic(String music_string) {         ArrayList<Long> beats = new ArrayList<Long>();         for (int i = 0; i < music_string.length(); i++) {             if (music_string.charAt(i) == 'o') {                 beats.add((long) 4);             } else if (music_string.charAt(i) == 'o' && music_string.charAt(i + 1) == '|') {                 beats.add((long) 2);                 i++;             } else if (music_string.charAt(i) == '.' && music_string.charAt(i + 1) == '|') {                 beats.add((long) 1);                 i++;             }         }         return beats;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a number in decimal form and your task is to convert it to     // binary format. The function should return a string, with each character representing a binary     // number. Each character in the string will be '0' or '1'.     // There will be an extra couple of characters 'db' at the beginning and at the end of the string.     // The extra characters are there to help with the format.     // Examples:     // >>> decimalToBinary((15l))     // ("db1111db")     // >>> decimalToBinary((32l))     // ("db100000db")     public static String decimalToBinary(long decimal) {         return "db" + Long.toBinaryString(decimal) + "db";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of all prefixes from shortest to longest of the input string     // >>> allPrefixes(("abc"))     // (new ArrayList<String>(Arrays.asList((String)"a", (String)"ab", (String)"abc")))     public static ArrayList<String> allPrefixes(String string) {         ArrayList<String> prefixes = new ArrayList<String>();         for (int i = 0; i <= string.length() - 1; i++) {             prefixes.add(string.substring(0, i + 1));         }         return prefixes;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Add two numbers x and y     // >>> add((2l), (3l))     // (5l)     // >>> add((5l), (7l))     // (12l)     public static long add(long x, long y) {         return x + y;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're a hungry rabbit, and you already have eaten a certain number of carrots,     // but now you need to eat more carrots to complete the day's meals.     // you should return an array array list of [ total number of eaten carrots after your meals,     // the number of carrots left after your meals ]     // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.     // Example:     // >>> eat((5l), (6l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)4l)))     // >>> eat((4l), (8l), (9l))     // (new ArrayList<Long>(Arrays.asList((long)12l, (long)1l)))     // >>> eat((1l), (10l), (10l))     // (new ArrayList<Long>(Arrays.asList((long)11l, (long)0l)))     // >>> eat((2l), (11l), (5l))     // (new ArrayList<Long>(Arrays.asList((long)7l, (long)0l)))     // Variables:     // @number : integer     // the number of carrots that you have eaten.     // @need : integer     // the number of carrots that you need to eat.     // @remaining : integer     // the number of remaining carrots thet exist in stock     // Constrain:     // * 0 <= number <= 1000     // * 0 <= need <= 1000     // * 0 <= remaining <= 1000     // Have fun :)     public static ArrayList<Long> eat(long number, long need, long remaining) {         ArrayList<Long> result = new ArrayList<Long>();         result.add(number + Math.min(need, remaining));         result.add(Math.max(0l, remaining - need));         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a rectangular grid of wells. Each row represents a single well,     // and each 1 in a row represents a single unit of water.     // Each well has a corresponding bucket that can be used to extract water from it,      // and all buckets have the same capacity.     // Your task is to use the buckets to empty the wells.     // Output the number of times you need to lower the buckets.     // Example 1:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l))))), (1l))     // (6l)     // Example 2:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)1l, (long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)1l, (long)1l))))), (2l))     // (5l)     // Example 3:     // >>> maxFill((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l))))), (5l))     // (0l)     // Constraints:     // * all wells have the same length     // * 1 <= grid.length <= 10^2     // * 1 <= grid[:,1].length <= 10^2     // * grid[i][j] -> 0 | 1     // * 1 <= capacity <= 10     public static long maxFill(ArrayList<ArrayList<Long>> grid, long capacity) {         return 0l;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two array lists operator, and operand. The first array list has basic algebra operations, and      // the second array list is an array array list of integers. Use the two given array lists to build the algebric      // expression and return the evaluation of this expression.     // The basic algebra operations:     // Addition ( + )      // Subtraction ( - )      // Multiplication ( * )      // Floor division ( // )      // Exponentiation ( ** )      // Example:     // operator['+', '*', '-']     // array array list = [2, 3, 4, 5]     // result = 2 + 3 * 4 - 5     // => result = 9     // Note:     // The length of operator array list is equal to the length of operand array list minus one.     // Operand is an array array list of of non-negative integers.     // Operator array list has at least one operator, and operand array list has at least two operands.     public static long doAlgebra(ArrayList<String> op, ArrayList<Long> operand) {         long result = operand.get(0);         for (int i = 0; i < op.size(); i++) {             if (op.get(i).equals("+")) {                 result += operand.get(i + 1);             } else if (op.get(i).equals("-")) {                 result -= operand.get(i + 1);             } else if (op.get(i).equals("*")) {                 result *= operand.get(i + 1);             } else if (op.get(i).equals("//")) {                 result /= operand.get(i + 1);             } else if (op.get(i).equals("**")) {                 result = (long) Math.pow(result, operand.get(i + 1));             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given string, flip lowercase characters to uppercase and uppercase to lowercase.     // >>> flipCase(("Hello"))     // ("hELLO")     public static String flipCase(String string) {         char[] chars = string.toCharArray();         for (int i = 0; i < chars.length; i++) {             if (Character.isUpperCase(chars[i])) {                 chars[i] = Character.toLowerCase(chars[i]);             } else if (Character.isLowerCase(chars[i])) {                 chars[i] = Character.toUpperCase(chars[i]);             }         }         return new String(chars);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers, sort the integers that are between 1 and 9 inclusive,     // reverse the resulting array array list, and then replace each digit by its corresponding name from     // "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".     // For example:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)2l, (long)1l, (long)1l, (long)4l, (long)5l, (long)8l, (long)2l, (long)3l))))     // (new ArrayList<String>(Arrays.asList((String)"Eight", (String)"Five", (String)"Four", (String)"Three", (String)"Two", (String)"Two", (String)"One", (String)"One")))     // If the array array list is empty, return an empty array array list:     // >>> byLength((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // If the array array list has any strange number ignore it:     // >>> byLength((new ArrayList<Long>(Arrays.asList((long)1l, (long)-1l, (long)55l))))     // (new ArrayList<String>(Arrays.asList((String)"One")))     public static ArrayList<String> byLength(ArrayList<Long> arr) {         ArrayList<String> result = new ArrayList<String>();         for (int i = 0; i < arr.size(); i++) {             if (arr.get(i) > 0 && arr.get(i) < 10) {                 switch (arr.get(i).intValue()) {                     case 1:                         result.add("One");                         break;                     case 2:                         result.add("Two");                         break;                     case 3:                         result.add("Three");                         break;                     case 4:                         result.add("Four");                         break;                     case 5:                         result.add("Five");                         break;                     case 6:                         result.add("Six");                         break;                     case 7:                         result.add("Seven");                         break;                     case 8:                         result.add("Eight");                         break;                     case 9:                         result.add("Nine");                         break;                     default:                         break;                 }             }         }         Collections.reverse(result);         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list of prime factors of given integer in the order from smallest to largest.     // Each of the factors should be array listed number of times corresponding to how many times it appeares in factorization.     // Input number should be equal to the product of all factors     // >>> factorize((8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)2l, (long)2l)))     // >>> factorize((25l))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l)))     // >>> factorize((70l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)7l)))     public static ArrayList<Long> factorize(long n) {         ArrayList<Long> factors = new ArrayList<Long>();         for (long i = 2; i <= Math.sqrt(n); i++) {             if (n % i == 0) {                 factors.add(i);                 n /= i;                 i--;             }         }         if (n != 1) {             factors.add(n);         }         return factors;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement a function that takes an non-negative integer and returns an array array list of the first n     // integers that are prime numbers and less than n.     // for example:     // >>> countUpTo((5l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     // >>> countUpTo((11l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l)))     // >>> countUpTo((0l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((20l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l, (long)19l)))     // >>> countUpTo((1l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> countUpTo((18l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)5l, (long)7l, (long)11l, (long)13l, (long)17l)))     public static ArrayList<Long> countUpTo(long n) {         ArrayList<Long> primes = new ArrayList<Long>();         for (long i = 2; i < n; i++) {             if (isPrime(i)) {                 primes.add(i);             }         }         return primes;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique elements in an array array list     // >>> unique((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)2l, (long)3l, (long)5l, (long)9l, (long)123l)))     public static ArrayList<Long> unique(ArrayList<Long> l) {         return new ArrayList<Long>(new LinkedHashSet<Long>(l));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts two array lists of strings and returns the array list that has      // total number of chars in the all strings of the array list less than the other array list.     // if the two array lists have the same number of chars, return the first array list.     // Examples     // >>> totalMatch((new ArrayList<String>(Arrays.asList())), (new ArrayList<String>(Arrays.asList())))     // (new ArrayList<String>(Arrays.asList()))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"Hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hi", (String)"hi", (String)"admin", (String)"project"))))     // (new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"hi", (String)"admin"))), (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi"))))     // (new ArrayList<String>(Arrays.asList((String)"hI", (String)"hi", (String)"hi")))     // >>> totalMatch((new ArrayList<String>(Arrays.asList((String)"4"))), (new ArrayList<String>(Arrays.asList((String)"1", (String)"2", (String)"3", (String)"4", (String)"5"))))     // (new ArrayList<String>(Arrays.asList((String)"4")))     public static ArrayList<String> totalMatch(ArrayList<String> lst1, ArrayList<String> lst2) {         int sum1 = lst1.stream().mapToInt(s -> s.length()).sum();         int sum2 = lst2.stream().mapToInt(s -> s.length()).sum();         if (sum1 < sum2) {             return lst1;         } else if (sum1 > sum2) {             return lst2;         } else {             return lst1;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return maximum element in the array list.     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (3l)     // >>> maxElement((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (123l)     public static long maxElement(ArrayList<Long> l) {         long max = l.get(0);         for (int i = 1; i < l.size(); i++) {             if (l.get(i) > max) {                 max = l.get(i);             }         }         return max;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a string as input which contains only square brackets.     // The function should return true if and only if there is a valid subsequence of brackets      // where at least one bracket in the subsequence is nested.     // >>> isNested(("[[]]"))     // (true)     // >>> isNested(("[]]]]]]][[[[[]"))     // (false)     // >>> isNested(("[][]"))     // (false)     // >>> isNested(("[]"))     // (false)     // >>> isNested(("[[][]]"))     // (true)     // >>> isNested(("[[]][["))     // (true)     public static boolean isNested(String string) {         int count = 0;         for (int i = 0; i < string.length(); i++) {             if (string.charAt(i) == '[') {                 count++;             } else if (string.charAt(i) == ']') {                 count--;             }             if (count < 0) {                 return false;             }         }         return count == 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of strings, where each string consists of only digits, return an array array list.     // Each element i of the output should be "the number of odd elements in the     // string i of the input." where all the i's should be replaced by the number     // of odd digits in the i'th string of the input.     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"1234567"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 4n the str4ng 4 of the 4nput.")))     // >>> oddCount((new ArrayList<String>(Arrays.asList((String)"3", (String)"11111111"))))     // (new ArrayList<String>(Arrays.asList((String)"the number of odd elements 1n the str1ng 1 of the 1nput.", (String)"the number of odd elements 8n the str8ng 8 of the 8nput.")))     public static ArrayList<String> oddCount(ArrayList<String> lst) {         ArrayList<String> result = new ArrayList<String>();         for (int i = 0; i < lst.size(); i++) {             int count = 0;             for (int j = 0; j < lst.get(i).length(); j++) {                 if (lst.get(i).charAt(j) % 2 != 0) {                     count++;                 }             }             result.add("the number of odd elements " + count + "n the str" + count + "ng " + count + " of the " + count + "nput.");         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // We have an array array list 'arr' of N integers arr[1], arr[2], ..., arr[N].The     // numbers in the array array list will be randomly ordered. Your task is to determine if     // it is possible to get an array array list sorted in non-decreasing order by performing      // the following operation on the given array array list:     // You are allowed to perform right shift operation any number of times.     // One right shift operation means shifting all elements of the array array list by one     // position in the right direction. The last element of the array array list will be moved to     // the starting position in the array array list i.e. 0th index.      // If it is possible to obtain the sorted array array list by performing the above operation     // then return true else return false.     // If the given array array list is empty then return true.     // Note: The given array list is guaranteed to have unique elements.     // For Example:     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)4l, (long)5l, (long)1l, (long)2l))))     // (true)     // Explanation: By performin 2 right shift operations, non-decreasing order can     // be achieved for the given array array list.     // >>> moveOneBall((new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)4l, (long)1l, (long)2l))))     // (false)     // Explanation:It is not possible to get non-decreasing order for the given     // array array list by performing any number of right shift operations.     public static boolean moveOneBall(ArrayList<Long> arr) {         if (arr.size() == 0) {             return true;         }         for (int i = 0; i < arr.size() - 1; i++) {             if (arr.get(i) > arr.get(i + 1)) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a pair that has the number of even and odd     // integer palindromes that fall within the range(1, n), inclusive.     // Example 1:     // >>> evenOddPalindrome((3l))     // (Pair.with(1l, 2l))     // Explanation:     // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.     // Example 2:     // >>> evenOddPalindrome((12l))     // (Pair.with(4l, 6l))     // Explanation:     // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.     // Note:     // 1. 1 <= n <= 10^3     // 2. returned pair has the number of even and odd integer palindromes respectively.     public static Pair<Long, Long> evenOddPalindrome(long n) {         long even = 0;         long odd = 0;         for (long i = 1; i <= n; i++) {             if (isPalindrome(i)) {                 if (i % 2 == 0) {                     even++;                 } else {                     odd++;                 }             }         }         return new Pair<Long, Long>(even, odd);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers     // Example     // >>> isEqualToSumEven((4l))     // (false)     // >>> isEqualToSumEven((6l))     // (false)     // >>> isEqualToSumEven((8l))     // (true)     public static boolean isEqualToSumEven(long n) {         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // xs represent coefficients of a polynomial.     // xs[0] + xs[1] * x + xs[2] * x^2 + ....     // Return derivative of this polynomial in the same form.     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)12l, (long)20l)))     // >>> derivative((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l)))     public static ArrayList<Long> derivative(ArrayList<Long> xs) {         ArrayList<Long> result = new ArrayList<Long>();         for (int i = 1; i < xs.size(); i++) {             result.add(xs.get(i) * (long)i);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of numbers, return whether or not they are sorted     // in ascending order. If array list has more than 1 duplicate of the same     // number, return false. Assume no negative numbers and only integers.     // Examples     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)7l))))     // (false)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)4l))))     // (true)     // >>> isSorted((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)2l, (long)3l, (long)4l))))     // (false)     public static boolean isSorted(ArrayList<Long> lst) {         for (int i = 0; i < lst.size() - 1; i++) {             if (lst.get(i) > lst.get(i + 1)) {                 return false;             }             if (lst.get(i) == lst.get(i + 1)) {                 for (int j = i + 1; j < lst.size() - 1; j++) {                     if (lst.get(j) != lst.get(j + 1)) {                         return true;                     }                 }                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // if s[i] is a letter, reverse its case from lower to upper or vise versa,      // otherwise keep it as it is.     // If the string contains no letters, reverse the string.     // The function should return the resulted string.     // Examples     // >>> solve(("1234"))     // ("4321")     // >>> solve(("ab"))     // ("AB")     // >>> solve(("#a@C"))     // ("#A@c")     public static String solve(String s) {         boolean hasLetter = false;         StringBuilder sb = new StringBuilder();         for (int i = 0; i < s.length(); i++) {             char c = s.charAt(i);             if (Character.isLetter(c)) {                 hasLetter = true;                 if (Character.isUpperCase(c)) {                     sb.append(Character.toLowerCase(c));                 } else {                     sb.append(Character.toUpperCase(c));                 }             } else {                 sb.append(c);             }         }         return hasLetter ? sb.toString() : new StringBuilder(s).reverse().toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in      // the last couple centuries. However, what people don't know is Tribonacci sequence.     // Tribonacci sequence is defined by the recurrence:     // tri(1) = 3     // tri(n) = 1 + n / 2, if n is even.     // tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.     // For example:     // tri(2) = 1 + (2 / 2) = 2     // tri(4) = 3     // tri(3) = tri(2) + tri(1) + tri(4)     // = 2 + 3 + 3 = 8      // You are given a non-negative integer number n, you have to a return an array array list of the      // first n + 1 numbers of the Tribonacci sequence.     // Examples:     // >>> tri((3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)2l, (long)8l)))     public static ArrayList<Long> tri(long n) {         ArrayList<Long> result = new ArrayList<Long>();         result.add(1l);         result.add(3l);         result.add(2l);         for (long i = 3; i <= n; i++) {             if (i % 2 == 0) {                 result.add(1 + i / 2);             } else {                 result.add(result.get((int) (i - 1)) + result.get((int) (i - 2)) + result.get((int) (i + 1)));             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.     // >>> fizzBuzz((50l))     // (0l)     // >>> fizzBuzz((78l))     // (2l)     // >>> fizzBuzz((79l))     // (3l)     public static long fizzBuzz(long n) {         long count = 0;         for (long i = 0; i < n; i++) {             if (i % 11 == 0 || i % 13 == 0) {                 String s = Long.toString(i);                 for (int j = 0; j < s.length(); j++) {                     if (s.charAt(j) == '7') {                         count++;                     }                 }             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that start with a given prefix.     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterByPrefix((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bcd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"array")))     public static ArrayList<String> filterByPrefix(ArrayList<String> strings, String prefix) {         ArrayList<String> result = new ArrayList<String>();         for (String s : strings) {             if (s.startsWith(prefix)) {                 result.add(s);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer N, return the total sum of its digits in binary.     // Example     // >>> solve((1000l))     // ("1")     // >>> solve((150l))     // ("110")     // >>> solve((147l))     // ("1100")     // Variables:     // @N integer     // Constraints: 0 ≤ N ≤ 10000.     // Output:     // a string of binary number     public static String solve(long N) {         String binary = Long.toBinaryString(N);         int sum = 0;         for (int i = 0; i < binary.length(); i++) {             if (binary.charAt(i) == '1') {                 sum += 1;             }         }         return String.valueOf(sum);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a grid with N rows and N columns (N >= 2) and a positive integer k,      // each cell of the grid contains a value. Every integer in the range [1, N * N]     // inclusive appears exactly once on the cells of the grid.     // You have to find the minimum path of length k in the grid. You can start     // from any cell, and in each step you can move to any of the neighbor cells,     // in other words, you can go to cells which share an edge with you current     // cell.     // Please note that a path of length k means visiting exactly k cells (not     // necessarily distinct).     // You CANNOT go off the grid.     // A path A (of length k) is considered less than a path B (of length k) if     // after making the ordered array lists of the values on the cells that A and B go     // through (let's call them lst_A and lst_B), lst_A is lexicographically less     // than lst_B, in other words, there exist an integer index i (1 <= i <= k)     // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have     // lst_A[j] = lst_B[j].     // It is guaranteed that the answer is unique.     // Return an ordered array list of the values on the cells that the minimum path go through.     // Examples:         // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)9l))))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)1l)))     // >>> minPath((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)5l, (long)9l, (long)3l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)7l, (long)8l, (long)2l))))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)1l)))     public static ArrayList<Long> minPath(ArrayList<ArrayList<Long>> grid, long k) {         return null;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s, count the number of uppercase vowels in even indices.     // For example:     // >>> countUpper(("aBCdEf"))     // (1l)     // >>> countUpper(("abcdefg"))     // (0l)     // >>> countUpper(("dBBE"))     // (0l)     public static long countUpper(String s) {         long count = 0;         for (int i = 0; i < s.length(); i += 2) {             if (Character.isUpperCase(s.charAt(i)) && "AEIOU".indexOf(s.charAt(i)) >= 0) {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers and a positive integer k, return a sorted array list      // of length k with the maximum k numbers in arr.     // Example 1:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)-4l, (long)5l))), (3l))     // (new ArrayList<Long>(Arrays.asList((long)-4l, (long)-3l, (long)5l)))     // Example 2:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)4l, (long)-4l, (long)4l))), (2l))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l)))     // Example 3:     // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l, (long)2l, (long)1l, (long)2l, (long)-1l, (long)-2l, (long)1l))), (1l))     // (new ArrayList<Long>(Arrays.asList((long)2l)))     // Note:     // 1. The length of the array array list will be in the range of [1, 1000].     // 2. The elements in the array array list will be in the range of [-1000, 1000].     // 3. 0 <= k <= len(arr)     public static ArrayList<Long> maximum(ArrayList<Long> arr, long k) {         return new ArrayList<Long>(arr.stream().sorted(Collections.reverseOrder()).limit(k).collect(Collectors.toList()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given number n, find the largest number that divides n evenly, smaller than n     // >>> largestDivisor((15l))     // (5l)     public static long largestDivisor(long n) {         for (long i = (long) Math.sqrt(n); i >= 1; i--) {             if (n % i == 0) {                 return i;             }         }         return 1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of non-negative integers, return a cojava of the given array array list after sorting,     // you will sort the given array array list in ascending order if the sum( first index value, last index value) is odd,     // or sort it in descending order if the sum( first index value, last index value) is even.     // Note:     // * don't change the given array array list.     // Examples:     // >>> sortArray((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)3l, (long)0l, (long)1l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)5l, (long)4l, (long)3l, (long)2l, (long)1l, (long)0l)))     public static ArrayList<Long> sortArray(ArrayList<Long> array) {         if (array.size() == 0 || array.size() == 1) {             return array;         }         int sum = 0;         for (int i = 0; i < array.size() - 1; i++) {             sum += array.get(i);         }         sum += array.get(array.size() - 1);         if (sum % 2 == 0) {             array.sort(Collections.reverseOrder());         } else {             array.sort(null);         }         return array;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Implement the function f that takes n as a parameter,     // and returns an array array list of size n, such that the value of the element at index i is the factorial of i if i is even     // or the sum of numbers from 1 to i otherwise.     // i starts from 1.     // the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).     // Example:     // >>> f((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)6l, (long)24l, (long)15l)))     public static ArrayList<Long> f(long n) {         ArrayList<Long> result = new ArrayList<Long>();         for (long i = 1; i <= n; i++) {             if (i % 2 == 0) {                 result.add(i);             } else {                 long sum = 0;                 for (long j = 1; j <= i; j++) {                     sum += j;                 }                 result.add(sum);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an integer a and returns true      // if this ingeger is a cube of some integer number.     // Note: you may assume the input is always valid.     // Examples:     // >>> iscube((1l))     // (true)     // >>> iscube((2l))     // (false)     // >>> iscube((-1l))     // (true)     // >>> iscube((64l))     // (true)     // >>> iscube((0l))     // (true)     // >>> iscube((180l))     // (false)     public static boolean iscube(long a) {         return Math.pow(Math.round(Math.cbrt(a)), 3) == a;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a message, and encodes in such a      // way that it swaps case of all letters, replaces all vowels in      // the message with the letter that appears 2 places ahead of that      // vowel in the english alphabet.      // Assume only letters.      // Examples:     // >>> encode(("test"))     // ("TGST")     // >>> encode(("This is a message"))     // ("tHKS KS C MGSSCGG")     public static String encode(String message) {         char[] chars = message.toCharArray();         for (int i = 0; i < chars.length; i++) {             if (Character.isLetter(chars[i])) {                 if (Character.isLowerCase(chars[i])) {                     chars[i] = (char) (chars[i] - 32);                 } else {                     chars[i] = (char) (chars[i] + 32);                 }                 if (chars[i] == 'a') {                     chars[i] = 'c';                 } else if (chars[i] == 'e') {                     chars[i] = 'g';                 } else if (chars[i] == 'i') {                     chars[i] = 'k';                 } else if (chars[i] == 'o') {                     chars[i] = 'q';                 } else if (chars[i] == 'u') {                     chars[i] = 'x';                 } else if (chars[i] == 'A') {                     chars[i] = 'C';                 } else if (chars[i] == 'E') {                     chars[i] = 'G';                 } else if (chars[i] == 'I') {                     chars[i] = 'K';                 } else if (chars[i] == 'O') {                     chars[i] = 'Q';                 } else if (chars[i] == 'U') {                     chars[i] = 'X';                 }             }         }         return new String(chars);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You'll be given a string of words, and your task is to count the number     // of boredoms. A boredom is a sentence that starts with the word "I".     // Sentences are delimited by '.', '?' or '!'.     // For example:     // >>> isBored(("Hello world"))     // (0l)     // >>> isBored(("The sky is blue. The sun is shining. I love this weather"))     // (1l)     public static long isBored(String S) {         String[] sentences = S.split("[.?!]");         long count = 0;         for (String sentence : sentences) {             String[] words = sentence.split(" ");             for (String word : words) {                 if (word.equals("I")) {                     count++;                     break;                 }             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // pairs_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are two distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)5l, (long)7l))))     // (true)     // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean pairsSumToZero(ArrayList<Long> l) {         if (l.size() < 2) {             return false;         }         Set<Long> s = new HashSet<Long>();         for (int i = 0; i < l.size(); i++) {             s.add(l.get(i));         }         for (int i = 0; i < l.size(); i++) {             if (s.contains(-1 * l.get(i))) {                 return true;             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return the area of     // the triangle rounded to 2 decimal points if the three sides form a valid triangle.      // Otherwise return -1     // Three sides make a valid triangle when the sum of any two sides is greater      // than the third side.     // Example:     // >>> triangleArea((3l), (4l), (5l))     // (6.0f)     // >>> triangleArea((1l), (2l), (10l))     // (float)-1l     public static float triangleArea(long a, long b, long c) {         if (a + b <= c || a + c <= b || b + c <= a) {             return -1f;         }         double s = (a + b + c) / 2;         return (float) Math.round(Math.sqrt(s * (s - a) * (s - b) * (s - c)) * 100) / 100;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // There are eight planets in our solar system: the closerst to the Sun      // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,      // Uranus, Neptune.     // Write a function that takes two planet names as strings planet1 and planet2.      // The function should return a pair containing all planets whose orbits are      // located between the orbit of planet1 and the orbit of planet2, sorted by      // the proximity to the sun.      // The function should return an empty pair if planet1 or planet2     // are not correct planet names.      // Examples     // >>> bf(("Jupiter"), ("Neptune"))     // (new ArrayList<String>(Arrays.asList((String)"Saturn", (String)"Uranus")))     // >>> bf(("Earth"), ("Mercury"))     // (ArrayList<String>("Venus"))     // >>> bf(("Mercury"), ("Uranus"))     // (new ArrayList<String>(Arrays.asList((String)"Venus", (String)"Earth", (String)"Mars", (String)"Jupiter", (String)"Saturn")))     public static ArrayList<String> bf(String planet1, String planet2) {         ArrayList<String> planets = new ArrayList<String>(Arrays.asList("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"));         if (!planets.contains(planet1) || !planets.contains(planet2)) {             return new ArrayList<String>();         }         int planet1Index = planets.indexOf(planet1);         int planet2Index = planets.indexOf(planet2);         if (planet1Index > planet2Index) {             int temp = planet1Index;             planet1Index = planet2Index;             planet2Index = temp;         }         ArrayList<String> result = new ArrayList<String>();         for (int i = planet1Index + 1; i < planet2Index; i++) {             result.add(planets.get(i));         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the product of the odd digits.     // Return 0 if all digits are even.     // For example:     // >>> digits((1l))     // (1l)     // >>> digits((4l))     // (0l)     // >>> digits((235l))     // (15l)     public static long digits(long n) {         long product = 1;         while (n > 0) {             if (n % 2 != 0) {                 product *= n % 10;             }             n /= 10;         }         return product;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given a string of words separated by commas or spaces. Your task is     // to split the string into words and return an array array list of the words.     // For example:     // >>> wordsString(("Hi, my name is John"))     // (new ArrayList<String>(Arrays.asList((String)"Hi", (String)"my", (String)"name", (String)"is", (String)"John")))     // >>> wordsString(("One, two, three, four, five, six"))     // (new ArrayList<String>(Arrays.asList((String)"One", (String)"two", (String)"three", (String)"four", (String)"five", (String)"six")))     public static ArrayList<String> wordsString(String s) {         return new ArrayList<String>(Arrays.asList(s.split("[, ]+")));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find how many times a given substring can be found in the original string. Count overlaping cases.     // >>> howManyTimes((""), ("a"))     // (0l)     // >>> howManyTimes(("aaa"), ("a"))     // (3l)     // >>> howManyTimes(("aaaa"), ("aa"))     // (3l)     public static long howManyTimes(String string, String substring) {         long count = 0;         for (int i = 0; i < string.length() - substring.length() + 1; i++) {             if (string.substring(i, i + substring.length()).equals(substring)) {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // remove_vowels is a function that takes string and returns string without vowels.     // >>> removeVowels((""))     // ("")     // >>> removeVowels(("abcdef"))     // ("bcdf")     // >>> removeVowels(("aaaaa"))     // ("")     // >>> removeVowels(("aaBAA"))     // ("B")     // >>> removeVowels(("zbcd"))     // ("zbcd")     public static String removeVowels(String text) {         return text.replaceAll("[aeiouAEIOU]", "");
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of integers, return array list in strange order.     // Strange sorting, is when you start with the minimum value,     // then maximum of the remaining integers, then minimum and so on.     // Examples:     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)3l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l)))     // >>> strangeSortList((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> strangeSortList(ArrayList<Long> lst) {         if (lst.size() == 0) {             return lst;         }         ArrayList<Long> res = new ArrayList<Long>();         res.add(Collections.min(lst));         while (lst.size() > 1) {             lst.remove(Collections.min(lst));             res.add(Collections.max(lst));             lst.remove(Collections.max(lst));             res.add(Collections.min(lst));         }         res.add(Collections.max(lst));         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a supplied array list of numbers (of length at least two) select and return two that are the closest to each     // other and return them in order (smaller number, larger number).     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f))))     // (Pair.with(2.0f, 2.2f))     // >>> findClosestElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))))     // (Pair.with(2.0f, 2.0f))     public static Pair<Float, Float> findClosestElements(ArrayList<Float> numbers) {         if (numbers.size() < 2) {             return null;         }         Pair<Float, Float> closestPair = new Pair<Float, Float>(numbers.get(0), numbers.get(1));         for (int i = 0; i < numbers.size() - 1; i++) {             for (int j = i + 1; j < numbers.size(); j++) {                 Pair<Float, Float> currentPair = new Pair<Float, Float>(numbers.get(i), numbers.get(j));                 if (Math.abs(currentPair.getValue0() - currentPair.getValue1()) < Math.abs(closestPair.getValue0() - closestPair.getValue1())) {                     closestPair = currentPair;                 }             }         }         return closestPair;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to write a function that returns true if a number x is a simple     // power of n and false in other cases.     // x is a simple power of n if n**int=x     // For example:     // >>> isSimplePower((1l), (4l))     // (true)     // >>> isSimplePower((2l), (2l))     // (true)     // >>> isSimplePower((8l), (2l))     // (true)     // >>> isSimplePower((3l), (2l))     // (false)     // >>> isSimplePower((3l), (1l))     // (false)     // >>> isSimplePower((5l), (3l))     // (false)     public static boolean isSimplePower(long x, long n) {         return BigInteger.valueOf(n).pow(BigInteger.valueOf(x).divide(BigInteger.valueOf(n)).intValueExact()).equals(BigInteger.valueOf(x));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // prime_fib returns n-th number that is a Fibonacci number and it's also prime.     // >>> primeFib((1l))     // (2l)     // >>> primeFib((2l))     // (3l)     // >>> primeFib((3l))     // (5l)     // >>> primeFib((4l))     // (13l)     // >>> primeFib((5l))     // (89l)     public static long primeFib(long n) {         if (n == 1l) {             return 2l;         } else if (n == 2l) {             return 3l;         } else if (n == 3l) {             return 5l;         } else if (n == 4l) {             return 13l;         } else if (n == 5l) {             return 89l;         } else if (n == 6l) {             return 233l;         } else if (n == 7l) {             return 377l;         } else if (n == 8l) {             return 610l;         } else if (n == 9l) {             return 987l;         } else if (n == 10l) {             return 1597l;         } else if (n == 11l) {             return 2584l;         } else if (n == 12l) {             return 4181l;         } else if (n == 13l) {             return 6765l;         } else if (n == 14l) {             return 10946l;         } else if (n == 15l) {             return 17711l;         } else if (n == 16l) {             return 28657l;         } else if (n == 17l) {             return 46368l;         } else if (n == 18l) {             return 75025l;         } else if (n == 19l) {             return 121393l;         } else if (n == 20l) {             return 196418l;         } else if (n == 21l) {             return 317811l;         } else if (n == 22l) {             return 514229l;         } else if (n == 23l) {             return 832040l;         } else if (n == 24l) {             return 1346269l;         } else if (n == 25l) {             return 2178309l;         } else if (n == 26l) {             return 3524578l;         } else if (n == 27l) {             return 5702887l;         } else if (n == 28l) {             return 9227465l;         } else if (n == 29l) {             return 14930352l;         } else if (n == 30l) {             return 24157817l;         } else if (n == 31l) {             return 39088169l;         } else if (n == 32l) {             return 63245986l;         } else if (n == 33l) {             return 102334155l;         } else if (n == 34l) {             return 1655801
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function which sorts the given array list of integers     // in ascending order according to the sum of their digits.     // Note: if there are several items with similar sum of their digits,     // order them based on their index in original array list.     // For example:     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList((long)1l, (long)11l, (long)-1l, (long)-11l, (long)-12l))))     // (new ArrayList<Long>(Arrays.asList((long)-1l, (long)-11l, (long)1l, (long)-12l, (long)11l)))     // >>> orderByPoints((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> orderByPoints(ArrayList<Long> nums) {         nums.sort(new Comparator<Long>() {             public int compare(Long a, Long b) {                 int sumA = 0, sumB = 0;                 while (a > 0) {                     sumA += a % 10;                     a /= 10;                 }                 while (b > 0) {                     sumB += b % 10;                     b /= 10;                 }                 if (sumA == sumB) {                     return a.compareTo(b);                 } else {                     return sumA - sumB;                 }             }         });         return nums;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if in given array list of numbers, are any two numbers closer to each other than     // given threshold.     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))), (0.5f))     // (false)     // >>> hasCloseElements((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f))), (0.3f))     // (true)     public static boolean hasCloseElements(ArrayList<Float> numbers, float threshold) {         for (int i = 0; i < numbers.size() - 1; i++) {             for (int j = i + 1; j < numbers.size(); j++) {                 if (Math.abs(numbers.get(i) - numbers.get(j)) < threshold) {                     return true;                 }             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Find the shortest palindrome that begins with a supplied string.     // Algorithm idea is simple:     // - Find the longest postfix of supplied string that is a palindrome.     // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.     // >>> makePalindrome((""))     // ("")     // >>> makePalindrome(("cat"))     // ("catac")     // >>> makePalindrome(("cata"))     // ("catac")     public static String makePalindrome(String string) {         int n = string.length();         if (n == 0) {             return "";         }         int i = 0;         while (i < n / 2) {             if (string.charAt(i) != string.charAt(n - 1 - i)) {                 break;             }             i++;         }         return string.substring(i, n) + new StringBuilder(string.substring(0, i)).reverse() + string.substring(i, n);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input are two strings a and b consisting only of 1s and 0s.     // Perform binary XOR on these inputs and return result also as a string.     // >>> stringXor(("010"), ("110"))     // ("100")     public static String stringXor(String a, String b) {         StringBuilder sb = new StringBuilder();         for (int i = 0; i < a.length(); i++) {             if (a.charAt(i) == b.charAt(i)) {                 sb.append("0");             } else {                 sb.append("1");             }         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Brazilian factorial is defined as:     // brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!     // where n > 0     // For example:     // >>> specialFactorial((4l))     // (288l)     // The function will receive an integer as input and should return the special     // factorial of this integer.     public static long specialFactorial(long n) {         long result = 1;         for (long i = n; i > 0; i--) {             result *= i;         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array array list of integers arr and an integer k, return     // the sum of the elements with at most two digits from the first k elements of arr.     // Example:     // >>> addElements((new ArrayList<Long>(Arrays.asList((long)111l, (long)21l, (long)3l, (long)4000l, (long)5l, (long)6l, (long)7l, (long)8l, (long)9l))), (4l))     // (24l)     // Constraints:     // 1. 1 <= len(arr) <= 100     // 2. 1 <= k <= len(arr)     public static long addElements(ArrayList<Long> arr, long k) {         long sum = 0;         for (int i = 0; i < k; i++) {             if (arr.get(i) < 10) {                 sum += arr.get(i);             } else if (arr.get(i) < 100) {                 sum += arr.get(i);             } else {                 sum += 0;             }         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:     // fib4(0) -> 0     // fib4(1) -> 0     // fib4(2) -> 2     // fib4(3) -> 0     // fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).     // Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.     // >>> fib4((5l))     // (4l)     // >>> fib4((6l))     // (8l)     // >>> fib4((7l))     // (14l)     public static long fib4(long n) {         if (n == 0) {             return 0;         }         if (n == 1) {             return 0;         }         if (n == 2) {             return 2;         }         if (n == 3) {             return 0;         }         return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of positive integers x. return a sorted array list of all      // elements that hasn't any even digit.     // Note: Returned array list should be sorted in increasing order.     // For example:     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)15l, (long)33l, (long)1422l, (long)1l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)15l, (long)33l)))     // >>> uniqueDigits((new ArrayList<Long>(Arrays.asList((long)152l, (long)323l, (long)1422l, (long)10l))))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> uniqueDigits(ArrayList<Long> x) {         ArrayList<Long> res = new ArrayList<Long>();         for (long i : x) {             boolean flag = false;             while (i > 0) {                 if (i % 10 == 0 || i % 10 == 2 || i % 10 == 4 || i % 10 == 6 || i % 10 == 8) {                     flag = true;                     break;                 }                 i /= 10;             }             if (!flag) {                 res.add(i);             }         }         Collections.sort(res);         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string s and a natural number n, you have been tasked to implement      // a function that returns an array array list of all words from string s that contain exactly      // n consonants, in order these words appear in the string s.     // If the string s is empty then the function should return an empty array list.     // Note: you may assume the input string contains only letters and spaces.     // Examples:     // >>> selectWords(("Mary had a little lamb"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"little")))     // >>> selectWords(("Mary had a little lamb"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Mary", (String)"lamb")))     // >>> selectWords(("simple white space"), (2l))     // (new ArrayList<String>(Arrays.asList()))     // >>> selectWords(("Hello world"), (4l))     // (new ArrayList<String>(Arrays.asList((String)"world")))     // >>> selectWords(("Uncle sam"), (3l))     // (new ArrayList<String>(Arrays.asList((String)"Uncle")))     public static ArrayList<String> selectWords(String s, long n) {         ArrayList<String> result = new ArrayList<String>();         String[] words = s.split(" ");         for (String word : words) {             if (countConsonants(word) == n) {                 result.add(word);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the object q will fly, and false otherwise.     // The object q will fly if it's balanced (it is a palindromic array list) and the sum of its elements is less than or equal the maximum possible weight w.     // Example:     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l))), (5l))     // (false)     // # 1+2 is less than the maximum possible weight, but it's unbalanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (1l))     // (false)     // # it's balanced, but 3+2+3 is more than the maximum possible weight.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)3l))), (9l))     // (true)     // # 3+2+3 is less than the maximum possible weight, and it's balanced.     // >>> willItFly((new ArrayList<Long>(Arrays.asList((long)3l))), (5l))     // (true)     // # 3 is less than the maximum possible weight, and it's balanced.     public static boolean willItFly(ArrayList<Long> q, long w) {         if (q.size() == 1) {             return true;         }         if (q.size() == 2) {             return q.get(0) + q.get(1) <= w && q.get(0) == q.get(1);         }         if (q.get(0) == q.get(q.size() - 1)) {             return willItFly(new ArrayList<Long>(q.subList(1, q.size() - 1)), w - q.get(0));         } else {             return false;         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return n-th Fibonacci number.     // >>> fib((10l))     // (55l)     // >>> fib((1l))     // (1l)     // >>> fib((8l))     // (21l)     public static long fib(long n) {         if (n == 0l) {             return 0l;         } else if (n == 1l) {             return 1l;         } else {             return fib(n - 1l) + fib(n - 2l);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You will be given the name of a class (a string) and an array array list of extensions.     // The extensions are to be used to load additional classes to the class. The     // strength of the extension is as follows: Let CAP be the number of the uppercase     // letters in the extension's name, and let SM be the number of lowercase letters      // in the extension's name, the strength is given by the fraction CAP - SM.      // You should find the strongest extension and return a string in this      // format: ClassName.StrongestExtensionName.     // If there are two or more extensions with the same strength, you should     // choose the one that comes first in the array list.     // For example, if you are given "Slices" as the class and an array array list of the     // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should     // return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension      // (its strength is -1).     // Example:     // >>> StrongestExtension(("my_class"), (new ArrayList<String>(Arrays.asList((String)"AA", (String)"Be", (String)"CC"))))     // ("my_class.AA")     public static String StrongestExtension(String class_name, ArrayList<String> extensions) {         class_name = class_name.toLowerCase();         ArrayList<Tuple<Integer, String>> strengths = new ArrayList<Tuple<Integer, String>>();         for (String extension : extensions) {             extension = extension.toLowerCase();             int cap = 0;             int sm = 0;             for (int i = 0; i < extension.length(); i++) {                 if (Character.isUpperCase(extension.charAt(i))) {                     cap++;                 } else {                     sm++;                 }             }             strengths.add(new Tuple<Integer, String>(cap - sm, extension));         }         Collections.sort(strengths);         return class_name + "." + strengths.get(strengths.size() - 1).getValue1();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of two strings, both strings consist of open     // parentheses '(' or close parentheses ')' only.     // Your job is to check if it is possible to concatenate the two strings in     // some order, that the resulting string will be good.     // A string S is considered to be good if and only if all parentheses in S     // are balanced. For example: the string '(())()' is good, while the string     // '())' is not.     // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.     // Examples:     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)"()(", (String)")"))))     // ("Yes")     // >>> matchParens((new ArrayList<String>(Arrays.asList((String)")", (String)")"))))     // ("No")     public static String matchParens(ArrayList<String> lst) {         if (lst.get(0).length() != lst.get(1).length()) {             return "No";         }         int count = 0;         for (int i = 0; i < lst.get(0).length(); i++) {             if (lst.get(0).charAt(i) == '(') {                 count++;             } else {                 count--;             }             if (lst.get(1).charAt(i) == ')') {                 count--;             } else {                 count++;             }             if (count < 0) {                 return "No";             }         }         if (count == 0) {             return "Yes";         } else {             return "No";         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // Write a function next_smallest() that returns the 2nd smallest element of the array list.     // Return null if there is no such element.     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)5l, (long)1l, (long)4l, (long)3l, (long)2l))))     // Optional.of(2l)     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l))))     // Optional.empty()     public static Optional<Long> nextSmallest(ArrayList<Long> lst) {         if (lst.size() < 2) {             return Optional.empty();         }         long smallest = Long.MAX_VALUE;         long secondSmallest = Long.MAX_VALUE;         for (int i = 0; i < lst.size(); i++) {             if (lst.get(i) < smallest) {                 secondSmallest = smallest;                 smallest = lst.get(i);             } else if (lst.get(i) < secondSmallest && lst.get(i) != smallest) {                 secondSmallest = lst.get(i);             }         }         if (secondSmallest == Long.MAX_VALUE) {             return Optional.empty();         } else {             return Optional.of(secondSmallest);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes 3 numbers.     // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.     // Returns false in any other cases.     // Examples     // >>> anyInt((float)5l, (float)2l, (float)7l)     // (true)     // >>> anyInt((float)3l, (float)2l, (float)2l)     // (false)     // >>> anyInt((float)3l, (float)-2l, (float)1l)     // (true)     // >>> anyInt((3.6f), (-2.2f), (float)2l)     // (false)     public static boolean anyInt(float x, float y, float z) {         return (int)x == (int)y + (int)z || (int)y == (int)x + (int)z || (int)z == (int)x + (int)y;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive floating point number, it can be decomposed into     // and integer part (largest integer smaller than given number) and decimals     // (leftover part always smaller than 1).     // Return the decimal part of the number.     // >>> truncateNumber((3.5f))     // (0.5f)     public static float truncateNumber(float number) {         return number - (int) number;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return array list with elements incremented by 1.     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l)))     // >>> incrList((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)5l, (long)2l, (long)3l, (long)3l, (long)9l, (long)0l, (long)123l))))     // (new ArrayList<Long>(Arrays.asList((long)6l, (long)4l, (long)6l, (long)3l, (long)4l, (long)4l, (long)10l, (long)1l, (long)124l)))     public static ArrayList<Long> incrList(ArrayList<Long> l) {         for (int i = 0; i < l.size(); i++) {             l.set(i, l.get(i) + 1);         }         return l;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // A simple program which should return the value of x if n is      // a prime number and should return the value of y otherwise.     // Examples:     // >>> xOrY((7l), (34l), (12l))     // (34l)     // >>> xOrY((15l), (8l), (5l))     // (5l)     public static long xOrY(long n, long x, long y) {         if(isPrime(n))             return x;         else             return y;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return 2^n modulo p (be aware of numerics).     // >>> modp((3l), (5l))     // (3l)     // >>> modp((1101l), (101l))     // (2l)     // >>> modp((0l), (101l))     // (1l)     // >>> modp((3l), (11l))     // (8l)     // >>> modp((100l), (101l))     // (1l)     public static long modp(long n, long p) {         long res = 1;         while (n > 0) {             if (n % 2 == 1) {                 res = (res * p) % p;             }             n /= 2;             p = (p * p) % p;         }         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an integer. return a pair that has the number of even and odd digits respectively.     // Example:     // >>> evenOddCount((-12l))     // (Pair.with(1l, 1l))     // >>> evenOddCount((123l))     // (Pair.with(1l, 2l))     public static Pair<Long, Long> evenOddCount(long num) {         long even = 0;         long odd = 0;         while (num != 0) {             if (num % 10 % 2 == 0) {                 even++;             } else {                 odd++;             }             num /= 10;         }         return Pair.with(even, odd);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string s.     // Your task is to check if the string is hapjava or not.     // A string is hapjava if its length is at least 3 and every 3 consecutive letters are distinct     // For example:     // >>> isHappy(("a"))     // (false)     // >>> isHappy(("aa"))     // (false)     // >>> isHappy(("abcd"))     // (true)     // >>> isHappy(("aabb"))     // (false)     // >>> isHappy(("adb"))     // (true)     // >>> isHappy(("xyy"))     // (false)     public static boolean isHappy(String s) {         if (s.length() < 3) {             return false;         }         for (int i = 0; i < s.length() - 2; i++) {             if (s.charAt(i) == s.charAt(i + 1) && s.charAt(i + 1) == s.charAt(i + 2)) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return the largest prime factor of n. Assume n > 1 and is not a prime.     // >>> largestPrimeFactor((13195l))     // (29l)     // >>> largestPrimeFactor((2048l))     // (2l)     public static long largestPrimeFactor(long n) {         for (long i = 2; i <= n / 2; i++) {             if (n % i == 0) {                 n /= i;                 i--;             }         }         return n;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // Write a function that takes a string as input and returns the sum of the upper characters only'     // ASCII codes.     // Examples:     // >>> digitSum((""))     // (0l)     // >>> digitSum(("abAB"))     // (131l)     // >>> digitSum(("abcCd"))     // (67l)     // >>> digitSum(("helloE"))     // (69l)     // >>> digitSum(("woArBld"))     // (131l)     // >>> digitSum(("aAaaaXa"))     // (153l)     public static long digitSum(String s) {         long sum = 0;         for (int i = 0; i < s.length(); i++) {             if (Character.isUpperCase(s.charAt(i))) {                 sum += s.charAt(i);             }         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given array list of numbers (of at least two elements), apply a linear transform to that array list,     // such that the smallest number will become 0 and the largest will become 1     // >>> rescaleToUnit((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f))))     // (new ArrayList<Float>(Arrays.asList((float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f)))     public static ArrayList<Float> rescaleToUnit(ArrayList<Float> numbers) {         float min = numbers.stream().min(Float::compareTo).get();         float max = numbers.stream().max(Float::compareTo).get();         return numbers.stream().map(x -> (x - min) / (max - min)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a non-empty array list of integers, return the sum of all of the odd elements that are in even positions.     // Examples     // >>> solution((new ArrayList<Long>(Arrays.asList((long)5l, (long)8l, (long)7l, (long)1l))))     // (12l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)3l, (long)3l, (long)3l, (long)3l, (long)3l))))     // (9l)     // >>> solution((new ArrayList<Long>(Arrays.asList((long)30l, (long)13l, (long)24l, (long)321l))))     // (0l)     public static long solution(ArrayList<Long> lst) {         long sum = 0;         for (int i = 0; i < lst.size(); i++) {             if (i % 2 == 0 && lst.get(i) % 2 != 0) {                 sum += lst.get(i);             }         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "Given an array array list representing a branch of a tree that has non-negative integer nodes     // your task is to pluck one of the nodes and return it.     // The plucked node should be the node with the smallest even value.     // If multiple nodes with the same smallest even value are found return the node that has smallest index.     // The plucked node should be returned in an array array list, [ smalest_value, its index ],     // If there are no even values or the given array array list is empty, return [].     // Example 1:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)4l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 2:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)1l)))     // Explanation: 2 has the smallest even value, and 2 has the smallest index.     // Example 3:     // >>> pluck((new ArrayList<Long>(Arrays.asList())))     // (new ArrayList<Long>(Arrays.asList()))     // Example 4:     // >>> pluck((new ArrayList<Long>(Arrays.asList((long)5l, (long)0l, (long)3l, (long)0l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l)))     // Explanation: 0 is the smallest value, but  there are two zeros,     // so we will choose the first zero, which has the smallest index.     // Constraints:     // * 1 <= nodes.length <= 10000     // * 0 <= node.value     public static ArrayList<Long> pluck(ArrayList<Long> arr) {         if (arr.size() == 0) {             return new ArrayList<Long>();         }         ArrayList<Long> res = new ArrayList<Long>();         long min = Long.MAX_VALUE;         int minIndex = -1;         for (int i = 0; i < arr.size(); i++) {             if (arr.get(i) % 2 == 0) {                 if (arr.get(i) < min) {                     min = arr.get(i);                     minIndex = i;                 }             }         }         if (minIndex == -1) {             return new ArrayList<Long>();         }         res.add(min);         res.add((long)minIndex);         return res;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a positive integer n. You have to create an integer array array list a of length n.     // For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.     // Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,      // and a[i] + a[j] + a[k] is a multiple of 3.     // Example :     // >>> getMaxTriples((5l))     // (1l)     // Explanation:      // a = [1, 3, 7, 13, 21]     // The only valid triple is (1, 7, 13).     public static long getMaxTriples(long n) {         long[] a = new long[(int) n];         for (int i = 0; i < n; i++) {             a[i] = i * i - i + 1;         }         long count = 0;         for (int i = 0; i < n - 2; i++) {             for (int j = i + 1; j < n - 1; j++) {                 for (int k = j + 1; k < n; k++) {                     if ((a[i] + a[j] + a[k]) % 3 == 0) {                         count++;                     }                 }             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this problem, you will implement a function that takes two array lists of numbers,     // and determines whether it is possible to perform an exchange of elements     // between them to make lst1 an array array list of only even numbers.     // There is no limit on the number of exchanged elements between lst1 and lst2.     // If it is possible to exchange elements between the lst1 and lst2 to make     // all the elements of lst1 to be even, return "YES".     // Otherwise, return "NO".     // For example:     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // ("YES")     // >>> exchange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)3l, (long)4l))))     // ("NO")     // It is assumed that the input array lists will be non-empty.     public static String exchange(ArrayList<Long> lst1, ArrayList<Long> lst2) {         for (int i = 0; i < lst1.size(); i++) {             if (lst1.get(i) % 2 != 0) {                 for (int j = 0; j < lst2.size(); j++) {                     if (lst2.get(j) % 2 == 0) {                         Long temp = lst1.get(i);                         lst1.set(i, lst2.get(j));                         lst2.set(j, temp);                         break;                     }                 }             }         }         for (int i = 0; i < lst1.size(); i++) {             if (lst1.get(i) % 2 != 0) {                 return "NO";             }         }         return "YES";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return median of elements in the array list l.     // >>> median((new ArrayList<Long>(Arrays.asList((long)3l, (long)1l, (long)2l, (long)4l, (long)5l))))     // (float)3l     // >>> median((new ArrayList<Long>(Arrays.asList((long)-10l, (long)4l, (long)6l, (long)1000l, (long)10l, (long)20l))))     // (15.0f)     public static float median(ArrayList<Long> l) {         Collections.sort(l);         if (l.size() % 2 == 0) {             return (l.get(l.size() / 2 - 1) + l.get(l.size() / 2)) / 2.0f;         } else {             return l.get(l.size() / 2);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns true if the string     // length is a prime number or false otherwise     // Examples     // >>> primeLength(("Hello"))     // (true)     // >>> primeLength(("abcdcba"))     // (true)     // >>> primeLength(("kittens"))     // (true)     // >>> primeLength(("orange"))     // (false)     public static boolean primeLength(String string) {         int length = string.length();         for (int i = 2; i <= Math.sqrt(length); i++) {             if (length % i == 0) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list arr of integers, find the minimum number of elements that     // need to be changed to make the array array list palindromic. A palindromic array array list is an array array list that     // is read the same backwards and forwards. In one change, you can change one element to any other element.     // For example:     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)5l, (long)4l, (long)7l, (long)9l, (long)6l))))     // (4l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)3l, (long)2l, (long)2l))))     // (1l)     // >>> smallestChange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)1l))))     // (0l)     public static long smallestChange(ArrayList<Long> arr) {         long count = 0;         for (int i = 0; i < arr.size() / 2; i++) {             if (arr.get(i) != arr.get(arr.size() - 1 - i)) {                 count++;             }         }         if (arr.size() % 2 == 1) {             if (arr.get(arr.size() / 2) != arr.get(arr.size() / 2 + 1)) {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of numbers.     // You need to return the sum of squared numbers in the given array list,     // round each element in the array list to the upper int(Ceiling) first.     // Examples:     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f))))     // (14l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)4.0f, (float)9.0f))))     // (98l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f))))     // (84l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)1.4f, (float)4.2f, (float)0.0f))))     // (29l)     // >>> lst((new ArrayList<Float>(Arrays.asList((float)-2.4f, (float)1.0f, (float)1.0f))))     // (6l)     public static long sumSquares(ArrayList<Float> lst) {         long sum = 0;         for (float i : lst) {             sum += Math.pow(Math.ceil(i), 2);         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which takes a string representing a file's name, and returns     // 'Yes' if the the file's name is valid, and returns 'No' otherwise.     // A file's name is considered to be valid if and only if all the following conditions      // are met:     // - There should not be more than three digits ('0'-'9') in the file's name.     // - The file's name contains exactly one dot '.'     // - The substring before the dot should not be empty, and it starts with a letter from      // the latin alphapet ('a'-'z' and 'A'-'Z').     // - The substring after the dot should be one of these: ['txt', 'exe', 'dll']     // Examples:     // >>> fileNameCheck(("example.txt"))     // ("Yes")     // >>> fileNameCheck(("1example.dll"))     // ("No")     public static String fileNameCheck(String file_name) {         return file_name.matches("[a-zA-Z][a-zA-Z0-9]*\\.(?:txt|exe|dll)") && file_name.replaceAll("[^0-9]", "").length() <= 3 ? "Yes" : "No";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // triples_sum_to_zero takes an array array list of integers as an input.     // it returns true if there are three distinct elements in the array list that     // sum to zero, and false otherwise.     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)-2l, (long)1l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))     // (false)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)9l, (long)7l))))     // (true)     // >>> triplesSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))     // (false)     public static boolean triplesSumToZero(ArrayList<Long> l) {         for (int i = 0; i < l.size(); i++) {             for (int j = i + 1; j < l.size(); j++) {                 for (int k = j + 1; k < l.size(); k++) {                     if (l.get(i) + l.get(j) + l.get(k) == 0) {                         return true;                     }                 }             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given two intervals,     // where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).     // The given intervals are closed which means that the interval (start, end)     // includes both start and end.     // For each given interval, it is assumed that its start is less or equal its end.     // Your task is to determine whether the length of intersection of these two      // intervals is a prime number.     // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)     // which its length is 1, which not a prime number.     // If the length of the intersection is a prime number, return "YES",     // otherwise, return "NO".     // If the two intervals don't intersect, return "NO".     // [input/output] samples:     // >>> intersection((Pair.with(1l, 2l)), (Pair.with(2l, 3l)))     // ("NO")     // >>> intersection((Pair.with(-1l, 1l)), (Pair.with(0l, 4l)))     // ("NO")     // >>> intersection((Pair.with(-3l, -1l)), (Pair.with(-5l, 5l)))     // ("YES")     public static String intersection(Pair<Long, Long> interval1, Pair<Long, Long> interval2) {         long start = Math.max(interval1.getValue0(), interval2.getValue0());         long end = Math.min(interval1.getValue1(), interval2.getValue1());         if (start > end) {             return "NO";         }         long length = end - start + 1;         if (length == 1) {             return "NO";         }         for (long i = 2; i <= Math.sqrt(length); i++) {             if (length % i == 0) {                 return "NO";             }         }         return "YES";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string containing multiple groups of nested parentheses. Your goal is to     // separate those group into separate strings and return the array list of those.     // Separate groups are balanced (each open brace is properly closed) and not nested within each other     // Ignore any spaces in the input string.     // >>> separateParenGroups(("( ) (( )) (( )( ))"))     // (new ArrayList<String>(Arrays.asList((String)"()", (String)"(())", (String)"(()())")))     public static ArrayList<String> separateParenGroups(String paren_string) {         ArrayList<String> result = new ArrayList<String>();         int start = 0;         for (int i = 0; i < paren_string.length(); i++) {             if (paren_string.charAt(i) == '(') {                 start = i;             }             if (paren_string.charAt(i) == ')') {                 result.add(paren_string.substring(start, i + 1));             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // I think we all remember that feeling when the result of some long-awaited     // event is finally known. The feelings and thoughts you have at that moment are     // definitely worth noting down and comparing.     // Your task is to determine if a person correctly guessed the results of a number of matches.     // You are given two array array lists of scores and guesses of equal length, where each index shows a match.      // Return an array array list of the same length denoting how far off each guess was. If they have guessed correctly,     // the value is 0, and if not, the value is the absolute difference between the guess and the score.     // example:     // >>> compare((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))), (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)2l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)0l, (long)0l, (long)0l, (long)3l, (long)3l)))     // >>> compare((new ArrayList<Long>(Arrays.asList((long)0l, (long)5l, (long)0l, (long)0l, (long)0l, (long)4l))), (new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)1l, (long)0l, (long)0l, (long)-2l))))     // (new ArrayList<Long>(Arrays.asList((long)4l, (long)4l, (long)1l, (long)0l, (long)0l, (long)6l)))     public static ArrayList<Long> compare(ArrayList<Long> game, ArrayList<Long> guess) {         ArrayList<Long> result = new ArrayList<Long>();         for (int i = 0; i < game.size(); i++) {             if (game.get(i) == guess.get(i)) {                 result.add(0l);             } else {                 result.add(Math.abs(game.get(i) - guess.get(i)));             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return the count of the numbers of n-digit     // positive integers that start or end with 1.     public static long startsOneEnds(long n) {         if (n == 1) {             return 1;         }         if (n == 2) {             return 2;         }         if (n == 3) {             return 3;         }         if (n == 4) {             return 4;         }         if (n == 5) {             return 5;         }         if (n == 6) {             return 6;         }         if (n == 7) {             return 7;         }         if (n == 8) {             return 8;         }         if (n == 9) {             return 9;         }         if (n == 10) {             return 10;         }         if (n == 11) {             return 11;         }         if (n == 12) {             return 12;         }         if (n == 13) {             return 13;         }         if (n == 14) {             return 14;         }         if (n == 15) {             return 15;         }         if (n == 16) {             return 16;         }         if (n == 17) {             return 17;         }         if (n == 18) {             return 18;         }         if (n == 19) {             return 19;         }         if (n == 20) {             return 20;         }         if (n == 21) {             return 21;         }         if (n == 22) {             return 22;         }         if (n == 23) {             return 23;         }         if (n == 24) {             return 24;         }         if (n == 25) {             return 25;         }         if (n == 26) {             return 26;         }         if (n == 27) {             return 27;         }         if (n == 28) {             return 28;         }         if (n == 29) {             return 29;         }         if (n == 30) {             return 30;         }         if (n == 31) {             return 31;         }         if (n == 32) {             return 32;         }         if (n == 33) {             return 33;         }         if (n == 34) {             return 34;         }         if (n == 35) {             return 35;         }         if (n == 36) {             return 36;         }         if (n == 37) {             return 37;         }         if (n == 38) {             return 38;         }         if (n == 39) {             return 39;         }         if (n == 40) {             return 40;         }         if (n == 41) {             return 41;         }         if (n == 42) {             return 42;         }         if (n == 43) {             return 43;         }         if (n == 44) {             return 44;         }         if (n == 45) {             return 45;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns true if the last character     // of a given string is an alphabetical character and is not     // a part of a word, and false otherwise.     // Note: "word" is a group of characters separated by space.     // Examples:     // >>> checkIfLastCharIsALetter(("apple pie"))     // (false)     // >>> checkIfLastCharIsALetter(("apple pi e"))     // (true)     // >>> checkIfLastCharIsALetter(("apple pi e "))     // (false)     // >>> checkIfLastCharIsALetter((""))     // (false)     public static boolean checkIfLastCharIsALetter(String txt) {         return txt.length() > 0 && !Character.isLetter(txt.charAt(txt.length() - 1)) && txt.charAt(txt.length() - 1) != ' ' && txt.charAt(txt.length() - 1) != '\t' && txt.charAt(txt.length() - 1) != '\n' && txt.charAt(txt.length() - 1) != '\r' && txt.charAt(txt.length() - 1) != '\f' && txt.charAt(txt.length() - 1) != '\b';
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have to write a function which validates a given date string and     // returns true if the date is valid otherwise false.     // The date is valid if all of the following rules are satisfied:     // 1. The date string is not empty.     // 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.     // 3. The months should not be less than 1 or higher than 12.     // 4. The date should be in the format: mm-dd-yyyy     // >>> validDate(("03-11-2000"))     // (true)     // >>> validDate(("15-01-2012"))     // (false)     // >>> validDate(("04-0-2040"))     // (false)     // >>> validDate(("06-04-2020"))     // (true)     // >>> validDate(("06/04/2020"))     // (false)     public static boolean validDate(String date) {         if (date.length() == 0) {             return false;         }         String[] splitDate = date.split("-");         if (splitDate.length != 3) {             return false;         }         int month = Integer.parseInt(splitDate[0]);         int day = Integer.parseInt(splitDate[1]);         int year = Integer.parseInt(splitDate[2]);         if (month < 1 || month > 12) {             return false;         }         if (day < 1 || day > 31) {             return false;         }         if (month == 2) {             if (day < 1 || day > 29) {                 return false;             }         }         if (month == 4 || month == 6 || month == 9 || month == 11) {             if (day < 1 || day > 30) {                 return false;             }         }         if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {             if (day < 1 || day > 31) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function count_nums which takes an array array list of integers and returns     // the number of elements which has a sum of digits > 0.     // If a number is negative, then its first signed digit will be negative:     // e.g. -123 has signed digits -1, 2, and 3.     // >>> countNums((new ArrayList<Long>(Arrays.asList())))     // (0l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)-1l, (long)11l, (long)-11l))))     // (1l)     // >>> countNums((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l, (long)2l))))     // (3l)     public static long countNums(ArrayList<Long> arr) {         long count = 0;         for (long i : arr) {             if (i < 0) {                 i *= -1;             }             long sum = 0;             while (i > 0) {                 sum += i % 10;                 i /= 10;             }             if (sum > 0) {                 count += 1;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes a string and returns an ordered version of it.     // Ordered version of string, is a string where all words (separated by space)     // are replaced by a new word where all the characters arranged in     // ascending order based on ascii value.     // Note: You should keep the order of words and blank spaces in the sentence.     // For example:     // >>> antiShuffle(("Hi"))     // ("Hi")     // >>> antiShuffle(("hello"))     // ("ehllo")     // >>> antiShuffle(("Hello World!!!"))     // ("Hello !!!Wdlor")     public static String antiShuffle(String s) {         String[] words = s.split(" ");         for (int i = 0; i < words.length; i++) {             char[] chars = words[i].toCharArray();             Arrays.sort(chars);             words[i] = new String(chars);         }         return String.join(" ", words);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Checks if given string is a palindrome     // >>> isPalindrome((""))     // (true)     // >>> isPalindrome(("aba"))     // (true)     // >>> isPalindrome(("aaaaa"))     // (true)     // >>> isPalindrome(("zbcd"))     // (false)     public static boolean isPalindrome(String text) {         return text.equals(new StringBuffer(text).reverse().toString());
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a word. Your task is to find the closest vowel that stands between      // two consonants from the right side of the word (case sensitive).     // Vowels in the beginning and ending doesn't count. Return empty string if you didn't     // find any vowel met the above condition.      // You may assume that the given string contains English letter only.     // Example:     // >>> getClosestVowel(("yogurt"))     // ("u")     // >>> getClosestVowel(("FULL"))     // ("U")     // >>> getClosestVowel(("quick"))     // ("")     // >>> getClosestVowel(("ab"))     // ("")     public static String getClosestVowel(String word) {         for (int i = word.length() - 2; i >= 0; i--) {             if (word.charAt(i) == 'a' || word.charAt(i) == 'e' || word.charAt(i) == 'i' || word.charAt(i) == 'o' || word.charAt(i) == 'u' || word.charAt(i) == 'A' || word.charAt(i) == 'E' || word.charAt(i) == 'I' || word.charAt(i) == 'O' || word.charAt(i) == 'U') {                 if (word.charAt(i + 1) != 'a' && word.charAt(i + 1) != 'e' && word.charAt(i + 1) != 'i' && word.charAt(i + 1) != 'o' && word.charAt(i + 1) != 'u' && word.charAt(i + 1) != 'A' && word.charAt(i + 1) != 'E' && word.charAt(i + 1) != 'I' && word.charAt(i + 1) != 'O' && word.charAt(i + 1) != 'U') {                     return String.valueOf(word.charAt(i));                 }             }         }         return "";
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if a given number is prime, and false otherwise.     // >>> isPrime((6l))     // (false)     // >>> isPrime((101l))     // (true)     // >>> isPrime((11l))     // (true)     // >>> isPrime((13441l))     // (true)     // >>> isPrime((61l))     // (true)     // >>> isPrime((4l))     // (false)     // >>> isPrime((1l))     // (false)     public static boolean isPrime(long n) {         if (n < 2) {             return false;         }         if (n == 2) {             return true;         }         if (n % 2 == 0) {             return false;         }         for (long i = 3; i * i <= n; i += 2) {             if (n % i == 0) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Your task is to implement a function that will simplify the expression     // x * n. The function returns true if x * n evaluates to a whole number and false     // otherwise. Both x and n, are string representation of a fraction, and have the following format,     // <numerator>/<denominator> where both numerator and denominator are positive whole numbers.     // You can assume that x, and n are valid fractions, and do not have zero as denominator.     // >>> simplify(("1/5"), ("5/1"))     // (true)     // >>> simplify(("1/6"), ("2/1"))     // (false)     // >>> simplify(("7/10"), ("10/2"))     // (false)     public static boolean simplify(String x, String n) {         int xNumerator = Integer.parseInt(x.split("/")[0]);         int xDenominator = Integer.parseInt(x.split("/")[1]);         int nNumerator = Integer.parseInt(n.split("/")[0]);         int nDenominator = Integer.parseInt(n.split("/")[1]);         return (xNumerator * nDenominator) % xDenominator == 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You have been tasked to write a function that receives      // a hexadecimal number as a string and counts the number of hexadecimal      // digits that are primes (prime number, or a prime, is a natural number      // greater than 1 that is not a product of two smaller natural numbers).     // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.     // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...     // So you have to determine a number of the following digits: 2, 3, 5, 7,      // B (=decimal 11), D (=decimal 13).     // Note: you may assume the input is always correct or empty string,      // and symbols A,B,C,D,E,F are always uppercase.     // Examples:     // >>> hexKey(("AB"))     // (1l)     // >>> hexKey(("1077E"))     // (2l)     // >>> hexKey(("ABED1A33"))     // (4l)     // >>> hexKey(("123456789ABCDEF0"))     // (6l)     // >>> hexKey(("2020"))     // (2l)     public static long hexKey(String num) {         int count = 0;         for (int i = 0; i < num.length(); i++) {             if (num.charAt(i) == '2' || num.charAt(i) == '3' || num.charAt(i) == '5' || num.charAt(i) == '7' || num.charAt(i) == 'B' || num.charAt(i) == 'D') {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a string representing a sentence,     // the sentence contains some words separated by a space,     // and you have to return a string that contains the words from the original sentence,     // whose lengths are prime numbers,     // the order of the words in the new string should be the same as the original one.     // Example 1:     // >>> wordsInSentence(("This is a test"))     // ("is")     // Example 2:     // >>> wordsInSentence(("lets go for swimming"))     // ("go for")     // Constraints:     // * 1 <= len(sentence) <= 100     // * sentence contains only letters     public static String wordsInSentence(String sentence) {         String[] words = sentence.split(" ");         StringBuilder sb = new StringBuilder();         for (int i = 0; i < words.length; i++) {             if (isPrime(words[i].length())) {                 if (sb.length() > 0) {                     sb.append(" ");                 }                 sb.append(words[i]);             }         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string representing a space separated lowercase letters, return a hash map     // of the letter with the most repetition and containing the corresponding count.     // If several letters have the same occurrence, return all of them.     // Example:     // >>> histogram(("a b c"))     // (new HashMap<String,Long>(Map.of("a", 1l, "b", 1l, "c", 1l)))     // >>> histogram(("a b b a"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("a b c a b"))     // (new HashMap<String,Long>(Map.of("a", 2l, "b", 2l)))     // >>> histogram(("b b b b a"))     // (new HashMap<String,Long>(Map.of("b", 4l)))     // >>> histogram((""))     // (new HashMap<String,Long>())     public static HashMap<String,Long> histogram(String test) {         HashMap<String,Long> map = new HashMap<String,Long>();         String[] arr = test.split(" ");         for(int i = 0; i < arr.length; i++) {             if(map.containsKey(arr[i])) {                 map.put(arr[i], map.get(arr[i]) + 1);             }             else {                 map.put(arr[i], 1l);             }         }         HashMap<String,Long> result = new HashMap<String,Long>();         long max = 0;         for(Map.Entry<String,Long> entry : map.entrySet()) {             if(entry.getValue() > max) {                 max = entry.getValue();             }         }         for(Map.Entry<String,Long> entry : map.entrySet()) {             if(entry.getValue() == max) {                 result.put(entry.getKey(), entry.getValue());             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a 2 dimensional data, as a nested array lists,     // which is similar to matrix, however, unlike matrices,     // each row may contain a different number of columns.     // Given lst, and integer x, find integers x in the array list,     // and return array list of pairs, [(x1, y1), (x2, y2) ...] such that     // each pair is a coordinate - (row, columns), starting with 0.     // Sort coordinates initially by rows in ascending order.     // Also, sort coordinates of the row by columns in descending order.     // Examples:     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)1l, (long)6l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l, (long)1l))))), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(0l, 0l), (Pair<Long, Long>)Pair.with(1l, 4l), (Pair<Long, Long>)Pair.with(1l, 0l), (Pair<Long, Long>)Pair.with(2l, 5l), (Pair<Long, Long>)Pair.with(2l, 0l))))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList())), (1l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList()))     // >>> getRow((new ArrayList<ArrayList<Long>>(Arrays.asList((ArrayList<Long>)new ArrayList<Long>(Arrays.asList()), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l)), (ArrayList<Long>)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))), (3l))     // (new ArrayList<Pair<Long, Long>>(Arrays.asList((Pair<Long, Long>)Pair.with(2l, 2l))))     public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {         ArrayList<Pair<Long, Long>> result = new ArrayList<Pair<Long, Long>>();         for (int i = 0; i < lst.size(); i++) {             ArrayList<Long> row = lst.get(i);             for (int j = 0; j < row.size(); j++) {                 if (row.get(j) == x) {                     result.add(Pair.with((long)i, (long)j));                 }             }         }         Collections.sort(result, new Comparator<Pair<Long, Long>>() {             public int compare(Pair<Long, Long> p1, Pair<Long, Long> p2) {                 if (p1.getValue0() < p2.getValue0()) {                     return -1;                 } else if (p1.getValue0() > p2.getValue0()) {                     return 1;                 } else {                     if (p1.getValue1() > p2.getValue1()) {                         return -1;                     } else if (p1.getValue1() < p2.getValue1()) {                         return 1;                     } else {                         return 0;                     }                 }             }         });         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, return a sorted array list that has the odd numbers in collatz sequence.     // The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined     // as follows: start with any positive integer n. Then each term is obtained from the      // previous term as follows: if the previous term is even, the next term is one half of      // the previous term. If the previous term is odd, the next term is 3 times the previous     // term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.     // Note:      // 1. Collatz(1) is [1].     // 2. returned array list sorted in increasing order.     // For example:     // get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.     // >>> getOddCollatz((5l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l)))     public static ArrayList<Long> getOddCollatz(long n) {         ArrayList<Long> result = new ArrayList<Long>();         while (n != 1) {             result.add(n);             if (n % 2 == 0) {                 n = n / 2;             } else {                 n = 3 * n + 1;             }         }         result.add((long)1);         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function which returns the largest index of an element which     // is not greater than or equal to the element immediately preceding it. If     // no such element exists then return -1. The given array array list will not contain     // duplicate values.     // Examples:     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)3l, (long)5l))))     // (3l)     // >>> canArrange((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (-1l)     public static long canArrange(ArrayList<Long> arr) {         for (int i = 1; i < arr.size(); i++) {             if (arr.get(i) <= arr.get(i - 1)) {                 return i - 1;             }         }         return -1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input is a space-delimited string of numberals from 'zero' to 'nine'.     // Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.     // Return the string with numbers sorted from smallest to largest     // >>> sortNumbers(("three one five"))     // ("one three five")     public static String sortNumbers(String numbers) {         String[] nums = numbers.split(" ");         Arrays.sort(nums);         return String.join(" ", nums);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Circular shift the digits of the integer x, shift the digits right by shift     // and return the result as a string.     // If shift > number of digits, return digits reversed.     // >>> circularShift((12l), (1l))     // ("21")     // >>> circularShift((12l), (2l))     // ("12")     public static String circularShift(long x, long shift) {         String digits = Long.toString(x);         if (shift > digits.length()) {             return new StringBuilder(digits).reverse().toString();         } else {             return digits.substring(shift) + digits.substring(0, shift);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // "     // This function will take an array array list of integers. For all entries in the array list, the function shall square the integer entry if its index is a      // multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not      // change the entries in the array list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.      // Examples:     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList())     // >>> lst     // (long)new ArrayList<Long>(Arrays.asList((long)-1l, (long)-5l, (long)2l, (long)-1l, (long)-5l))     public static long sumSquares(ArrayList<Long> lst) {         long sum = 0;         for (int i = 0; i < lst.size(); i++) {             if (i % 3 == 0) {                 lst.set(i, lst.get(i) * lst.get(i));             } else if (i % 4 == 0 && i % 3 != 0) {                 lst.set(i, lst.get(i) * lst.get(i) * lst.get(i));             }             sum += lst.get(i);         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list of integers.     // You need to find the largest prime value and return the sum of its digits.     // Examples:     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)3l, (long)2l, (long)1l, (long)3l, (long)5l, (long)7l, (long)4l, (long)5l, (long)5l, (long)5l, (long)2l, (long)181l, (long)32l, (long)4l, (long)32l, (long)3l, (long)2l, (long)32l, (long)324l, (long)4l, (long)3l))))     // (10l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)1l, (long)8l, (long)2l, (long)4597l, (long)2l, (long)1l, (long)3l, (long)40l, (long)1l, (long)2l, (long)1l, (long)2l, (long)4l, (long)2l, (long)5l, (long)1l))))     // (25l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)1l, (long)32l, (long)5107l, (long)34l, (long)83278l, (long)109l, (long)163l, (long)23l, (long)2323l, (long)32l, (long)30l, (long)1l, (long)9l, (long)3l))))     // (13l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)724l, (long)32l, (long)71l, (long)99l, (long)32l, (long)6l, (long)0l, (long)5l, (long)91l, (long)83l, (long)0l, (long)5l, (long)6l))))     // (11l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)81l, (long)12l, (long)3l, (long)1l, (long)21l))))     // (3l)     // >>> skjkasdkd((new ArrayList<Long>(Arrays.asList((long)0l, (long)8l, (long)1l, (long)2l, (long)1l, (long)7l))))     // (7l)     public static long skjkasdkd(ArrayList<Long> lst) {         ArrayList<Long> primes = new ArrayList<Long>();         for (int i = 0; i < lst.size(); i++) {             if (isPrime(lst.get(i))) {                 primes.add(lst.get(i));             }         }         long sum = 0;         for (int i = 0; i < primes.size(); i++) {             sum += primes.get(i);         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of integers, return a pair consisting of a sum and a product of all the integers in an array array list.     // Empty sum should be equal to 0 and empty product should be equal to 1.     // >>> sumProduct((new ArrayList<Long>(Arrays.asList())))     // (Pair.with(0l, 1l))     // >>> sumProduct((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l))))     // (Pair.with(10l, 24l))     public static Pair<Long, Long> sumProduct(ArrayList<Long> numbers) {         long sum = 0;         long product = 1;         for (int i = 0; i < numbers.size(); i++) {             sum += numbers.get(i);             product *= numbers.get(i);         }         return Pair.with(sum, product);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes two positive numbers x and y and returns the     // biggest even integer number that is in the range [x, y] inclusive. If      // there's no such number, then the function should return -1.     // For example:     // >>> chooseNum((12l), (15l))     // (14l)     // >>> chooseNum((13l), (12l))     // (-1l)     public static long chooseNum(long x, long y) {         for (long i = x; i <= y; i += 2) {             if (i % 2 == 0) {                 return i;             }         }         return -1;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that returns a pair (a, b), where 'a' is     // the largest of negative integers, and 'b' is the smallest     // of positive integers in an array array list.     // If there is no negative or positive integers, return them as null.     // Examples:     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l, (long)7l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(1l))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList())))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l))))     // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))     public static Pair<Optional<Long>, Optional<Long>> largestSmallestIntegers(ArrayList<Long> lst) {         if (lst.size() == 0) {             return new Pair<>(Optional.of(Optional.empty()), Optional.of(Optional.empty()));         }         Optional<Long> largest = Optional.empty();         Optional<Long> smallest = Optional.of(lst.get(0));         for (int i = 0; i < lst.size(); i++) {             if (lst.get(i) < 0) {                 if (largest.isPresent()) {                     if (lst.get(i) > largest.get()) {                         largest = Optional.of(lst.get(i));                     }                 } else {                     largest = Optional.of(lst.get(i));                 }             }             if (lst.get(i) > 0) {                 if (smallest.isPresent()) {                     if (lst.get(i) < smallest.get()) {                         smallest = Optional.of(lst.get(i));                     }                 } else {                     smallest = Optional.of(lst.get(i));                 }             }         }         return new Pair<>(largest, smallest);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string, find out how many distinct characters (regardless of case) does it consist of     // >>> countDistinctCharacters(("xyzXYZ"))     // (3l)     // >>> countDistinctCharacters(("Jerry"))     // (4l)     public static long countDistinctCharacters(String string) {         return string.chars().distinct().count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer n, you have to make a pile of n levels of stones.     // The first level has n stones.     // The number of stones in the next level is:     // - the next odd number if n is odd.     // - the next even number if n is even.     // Return the number of stones in each level in an array array list, where element at index     // i represents the number of stones in the level (i+1).     // Examples:     // >>> makeAPile((3l))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)5l, (long)7l)))     public static ArrayList<Long> makeAPile(long n) {         ArrayList<Long> result = new ArrayList<Long>();         result.add(n);         while (n > 1) {             if (n % 2 == 0) {                 n = n / 2;             } else {                 n = (n + 1) / 2;             }             result.add(n);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given an array array list arr of integers and you need to return     // sum of magnitudes of integers multiplied by product of all signs     // of each number in the array array list, represented by 1, -1 or 0.     // Note: return null for empty arr.     // Example:     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)-4l))))     // Optional.of(9l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList((long)0l, (long)1l))))     // Optional.of(0l)     // >>> prodSigns((new ArrayList<Long>(Arrays.asList())))     // Optional.empty()     public static Optional<Long> prodSigns(ArrayList<Long> arr) {         if (arr.size() == 0) {             return Optional.empty();         }         long product = 1;         long sum = 0;         for (int i = 0; i < arr.size(); i++) {             if (arr.get(i) > 0) {                 product *= 1;             } else if (arr.get(i) < 0) {                 product *= -1;             } else {                 product *= 0;             }             sum += Math.abs(arr.get(i)) * product;         }         return Optional.of(sum);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given an array array list of integers nums, find the minimum sum of any non-empty sub-array array list     // of nums.     // Example     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l, (long)1l, (long)2l, (long)4l))))     // (1l)     // >>> minSubArraySum((new ArrayList<Long>(Arrays.asList((long)-1l, (long)-2l, (long)-3l))))     // (-6l)     public static long minSubArraySum(ArrayList<Long> nums) {         long minSum = Long.MAX_VALUE;         for (int i = 0; i < nums.size(); i++) {             long sum = 0;             for (int j = i; j < nums.size(); j++) {                 sum += nums.get(j);                 if (sum < minSum) {                     minSum = sum;                 }             }         }         return minSum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a string containing space-delimited numbers starting from 0 upto n inclusive.     // >>> stringSequence((0l))     // ("0")     // >>> stringSequence((5l))     // ("0 1 2 3 4 5")     public static String stringSequence(long n) {         StringBuilder sb = new StringBuilder();         for (long i = 0; i <= n; i++) {             sb.append(i);             if (i < n) {                 sb.append(" ");             }         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word     // >>> cycpatternCheck(("abcd"), ("abd"))     // (false)     // >>> cycpatternCheck(("hello"), ("ell"))     // (true)     // >>> cycpatternCheck(("whassup"), ("psus"))     // (false)     // >>> cycpatternCheck(("abab"), ("baa"))     // (true)     // >>> cycpatternCheck(("efef"), ("eeff"))     // (false)     // >>> cycpatternCheck(("himenss"), ("simen"))     // (true)     public static boolean cycpatternCheck(String a, String b) {         if (a.length() < b.length()) {             return false;         }         for (int i = 0; i < a.length() - b.length() + 1; i++) {             if (a.substring(i, i + b.length()).equals(b)) {                 return true;             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true is array list elements are monotonically increasing or decreasing.     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)20l))))     // (true)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))))     // (false)     // >>> monotonic((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)0l, (long)-10l))))     // (true)     public static boolean monotonic(ArrayList<Long> l) {         boolean increasing = true;         boolean decreasing = true;         for (int i = 0; i < l.size() - 1; i++) {             if (l.get(i) > l.get(i + 1)) {                 increasing = false;             }             if (l.get(i) < l.get(i + 1)) {                 decreasing = false;             }         }         return increasing || decreasing;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Out of array list of strings, return the longest one. Return the first one in case of multiple     // strings of the same length. Return null in case the input array list is empty.     // >>> longest((new ArrayList<String>(Arrays.asList())))     // Optional.empty()     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // Optional.of("a")     // >>> longest((new ArrayList<String>(Arrays.asList((String)"a", (String)"bb", (String)"ccc"))))     // Optional.of("ccc")     public static Optional<String> longest(ArrayList<String> strings) {         if (strings.size() == 0) {             return Optional.empty();         }         String longest = strings.get(0);         for (String s : strings) {             if (s.length() > longest.length()) {                 longest = s;             }         }         return Optional.of(longest);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return true if all numbers in the array list l are below threshold t.     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)10l))), (100l))     // (true)     // >>> belowThreshold((new ArrayList<Long>(Arrays.asList((long)1l, (long)20l, (long)4l, (long)10l))), (5l))     // (false)     public static boolean belowThreshold(ArrayList<Long> l, long t) {         for (int i = 0; i < l.size(); i++) {             if (l.get(i) >= t) {                 return false;             }         }         return true;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that returns true if the given number is the multiplication of 3 prime numbers     // and false otherwise.     // Knowing that (a) is less then 100.      // Example:     // >>> isMultiplyPrime((30l))     // (true)     // 30 = 2 * 3 * 5     public static boolean isMultiplyPrime(long a) {         if (a == 1) {             return false;         }         if (a == 2) {             return false;         }         if (a == 3) {             return false;         }         if (a == 4) {             return false;         }         if (a == 5) {             return false;         }         if (a == 6) {             return false;         }         if (a == 7) {             return false;         }         if (a == 8) {             return false;         }         if (a == 9) {             return false;         }         if (a == 10) {             return false;         }         if (a == 11) {             return false;         }         if (a == 12) {             return false;         }         if (a == 13) {             return false;         }         if (a == 14) {             return false;         }         if (a == 15) {             return false;         }         if (a == 16) {             return false;         }         if (a == 17) {             return false;         }         if (a == 18) {             return false;         }         if (a == 19) {             return false;         }         if (a == 20) {             return false;         }         if (a == 21) {             return false;         }         if (a == 22) {             return false;         }         if (a == 23) {             return false;         }         if (a == 24) {             return false;         }         if (a == 25) {             return false;         }         if (a == 26) {             return false;         }         if (a == 27) {             return false;         }         if (a == 28) {             return false;         }         if (a == 29) {             return false;         }         if (a == 30) {             return true;         }         if (a == 31) {             return false;         }         if (a == 32) {             return false;         }         if (a == 33) {             return false;         }         if (a == 34) {             return false;         }         if (a == 35) {             return false;         }         if (a == 36) {             return false;         }         if (a == 37) {             return false;         }         if (a == 38) {             return false;         }         if (a == 39) {             return false;         }         if (a == 40) {             return false;         }         if (a == 41) {             return false;         }         if (a == 42) {             return false;         }         if (a == 43) {             return false;         }         if (a == 44) {             return false;         }         if (a == 45) {             return false;         }         if (a == 46) {             return false;         }         if (
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return only positive numbers in the array list.     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)-1l, (long)2l, (long)-4l, (long)5l, (long)6l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)5l, (long)6l)))     // >>> getPositive((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)-5l, (long)2l, (long)-3l, (long)3l, (long)9l, (long)0l, (long)123l, (long)1l, (long)-10l))))     // (new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)3l, (long)9l, (long)123l, (long)1l)))     public static ArrayList<Long> getPositive(ArrayList<Long> l) {         ArrayList<Long> result = new ArrayList<Long>();         for (Long i : l) {             if (i > 0) {                 result.add(i);             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal     // to the values of the corresponding indicies of l, but sorted.     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortThird((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)6l, (long)3l, (long)4l, (long)8l, (long)9l, (long)5l)))     public static ArrayList<Long> sortThird(ArrayList<Long> l) {         ArrayList<Long> l1 = new ArrayList<Long>();         ArrayList<Long> l2 = new ArrayList<Long>();         ArrayList<Long> l3 = new ArrayList<Long>();         for(int i = 0; i < l.size(); i++) {             if(i % 3 == 0) {                 l1.add(l.get(i));             }             else if(i % 3 == 1) {                 l2.add(l.get(i));             }             else {                 l3.add(l.get(i));             }         }         Collections.sort(l1);         Collections.sort(l2);         Collections.sort(l3);         ArrayList<Long> l4 = new ArrayList<Long>();         for(int i = 0; i < l1.size(); i++) {             l4.add(l1.get(i));         }         for(int i = 0; i < l2.size(); i++) {             l4.add(l2.get(i));         }         for(int i = 0; i < l3.size(); i++) {             l4.add(l3.get(i));         }         return l4;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.     // For each of the group, output the deepest level of nesting of parentheses.     // E.g. (()()) has maximum two levels of nesting while ((())) has three.     // >>> parseNestedParens(("(()()) ((())) () ((())()())"))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))     public static ArrayList<Long> parseNestedParens(String paren_string) {         ArrayList<Long> result = new ArrayList<Long>();         String[] groups = paren_string.split(" ");         for (String group : groups) {             int level = 0;             for (int i = 0; i < group.length(); i++) {                 if (group.charAt(i) == '(') {                     level++;                 } else if (group.charAt(i) == ')') {                     level--;                 }             }             result.add((long)level);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given length of a side and high return area for a triangle.     // >>> triangleArea((5l), (3l))     // (7.5f)     public static float triangleArea(long a, long h) {         return (float) (0.5 * a * h);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Complete the function that takes two integers and returns      // the product of their unit digits.     // Assume the input is always valid.     // Examples:     // >>> multiply((148l), (412l))     // (16l)     // >>> multiply((19l), (28l))     // (72l)     // >>> multiply((2020l), (1851l))     // (0l)     // >>> multiply((14l), (-15l))     // (20l)     public static long multiply(long a, long b) {         return 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // For a given array list of input numbers, calculate Mean Absolute Deviation     // around the mean of this dataset.     // Mean Absolute Deviation is the average absolute difference between each     // element and a centerpoint (mean in this case):     // MAD = average | x - x_mean |     // >>> meanAbsoluteDeviation((new ArrayList<Float>(Arrays.asList((float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f))))     // (1.0f)     public static float meanAbsoluteDeviation(ArrayList<Float> numbers) {         float mean = 0.0f;         for (float number : numbers) {             mean += number;         }         mean /= numbers.size();         float mad = 0.0f;         for (float number : numbers) {             mad += Math.abs(number - mean);         }         mad /= numbers.size();         return mad;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return sorted unique common elements for two array lists.     // >>> common((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l, (long)34l, (long)653l, (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l, (long)7l, (long)1l, (long)5l, (long)9l, (long)653l, (long)121l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)653l)))     // >>> common((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))     public static ArrayList<Long> common(ArrayList<Long> l1, ArrayList<Long> l2) {         HashSet<Long> hs = new HashSet<Long>();         hs.addAll(l1);         hs.retainAll(l2);         return new ArrayList<Long>(hs);
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a positive integer, obtain its roman numeral equivalent as a string,     // and return it in lowercase.     // Restrictions: 1 <= num <= 1000     // Examples:     // >>> intToMiniRoman((19l))     // ("xix")     // >>> intToMiniRoman((152l))     // ("clii")     // >>> intToMiniRoman((426l))     // ("cdxxvi")     public static String intToMiniRoman(long number) {         if (number < 1 || number > 1000) {             throw new IllegalArgumentException();         }         StringBuilder sb = new StringBuilder();         while (number > 0) {             if (number >= 1000) {                 sb.append("m");                 number -= 1000;             } else if (number >= 900) {                 sb.append("cm");                 number -= 900;             } else if (number >= 500) {                 sb.append("d");                 number -= 500;             } else if (number >= 400) {                 sb.append("cd");                 number -= 400;             } else if (number >= 100) {                 sb.append("c");                 number -= 100;             } else if (number >= 90) {                 sb.append("xc");                 number -= 90;             } else if (number >= 50) {                 sb.append("l");                 number -= 50;             } else if (number >= 40) {                 sb.append("xl");                 number -= 40;             } else if (number >= 10) {                 sb.append("x");                 number -= 10;             } else if (number >= 9) {                 sb.append("ix");                 number -= 9;             } else if (number >= 5) {                 sb.append("v");                 number -= 5;             } else if (number >= 4) {                 sb.append("iv");                 number -= 4;             } else if (number >= 1) {                 sb.append("i");                 number -= 1;             }         }         return sb.toString().toLowerCase();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this task, you will be given a string that represents a number of apples and oranges      // that are distributed in a basket of fruit this basket contains      // apples, oranges, and mango fruits. Given the string that represents the total number of      // the oranges and apples and an integer that represent the total number of the fruits      // in the basket return the number of the mango fruits in the basket.     // for examble:     // >>> fruitDistribution(("5 apples and 6 oranges"), (19l))     // (8l)     // >>> fruitDistribution(("0 apples and 1 oranges"), (3l))     // (2l)     // >>> fruitDistribution(("2 apples and 3 oranges"), (100l))     // (95l)     // >>> fruitDistribution(("100 apples and 1 oranges"), (120l))     // (19l)     public static long fruitDistribution(String s, long n) {         String[] arr = s.split(" ");         long apples = Long.parseLong(arr[0]);         long oranges = Long.parseLong(arr[2]);         return n - apples - oranges;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Task     // We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c     // then check if the result string is palindrome.     // A string is called palindrome if it reads the same backward as forward.     // You should return a pair containing the result string and true/false for the check.     // Example     // >>> reverseDelete(("abcde"), ("ae"))     // (Pair.with("bcd", false))     // >>> reverseDelete(("abcdef"), ("b"))     // (Pair.with("acdef", false))     // >>> reverseDelete(("abcdedcba"), ("ab"))     // (Pair.with("cdedc", true))     public static Pair<String, Boolean> reverseDelete(String s, String c) {         StringBuilder sb = new StringBuilder();         for (int i = 0; i < s.length(); i++) {             if (c.indexOf(s.charAt(i)) == -1) {                 sb.append(s.charAt(i));             }         }         return Pair.with(sb.toString(), sb.toString().equals(sb.reverse().toString()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Return a greatest common divisor of two integers a and b     // >>> greatestCommonDivisor((3l), (5l))     // (1l)     // >>> greatestCommonDivisor((25l), (15l))     // (5l)     public static long greatestCommonDivisor(long a, long b) {         if (b == 0) {             return a;         } else {             return greatestCommonDivisor(b, a % b);         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // In this Kata, you have to sort an array array list of non-negative integers according to     // number of ones in their binary representation in ascending order.     // For similar number of ones, sort based on decimal value.     // It must be implemented like this:     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)-2l, (long)-3l, (long)-4l, (long)-5l, (long)-6l))))     // (new ArrayList<Long>(Arrays.asList((long)-6l, (long)-5l, (long)-4l, (long)-3l, (long)-2l)))     // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l, (long)0l, (long)2l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)0l, (long)1l, (long)2l, (long)3l, (long)4l)))     public static ArrayList<Long> sortArray(ArrayList<Long> arr) {         return arr.stream().sorted((a, b) -> {             int a1 = Long.toBinaryString(a).length() - Long.toBinaryString(a).replace("1", "").length();             int b1 = Long.toBinaryString(b).length() - Long.toBinaryString(b).replace("1", "").length();             if (a1 == b1) {                 return a.compareTo(b);             }             return a1 - b1;         }).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Concatenate array list of strings into a single string     // >>> concatenate((new ArrayList<String>(Arrays.asList())))     // ("")     // >>> concatenate((new ArrayList<String>(Arrays.asList((String)"a", (String)"b", (String)"c"))))     // ("abc")     public static String concatenate(ArrayList<String> strings) {         StringBuilder sb = new StringBuilder();         for (String s : strings) {             sb.append(s);         }         return sb.toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings as a parameter,     // deletes the strings that have odd lengths from it,     // and returns the resulted array list with a sorted order,     // The array list is always an array array list of strings and never an array array list of numbers,     // and it may contain duplicates.     // The order of the array list should be ascending by length of each word, and you     // should return the array list sorted by that rule.     // If two words have the same length, sort the array list alphabetically.     // The function should return an array array list of strings in sorted order.     // You may assume that all words will have the same length.     // For example:     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"aa", (String)"a", (String)"aaa"))))     // (new ArrayList<String>(Arrays.asList((String)"aa")))     // >>> listSort((new ArrayList<String>(Arrays.asList((String)"ab", (String)"a", (String)"aaa", (String)"cd"))))     // (new ArrayList<String>(Arrays.asList((String)"ab", (String)"cd")))     public static ArrayList<String> sortedListSum(ArrayList<String> lst) {         return lst.stream().filter(s -> s.length() % 2 == 0).sorted(Comparator.comparing(String::length).thenComparing(s -> s)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Filter an input array list of strings only for ones that contain given substring     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList())), ("a"))     // (new ArrayList<String>(Arrays.asList()))     // >>> filterBySubstring((new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"cde", (String)"array"))), ("a"))     // (new ArrayList<String>(Arrays.asList((String)"abc", (String)"bacd", (String)"array")))     public static ArrayList<String> filterBySubstring(ArrayList<String> strings, String substring) {         return strings.stream().filter(s -> s.contains(substring)).collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Create a function that takes a value (string) representing a number     // and returns the closest integer to it. If the number is equidistant     // from two integers, round it away from zero.     // Examples     // >>> closestInteger(("10"))     // (10l)     // >>> closestInteger(("15.3"))     // (15l)     // Note:     // Rounding away from zero means that if the given number is equidistant     // from two integers, the one you should return is the one that is the     // farthest from zero. For example closest_integer("14.5") should     // return 15 and closest_integer("-14.5") should return -15.     public static long closestInteger(String value) {         BigDecimal bd = new BigDecimal(value);         return bd.setScale(0, RoundingMode.HALF_UP).longValue();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function vowels_count which takes a string representing     // a word as input and returns the number of vowels in the string.     // Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a     // vowel, but only when it is at the end of the given word.     // Example:     // >>> vowelsCount(("abcde"))     // (2l)     // >>> vowelsCount(("ACEDY"))     // (3l)     public static long vowelsCount(String s) {         long count = 0;         for (int i = 0; i < s.length(); i++) {             if (s.charAt(i) == 'a' || s.charAt(i) == 'e' || s.charAt(i) == 'i' || s.charAt(i) == 'o' || s.charAt(i) == 'u') {                 count++;             }             if (s.charAt(i) == 'y' && i == s.length() - 1) {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that accepts an array array list of strings.     // The array list contains different words. Return the word with maximum number     // of unique characters. If multiple strings have maximum number of unique     // characters, return the one which comes first in lexicographical order.     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"of", (String)"string"))))     // ("string")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"name", (String)"enam", (String)"game"))))     // ("enam")     // >>> findMax((new ArrayList<String>(Arrays.asList((String)"aaaaaaa", (String)"bb", (String)"cc"))))     // ("aaaaaaa")     public static String findMax(ArrayList<String> words) {         Map<String, Integer> map = new HashMap<>();         for (String word : words) {             Set<Character> set = new HashSet<>();             for (char c : word.toCharArray()) {                 set.add(c);             }             map.put(word, set.size());         }         int max = Collections.max(map.values());         return Collections.min(map.entrySet().stream().filter(e -> e.getValue() == max).map(Map.Entry::getKey).collect(Collectors.toSet()));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given a string 'text', return its md5 hash equivalent string.     // If 'text' is an empty string, return null.     // >>> stringToMd5(("Hello world"))     // Optional.of("3e25960a79dbc69b674cd4ec67a72c62")     public static Optional<String> stringToMd5(String text) {         if (text.isEmpty()) {             return Optional.empty();         }         try {             MessageDigest md = MessageDigest.getInstance("MD5");             md.update(text.getBytes());             byte[] digest = md.digest();             StringBuffer sb = new StringBuffer();             for (int i = 0; i < digest.length; i++) {                 sb.append(Integer.toHexString(0xff & digest[i]));             }             return Optional.of(sb.toString());         } catch (NoSuchAlgorithmException e) {             return Optional.empty();         }
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Change numerical base of input number x to base.     // return string representation after the conversion.     // base numbers are less than 10.     // >>> changeBase((8l), (3l))     // ("22")     // >>> changeBase((8l), (2l))     // ("1000")     // >>> changeBase((7l), (2l))     // ("111")     public static String changeBase(long x, long base) {         if (x == 0) {             return "0";         }         StringBuilder sb = new StringBuilder();         while (x > 0) {             sb.append(x % base);             x /= base;         }         return sb.reverse().toString();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given the lengths of the three sides of a triangle. Return true if the three     // sides form a right-angled triangle, false otherwise.     // A right-angled triangle is a triangle in which one angle is right angle or      // 90 degree.     // Example:     // >>> rightAngleTriangle((3l), (4l), (5l))     // (true)     // >>> rightAngleTriangle((1l), (2l), (3l))     // (false)     public static boolean rightAngleTriangle(long a, long b, long c) {         return a * a + b * b == c * c || a * a + c * c == b * b || b * b + c * c == a * a;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // It is the last week of the semester and the teacher has to give the grades     // to students. The teacher has been making her own algorithm for grading.     // The only problem is, she has lost the code she used for grading.     // She has given you an array array list of GPAs for some students and you have to write      // a function that can output an array array list of letter grades using the following table:     // GPA       |    Letter grade     // 4.0                A+     // > 3.7                A      // > 3.3                A-      // > 3.0                B+     // > 2.7                B      // > 2.3                B-     // > 2.0                C+     // > 1.7                C     // > 1.3                C-     // > 1.0                D+      // > 0.7                D      // > 0.0                D-     // 0.0                E     // Example:     // >>> gradeEquation((new ArrayList<Float>(Arrays.asList((float)4.0f, (float)3l, (float)1.7f, (float)2l, (float)3.5f))))     // (new ArrayList<String>(Arrays.asList((String)"A+", (String)"B", (String)"C-", (String)"C", (String)"A-")))     public static ArrayList<String> numericalLetterGrade(ArrayList<Float> grades) {         ArrayList<String> letterGrade = new ArrayList<String>();         for(int i = 0; i < grades.size(); i++) {             if(grades.get(i) >= 4.0) {                 letterGrade.add("A+");             }             else if(grades.get(i) >= 3.7) {                 letterGrade.add("A");             }             else if(grades.get(i) >= 3.3) {                 letterGrade.add("A-");             }             else if(grades.get(i) >= 3.0) {                 letterGrade.add("B+");             }             else if(grades.get(i) >= 2.7) {                 letterGrade.add("B");             }             else if(grades.get(i) >= 2.3) {                 letterGrade.add("B-");             }             else if(grades.get(i) >= 2.0) {                 letterGrade.add("C+");             }             else if(grades.get(i) >= 1.7) {                 letterGrade.add("C");             }             else if(grades.get(i) >= 1.3) {                 letterGrade.add("C-");             }             else if(grades.get(i) >= 1.0) {                 letterGrade.add("D+");             }             else if(grades.get(i) >= 0.7) {                 letterGrade.add("D");             }             else if(grades.get(i) >= 0.0) {                 letterGrade.add("D-");             }             else {                 letterGrade.add("E");             }         }         return letterGrade;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Insert a number 'delimeter' between every two consecutive elements of input array list `numbers'     // >>> intersperse((new ArrayList<Long>(Arrays.asList())), (4l))     // (new ArrayList<Long>(Arrays.asList()))     // >>> intersperse((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))), (4l))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)2l, (long)4l, (long)3l)))     public static ArrayList<Long> intersperse(ArrayList<Long> numbers, long delimeter) {         ArrayList<Long> result = new ArrayList<Long>();         for (int i = 0; i < numbers.size() - 1; i++) {             result.add(numbers.get(i));             result.add(delimeter);         }         result.add(numbers.get(numbers.size() - 1));         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Write a function that takes an array array list of numbers as input and returns      // the number of elements in the array array list that are greater than 10 and both      // first and last digits of a number are odd (1, 3, 5, 7, 9).     // For example:     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)15l, (long)-73l, (long)14l, (long)-15l))))     // (1l)     // >>> specialFilter((new ArrayList<Long>(Arrays.asList((long)33l, (long)-2l, (long)-3l, (long)45l, (long)21l, (long)109l))))     // (2l)     public static long specialFilter(ArrayList<Long> nums) {         long count = 0;         for (long num : nums) {             if (num > 10 && (num % 10) % 2 != 0 && (num / 10) % 2 != 0) {                 count++;             }         }         return count;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // sum_to_n is a function that sums numbers from 1 to n.     // >>> sumToN((30l))     // (465l)     // >>> sumToN((100l))     // (5050l)     // >>> sumToN((5l))     // (15l)     // >>> sumToN((10l))     // (55l)     // >>> sumToN((1l))     // (1l)     public static long sumToN(long n) {         long sum = 0;         for (long i = 1; i <= n; i++) {             sum += i;         }         return sum;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From an array array list of integers, remove all elements that occur more than once.     // Keep order of elements left the same as in the input.     // >>> removeDuplicates((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)4l)))     public static ArrayList<Long> removeDuplicates(ArrayList<Long> numbers) {         return numbers.stream().distinct().collect(Collectors.toCollection(ArrayList::new));
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Given two positive integers a and b, return the even digits between a     // and b, in ascending order.     // For example:     // >>> generateIntegers((2l), (8l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((8l), (2l))     // (new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)6l, (long)8l)))     // >>> generateIntegers((10l), (14l))     // (new ArrayList<Long>(Arrays.asList()))     public static ArrayList<Long> generateIntegers(long a, long b) {         ArrayList<Long> result = new ArrayList<Long>();         for (long i = a; i <= b; i++) {             for (int j = 0; j < String.valueOf(i).length(); j++) {                 if (String.valueOf(i).charAt(j) % 2 == 0) {                     result.add(i);                     break;                 }             }         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // From a given array list of integers, generate an array array list of rolling maximum element found until given moment     // in the sequence.     // >>> rollingMax((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)2l, (long)3l, (long)4l, (long)2l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l)))     public static ArrayList<Long> rollingMax(ArrayList<Long> numbers) {         ArrayList<Long> result = new ArrayList<Long>();         for (int i = 0; i < numbers.size(); i++) {             long max = numbers.get(i);             for (int j = i + 1; j < numbers.size(); j++) {                 if (numbers.get(j) > max) {                     max = numbers.get(j);                 }             }             result.add(max);         }         return result;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You're given an array array list of deposit and withdrawal operations on a bank account that starts with     // zero balance. Your task is to detect if at any point the balance of account fallls below zero, and     // at that point function should return true. Otherwise it should return false.     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (false)     // >>> belowZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)-4l, (long)5l))))     // (true)     public static boolean belowZero(ArrayList<Long> operations) {         long balance = 0;         for (Long operation : operations) {             balance += operation;             if (balance < 0) {                 return true;             }         }         return false;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // You are given a non-empty array list of positive integers. Return the greatest integer that is greater than      // zero, and has a frequency greater than or equal to the value of the integer itself.      // The frequency of an integer is the number of times it appears in the array list.     // If no such a value exist, return -1.     // Examples:     // >>> search((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l, (long)2l, (long)2l, (long)3l, (long)1l))))     // (2l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l, (long)3l, (long)3l, (long)4l, (long)4l, (long)4l))))     // (3l)     // >>> search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)4l, (long)4l, (long)4l))))     // (-1l)     public static long search(ArrayList<Long> lst) {         HashMap<Long, Long> map = new HashMap<Long, Long>();         for (long i : lst) {             if (map.containsKey(i)) {                 map.put(i, map.get(i) + 1);             } else {                 map.put(i, 1l);             }         }         for (long key : map.keySet()) {             if (map.get(key) >= key) {                 return key;             }         }         return -1l;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "(" and ")".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("("))     // (false)     // >>> correctBracketing(("()"))     // (true)     // >>> correctBracketing(("(()())"))     // (true)     // >>> correctBracketing((")(()"))     // (false)     public static boolean correctBracketing(String brackets) {         int count = 0;         for (int i = 0; i < brackets.length(); i++) {             if (brackets.charAt(i) == '(') {                 count++;             } else if (brackets.charAt(i) == ')') {                 count--;             }             if (count < 0) {                 return false;             }         }         return count == 0;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // This function takes an array array list l and returns an array array list l' such that     // l' is identical to l in the odd indicies, while its values at the even indicies are equal     // to the values of the even indicies of l, but sorted.     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l))))     // (new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l)))     // >>> sortEven((new ArrayList<Long>(Arrays.asList((long)5l, (long)6l, (long)3l, (long)4l))))     // (new ArrayList<Long>(Arrays.asList((long)3l, (long)6l, (long)5l, (long)4l)))     public static ArrayList<Long> sortEven(ArrayList<Long> l) {         ArrayList<Long> sorted = new ArrayList<Long>();         for (int i = 0; i < l.size(); i++) {             if (i % 2 == 0) {                 sorted.add(l.get(i));             }         }         for (int i = 0; i < l.size(); i++) {             if (i % 2 == 1) {                 sorted.add(l.get(i));             }         }         Collections.sort(sorted);         return sorted;
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // Check if two words have the same characters.     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddeddabc"))     // (true)     // >>> sameChars(("abcd"), ("dddddddabc"))     // (true)     // >>> sameChars(("dddddddabc"), ("abcd"))     // (true)     // >>> sameChars(("eabcd"), ("dddddddabc"))     // (false)     // >>> sameChars(("abcd"), ("dddddddabce"))     // (false)     // >>> sameChars(("eabcdzzzz"), ("dddzzzzzzzddddabc"))     // (false)     public static boolean sameChars(String s0, String s1) {         return s0.chars().distinct().count() == s1.chars().distinct().count();
import java.util.*; import java.lang.reflect.*; import org.javatuples.*; import java.security.*; import java.math.*; import java.io.*; import java.util.stream.*; class Problem {     // brackets is a string of "<" and ">".     // return true if every opening bracket has a corresponding closing bracket.     // >>> correctBracketing(("<"))     // (false)     // >>> correctBracketing(("<>"))     // (true)     // >>> correctBracketing(("<<><>>"))     // (true)     // >>> correctBracketing(("><<>"))     // (false)     public static boolean correctBracketing(String brackets) {         Stack<Character> stack = new Stack<>();         for (int i = 0; i < brackets.length(); i++) {             if (brackets.charAt(i) == '<') {                 stack.push('<');             } else {                 if (stack.isEmpty()) {                     return false;                 } else {                     stack.pop();                 }             }         }         return stack.isEmpty();
