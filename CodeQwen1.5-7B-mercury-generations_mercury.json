[["class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        \n        while matrix:\n            ans += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    ans.append(row.pop())\n            if matrix:\n                ans += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    ans.append(row.pop(0))\n        return ans\n", "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        while matrix:\n            ans += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    ans.append(row.pop())\n            if matrix:\n                ans += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    ans.append(row.pop(0))\n        return ans\n", "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        \n        while matrix:\n            ans += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    ans.append(row.pop())\n            if matrix:\n                ans += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    ans.append(row.pop(0))\n        \n        return ans\n", "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        \n        while matrix:\n            ans += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    ans.append(row.pop())\n            if matrix:\n                ans += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    ans.append(row.pop(0))\n        return ans\n\n", "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        while matrix:\n            ans += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    ans.append(row.pop())\n            if matrix:\n                ans += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    ans.append(row.pop(0))\n        return ans"], ["class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        i = 0\n        while i < len(nums):\n            start = nums[i]\n            while i + 1 < len(nums) and nums[i + 1] == nums[i] + 1:\n                i += 1\n            end = nums[i]\n            if start == end:\n                ans.append(str(start))\n            else:\n                ans.append(str(start) + \"->\" + str(end))\n            i += 1\n        return ans\n", "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(nums):\n            start = nums[i]\n            while i < len(nums) - 1 and nums[i] + 1 == nums[i + 1]:\n                i += 1\n            if start != nums[i]:\n                res.append(str(start) + \"->\" + str(nums[i]))\n            else:\n                res.append(str(start))\n            i += 1\n        return res", "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        i = 0\n        while i < len(nums):\n            j = i + 1\n            while j < len(nums) and nums[j] == nums[j - 1] + 1:\n                j += 1\n            if j - i > 1:\n                ans.append(f\"{nums[i]}->{nums[j - 1]}\")\n            else:\n                ans.append(f\"{nums[i]}\")\n            i = j\n        return ans", "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(nums):\n            start = nums[i]\n            while i + 1 < len(nums) and nums[i] + 1 == nums[i + 1]:\n                i += 1\n            if start != nums[i]:\n                res.append(str(start) + \"->\" + str(nums[i]))\n            else:\n                res.append(str(start))\n            i += 1\n        return res", "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        ranges = []\n        start = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1] + 1:\n                if start == nums[i - 1]:\n                    ranges.append(str(start))\n                else:\n                    ranges.append(str(start) + \"->\" + str(nums[i - 1]))\n                start = nums[i]\n        \n        if start == nums[-1]:\n            ranges.append(str(start))\n        else:\n            ranges.append(str(start) + \"->\" + str(nums[-1]))\n        \n        return ranges\n\n"], ["class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        m = len(t)\n        \n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[n][m]", "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(s)\n        n = len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n]\n", "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(s)\n        n = len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[m][n]\n", "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(s)\n        n = len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n]\n", "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(s)\n        n = len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n]\n"], ["class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        \n        if 1 not in nums:\n            return 1\n        \n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1] + 1:\n                return nums[i - 1] + 1\n        \n        return nums[-1] + 1", "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1\n", "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1", "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        \n        i = 1\n        \n        for num in nums:\n            if num == i:\n                i += 1\n                \n        return i", "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1"], ["class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        nums = list(range(1, n + 1))\n        k -= 1\n        ans = []\n        while n > 0:\n            n -= 1\n            i, k = divmod(k, math.factorial(n))\n            ans.append(str(nums[i]))\n            nums.pop(i)\n        return ''.join(ans)", "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        def factorial(n):\n            if n == 0:\n                return 1\n            return n * factorial(n - 1)\n        \n        def get_permutation(n, k):\n            if n == 1:\n                return [1]\n            \n            fact = factorial(n - 1)\n            idx = (k - 1) // fact\n            \n            res = [i + 1 for i in range(n)]\n            res.pop(idx)\n            \n            return [res[idx]] + get_permutation(n - 1, k - idx * fact)\n        \n        return ''.join(map(str, get_permutation(n, k)))\n", "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        nums = list(range(1, n + 1))\n        k -= 1\n        ans = []\n        while n > 0:\n            n -= 1\n            i, k = divmod(k, math.factorial(n))\n            ans.append(str(nums[i]))\n            nums.pop(i)\n        return ''.join(ans)", "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        nums = [i for i in range(1, n + 1)]\n        ans = []\n        k -= 1\n        while n > 0:\n            n -= 1\n            i, k = divmod(k, math.factorial(n))\n            ans.append(str(nums.pop(i)))\n        return ''.join(ans)\n", "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        def factorial(n):\n            if n == 1:\n                return 1\n            return n * factorial(n - 1)\n        \n        def get_permutation(n, k):\n            if n == 1:\n                return str(k)\n            \n            f = factorial(n - 1)\n            i = k / f\n            return str(i) + get_permutation(n - 1, k % f)\n        \n        return get_permutation(n, k)"], ["class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        i = 0\n        j = len(numbers) - 1\n        while i < j:\n            if numbers[i] + numbers[j] == target:\n                return [i + 1, j + 1]\n            elif numbers[i] + numbers[j] > target:\n                j -= 1\n            else:\n                i += 1\n        return []", "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            elif s < target:\n                l += 1\n            else:\n                r -= 1", "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        i = 0\n        j = len(numbers) - 1\n        while i < j:\n            if numbers[i] + numbers[j] == target:\n                return [i + 1, j + 1]\n            elif numbers[i] + numbers[j] < target:\n                i += 1\n            else:\n                j -= 1\n        return [-1, -1]", "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            elif s < target:\n                l += 1\n            else:\n                r -= 1", "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        i = 0\n        j = len(numbers) - 1\n        while i < j:\n            if numbers[i] + numbers[j] == target:\n                return [i + 1, j + 1]\n            elif numbers[i] + numbers[j] > target:\n                j -= 1\n            else:\n                i += 1\n        return []"], ["class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, expr, val, prev):\n            if not num:\n                if val == target and expr == path:\n                    res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                cur = num[:i]\n                if i > 1 and cur[0] == '0':\n                    continue\n                if path:\n                    dfs(num[i:], target, path + '+' + cur, res, expr + '+' + cur, val + int(cur), int(cur))\n                    dfs(num[i:], target, path + '-' + cur, res, expr + '-' + cur, val - int(cur), -int(cur))\n                    dfs(num[i:], target, path + '*' + cur, res, expr + '*' + cur, val - prev + prev * int(cur), prev * int(cur))\n                else:\n                    dfs(num[i:], target, cur, res, cur, int(cur), int(cur))\n        \n        res = []\n        dfs(num, target, '', res, '', 0, 0)\n        return res", "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, cur, pre):\n            if not num:\n                if target == cur:\n                    res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                if i != 1 and num[0] == '0':\n                    break\n                val = int(num[:i])\n                if path == '':\n                    dfs(num[i:], target, path + str(val), res, val, val)\n                else:\n                    dfs(num[i:], target, path + '+' + str(val), res, cur + val, val)\n                    dfs(num[i:], target, path + '-' + str(val), res, cur - val, -val)\n                    dfs(num[i:], target, path + '*' + str(val), res, cur - pre + pre * val, pre * val)\n        \n        res = []\n        dfs(num, target, '', res, 0, 0)\n        return res", "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, prev, curr, res, path):\n            if i == len(num):\n                if curr == target:\n                    res.append(path)\n                return\n            for j in range(i + 1, len(num) + 1):\n                if i == 0:\n                    dfs(j, int(num[i:j]), int(num[i:j]), res, path + num[i:j])\n                else:\n                    dfs(j, prev * int(num[i:j]), curr - prev + prev * int(num[i:j]), res, path + \"*\" + num[i:j])\n                    dfs(j, -int(num[i:j]), curr - prev + int(num[i:j]), res, path + \"-\" + num[i:j])\n                    dfs(j, int(num[i:j]), curr - prev + int(num[i:j]), res, path + \"+\" + num[i:j])\n        res = []\n        dfs(0, 0, 0, res, \"\")\n        return res", "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, val, pre):\n            if not num:\n                if val == target:\n                    res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                cur = num[:i]\n                if i == 1 or (i > 1 and num[0] != '0'):\n                    dfs(num[i:], target, path + '+' + cur if path else cur, res, val + int(cur), int(cur))\n                    dfs(num[i:], target, path + '-' + cur if path else '-' + cur, res, val - int(cur), -int(cur))\n                    dfs(num[i:], target, path + '*' + cur if path else cur, res, (val - pre) + pre * int(cur), pre * int(cur))\n        \n        res = []\n        dfs(num, target, '', res, 0, 0)\n        return res", "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, prev, curr, res, path):\n            if i == len(num):\n                if curr == target:\n                    res.append(path)\n                return\n            for j in range(i + 1, len(num) + 1):\n                if j > i + 1 and num[i] == '0':\n                    break\n                curr_num = int(num[i:j])\n                if i == 0:\n                    dfs(j, curr_num, curr_num, res, path + str(curr_num))\n                else:\n                    dfs(j, curr_num, curr + curr_num, res, path + \"+\" + str(curr_num))\n                    dfs(j, -curr_num, curr - curr_num, res, path + \"-\" + str(curr_num))\n                    dfs(j, prev * curr_num, (curr - prev) + prev * curr_num, res, path + \"*\" + str(curr_num))\n        \n        res = []\n        dfs(0, 0, 0, res, \"\")\n        return res"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        s = s.upper().replace('-', '')\n        n = len(s)\n        ans = []\n        for i in range(n - 1, -1, -k):\n            ans.append(s[max(i - k + 1, 0):i + 1])\n        return '-'.join(reversed(ans))", "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.upper()\n        s = s.replace('-', '')\n        \n        n = len(s)\n        \n        if n <= k:\n            return s\n        \n        ans = ''\n        \n        for i in range(n - 1, -1, -1):\n            if i % k == 0:\n                ans += '-'\n            ans += s[i]\n        \n        return ans[::-1]", "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.upper()\n        s = s.replace('-', '')\n        \n        n = len(s)\n        \n        if n <= k:\n            return s\n        \n        ans = ''\n        \n        for i in range(n):\n            if i % k == 0 and i != 0:\n                ans += '-'\n            ans += s[i]\n            \n        return ans\n", "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        \n        if len(s) % k == 0:\n            return '-'.join([s[i:i+k] for i in range(0, len(s), k)])\n        else:\n            return '-'.join([s[i:i+k] for i in range(0, len(s) - len(s) % k, k)]) + '-' + s[-len(s) % k:]\n", "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        s = s.upper().replace('-', '')\n        n = len(s)\n        ans = []\n        for i in range(n - 1, -1, -k):\n            ans.append(s[max(i - k + 1, 0):i + 1])\n        return '-'.join(reversed(ans))\n\n"], ["class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        for i in range(n):\n            tank = 0\n            for j in range(i, i + n):\n                tank += gas[j % n] - cost[j % n]\n                if tank < 0:\n                    break\n            if tank >= 0:\n                return i\n        return -1\n", "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        for i in range(n):\n            tank = 0\n            for j in range(i, i + n):\n                k = j % n\n                tank += gas[k] - cost[k]\n                if tank < 0:\n                    break\n            else:\n                return i\n        return -1", "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        for i in range(n):\n            tank = 0\n            for j in range(i, i + n):\n                k = j % n\n                tank += gas[k] - cost[k]\n                if tank < 0:\n                    break\n            else:\n                return i\n        return -1", "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        for i in range(n):\n            if gas[i] < cost[i]:\n                continue\n            \n            tank = gas[i] - cost[i]\n            j = i + 1\n            while j < n + i:\n                tank += gas[j % n] - cost[j % n]\n                if tank < 0:\n                    break\n                j += 1\n            if j == n + i:\n                return i\n        return -1", "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        total_tank, curr_tank = 0, 0\n        starting_station = 0\n        for i in range(n):\n            total_tank += gas[i] - cost[i]\n            curr_tank += gas[i] - cost[i]\n            # If one couldn't get here,\n            if curr_tank < 0:\n                # Pick up the next station as the starting one.\n                starting_station = i + 1\n                # Start with an empty tank.\n                curr_tank = 0\n        return starting_station if total_tank >= 0 else -1"], ["class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n        nums = [1] + nums + [1]\n        \n        for i in range(n, -1, -1):\n            for j in range(i + 1, n + 2):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n + 1]", "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n        nums = [1] + nums + [1]\n        \n        for i in range(n, -1, -1):\n            for j in range(i + 1, n + 2):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n + 1]", "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        nums = [1] + nums + [1]\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n        \n        for i in range(n, -1, -1):\n            for j in range(i + 1, n + 1):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n]", "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(3, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]", "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n        nums = [1] + nums + [1]\n        for i in range(n, -1, -1):\n            for j in range(i + 1, n + 2):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        return dp[0][n + 1]"], ["class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        \n        digits.insert(0, 1)\n        return digits", "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits\n", "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits\n", "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits\n", "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        digits.insert(0, 1)\n        return digits\n"], ["class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        m = len(s)\n        n = len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (i > 0 and dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n                else:\n                    dp[i][j] = i > 0 and dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')\n        return dp[m][n]\n\n", "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (i > 0 and (s[i - 1] == p[j - 2] or p[j - 2] == '.') and dp[i - 1][j])\n                else:\n                    dp[i][j] = i > 0 and dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')\n        return dp[m][n]\n", "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (i > 0 and (s[i - 1] == p[j - 2] or p[j - 2] == '.') and dp[i - 1][j])\n                else:\n                    dp[i][j] = i > 0 and dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')\n        return dp[m][n]\n", "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i][j] = True if s[:i] matches p[:j]\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        \n        # Empty string matches empty pattern\n        dp[0][0] = True\n        \n        # Handle patterns with '*' at the beginning\n        for j in range(1, len(p)):\n            if p[j] == '*':\n                dp[0][j + 1] = dp[0][j - 1]\n        \n        # Fill the DP table\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == '.' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n        \n        return dp[-1][-1]"], ["class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def max_array(nums, k):\n            drop = len(nums) - k\n            stack = []\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                bigger = a if a > b else b\n                ans.append(bigger[0])\n                bigger.pop(0)\n            return ans\n        \n        ans = []\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            candidate = merge(max_array(nums1, i), max_array(nums2, k - i))\n            if candidate > ans:\n                ans = candidate\n        return ans", "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                bigger = a if a > b else b\n                ans.append(bigger[0])\n                bigger.pop(0)\n            return ans\n        \n        ans = []\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            ans = max(ans, merge(pick(nums1, i), pick(nums2, k - i)))\n        return ans", "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def getMax(nums, k):\n            drop = len(nums) - k\n            drop_stack = []\n            for num in nums:\n                while drop and drop_stack and drop_stack[-1] < num:\n                    drop_stack.pop()\n                    drop -= 1\n                drop_stack.append(num)\n            return drop_stack[:k]\n        \n        def merge(nums1, nums2):\n            merged = []\n            while nums1 or nums2:\n                bigger = nums1 if nums1 > nums2 else nums2\n                merged.append(bigger[0])\n                bigger.pop(0)\n            return merged\n        \n        max_num = []\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            max_num = max(max_num, merge(getMax(nums1, i), getMax(nums2, k - i)))\n        return max_num", "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                bigger = a if a > b else b\n                ans.append(bigger[0])\n                bigger.pop(0)\n            return ans\n        \n        ans = []\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            ans = max(ans, merge(pick(nums1, i), pick(nums2, k - i)))\n        return ans", "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def max_array(nums, k):\n            drop = len(nums) - k\n            stack = []\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                bigger = a if a > b else b\n                ans.append(bigger[0])\n                bigger.pop(0)\n            return ans\n        \n        ans = []\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            candidate = merge(max_array(nums1, i), max_array(nums2, k - i))\n            if candidate > ans:\n                ans = candidate\n        return ans"], ["class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i != num // i:\n                    divisors.append(num // i)\n        \n        return sum(divisors) == num", "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i != num // i:\n                    divisors.append(num // i)\n        \n        return sum(divisors) == num", "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                sum += i\n                if i * i != num:\n                    sum += num / i\n            i += 1\n        \n        return sum == num", "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                sum += i\n                if i != num // i:\n                    sum += num // i\n        return sum == num", "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i != num // i:\n                    divisors.append(num // i)\n        \n        return sum(divisors) == num"], ["class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 1:\n            return n\n        \n        a, b = 0, 1\n        for i in range(2, n + 1):\n            a, b = b, a + b\n        \n        return b\n", "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n - 1) + self.fib(n - 2)\n", "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n - 1) + self.fib(n - 2)\n", "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 1:\n            return n\n        return self.fib(n - 1) + self.fib(n - 2)", "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 1:\n            return n\n        else:\n            return self.fib(n - 1) + self.fib(n - 2)\n"], ["class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n        \n        for i in range(m - 2, -1, -1):\n            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1])\n        \n        for j in range(n - 2, -1, -1):\n            dp[m - 1][j] = max(1, dp[m - 1][j + 1] - dungeon[m - 1][j])\n        \n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n        \n        return dp[0][0]", "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\n        \n        for i in range(m - 2, -1, -1):\n            dp[i][-1] = max(1, dp[i + 1][-1] - dungeon[i][-1])\n            \n        for j in range(n - 2, -1, -1):\n            dp[-1][j] = max(1, dp[-1][j + 1] - dungeon[-1][j])\n            \n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n                \n        return dp[0][0]\n", "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n        \n        for i in range(m - 2, -1, -1):\n            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1])\n            \n        for j in range(n - 2, -1, -1):\n            dp[m - 1][j] = max(1, dp[m - 1][j + 1] - dungeon[m - 1][j])\n            \n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n                \n        return dp[0][0]\n", "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n        \n        for i in range(m - 2, -1, -1):\n            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1])\n        \n        for j in range(n - 2, -1, -1):\n            dp[m - 1][j] = max(1, dp[m - 1][j + 1] - dungeon[m - 1][j])\n        \n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n        \n        return dp[0][0]\n", "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\n        \n        for i in range(m - 2, -1, -1):\n            dp[i][-1] = max(1, dp[i + 1][-1] - dungeon[i][-1])\n            \n        for j in range(n - 2, -1, -1):\n            dp[-1][j] = max(1, dp[-1][j + 1] - dungeon[-1][j])\n            \n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n                \n        return dp[0][0]"], ["class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        def count(d):\n            cnt = i = 0\n            for j in range(1, n):\n                while nums[j] - nums[i] > d:\n                    i += 1\n                cnt += j - i\n            return cnt\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if count(mi) < k:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo", "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(nums, mid):\n            count = 0\n            for i in range(len(nums)):\n                for j in range(i + 1, len(nums)):\n                    if nums[j] - nums[i] <= mid:\n                        count += 1\n            return count\n        \n        nums.sort()\n        left = 0\n        right = nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if count(nums, mid) >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l = 0\n        r = nums[-1] - nums[0]\n        \n        while l < r:\n            mid = (l + r) // 2\n            count = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l", "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"], ["class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.split())\n", "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())\n", "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.split())\n", "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.split())\n", "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.split())\n"], ["class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set('aeiouAEIOU')\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        return ''.join(s)\n", "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] not in vowels:\n                i += 1\n            elif s[j] not in vowels:\n                j -= 1\n            else:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        return ''.join(s)\n", "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = set('aeiouAEIOU')\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        return ''.join(s)\n", "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] not in vowels:\n                i += 1\n            elif s[j] not in vowels:\n                j -= 1\n            else:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        return ''.join(s)\n", "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = set('aeiouAEIOU')\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        return ''.join(s)\n"], ["class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for n in nums:\n            if n - 1 not in nums:\n                length = 0\n                while n + length in nums:\n                    length += 1\n                longest = max(longest, length)\n        return longest\n", "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for n in nums:\n            if n - 1 not in nums:\n                length = 1\n                while n + length in nums:\n                    length += 1\n                longest = max(longest, length)\n        return longest", "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        nums = set(nums)\n        longest = 0\n        \n        for n in nums:\n            if n - 1 not in nums:\n                length = 1\n                while n + length in nums:\n                    length += 1\n                longest = max(longest, length)\n        \n        return longest", "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for n in nums:\n            if n - 1 not in nums:\n                length = 1\n                while n + length in nums:\n                    length += 1\n                longest = max(longest, length)\n        \n        return longest", "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = set(nums)\n        longest = 0\n        \n        for n in nums:\n            if n - 1 not in nums:\n                length = 0\n                while n + length in nums:\n                    length += 1\n                longest = max(longest, length)\n        return longest"], ["class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        return n * (n + 1) / 2 - sum(nums)", "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        return n * (n + 1) / 2 - sum(nums)\n", "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        return n * (n + 1) / 2 - sum(nums)\n", "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        total = n * (n + 1) / 2\n        return total - sum(nums)\n", "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        \n        # XOR all the numbers from 0 to n\n        xor_full = reduce(xor, range(n + 1))\n        \n        # XOR all the numbers in the array\n        xor_array = reduce(xor, nums)\n        \n        # The missing number is the XOR of the two results\n        return xor_full ^ xor_array"], ["class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        \n        queue = collections.deque([(beginWord, 1)])\n        \n        while queue:\n            word, length = queue.popleft()\n            \n            if word == endWord:\n                return length\n            \n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append((next_word, length + 1))\n        \n        return 0", "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        q = collections.deque([(beginWord, 1)])\n        \n        while q:\n            word, length = q.popleft()\n            \n            if word == endWord:\n                return length\n            \n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        q.append((next_word, length + 1))\n        \n        return 0", "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        \n        queue = [(beginWord, 1)]\n        \n        while queue:\n            word, level = queue.pop(0)\n            \n            if word == endWord:\n                return level\n            \n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordList:\n                        queue.append((new_word, level + 1))\n                        wordList.remove(new_word)\n        \n        return 0\n", "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return 0\n        \n        queue = [(beginWord, 1)]\n        while queue:\n            word, length = queue.pop(0)\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        queue.append((next_word, length + 1))\n                        wordList.remove(next_word)\n        return 0\n", "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        \n        q = collections.deque([(beginWord, 1)])\n        \n        while q:\n            word, level = q.popleft()\n            \n            if word == endWord:\n                return level\n            \n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        q.append((next_word, level + 1))\n        \n        return 0"], ["class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        ans = \"\"\n        i, j = len(a) - 1, len(b) - 1\n        carry = 0\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(a[i])\n                i -= 1\n            if j >= 0:\n                carry += int(b[j])\n                j -= 1\n            ans += str(carry % 2)\n            carry //= 2\n        return ans[::-1]\n", "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        \n        return bin(a + b)[2:]", "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        return bin(int(a, 2) + int(b, 2))[2:]\n", "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        return bin(a + b)[2:]", "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        \n        return bin(a + b)[2:]"], ["class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target, findStartIndex):\n            ans = -1\n            l, r = 0, len(nums) - 1\n            while l <= r:\n                mid = (l + r) // 2\n                if nums[mid] > target:\n                    r = mid - 1\n                elif nums[mid] < target:\n                    l = mid + 1\n                else:\n                    ans = mid\n                    if findStartIndex:\n                        r = mid - 1\n                    else:\n                        l = mid + 1\n            return ans\n        \n        return [binarySearch(nums, target, True), binarySearch(nums, target, False)]\n", "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left_bound):\n            l, r = 0, len(nums) - 1\n            idx = -1\n            while l <= r:\n                mid = (l + r) // 2\n                if nums[mid] > target or (left_bound and target == nums[mid]):\n                    r = mid - 1\n                else:\n                    l = mid + 1\n                    idx = mid\n            return idx\n        \n        return [binary_search(nums, target, True), binary_search(nums, target, False)]\n", "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_start_index):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    index = mid\n                    if find_start_index:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return index\n        \n        start_index = binary_search(nums, target, True)\n        end_index = binary_search(nums, target, False)\n        \n        return [start_index, end_index]\n", "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_first):\n            left, right = 0, len(nums) - 1\n            result = -1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    result = mid\n                    if find_first:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return result\n        \n        first_index = binary_search(nums, target, True)\n        last_index = binary_search(nums, target, False)\n        \n        return [first_index, last_index]\n", "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target, left):\n            lo, hi = 0, len(nums)\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if nums[mid] > target or (left and target == nums[mid]):\n                    hi = mid\n                else:\n                    lo = mid + 1\n            return lo\n        \n        leftIdx = binarySearch(nums, target, True)\n        if leftIdx == len(nums) or nums[leftIdx] != target:\n            return [-1, -1]\n        \n        rightIdx = binarySearch(nums, target, False) - 1\n        return [leftIdx, rightIdx]\n"], ["class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[i] != nums[j]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1\n", "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[i] != nums[j]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1\n", "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1", "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[i] != nums[j]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1\n", "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1\n"], ["class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        jumps = 0\n        left = 0\n        right = 0\n        \n        while right < n - 1:\n            maxJump = 0\n            for i in range(left, right + 1):\n                maxJump = max(maxJump, i + nums[i])\n            left = right + 1\n            right = maxJump\n            jumps += 1\n        \n        return jumps\n", "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        jumps = 0\n        left = right = 0\n        \n        while right < n - 1:\n            farthest = 0\n            for i in range(left, right + 1):\n                farthest = max(farthest, i + nums[i])\n            left = right + 1\n            right = farthest\n            jumps += 1\n        \n        return jumps", "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        jumps = 0\n        left = right = 0\n        \n        while right < n - 1:\n            farthest = 0\n            for i in range(left, right + 1):\n                farthest = max(farthest, i + nums[i])\n            left = right + 1\n            right = farthest\n            jumps += 1\n        \n        return jumps", "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        jumps = 0\n        left = 0\n        right = 0\n        \n        while right < n - 1:\n            farthest = 0\n            for i in range(left, right + 1):\n                farthest = max(farthest, i + nums[i])\n            left = right + 1\n            right = farthest\n            jumps += 1\n        \n        return jumps\n", "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        jumps = 0\n        i = 0\n        while i < n - 1:\n            jumps += 1\n            max_reach = i + nums[i]\n            if max_reach >= n - 1:\n                return jumps\n            \n            max_jump = 0\n            for j in range(i + 1, min(i + nums[i] + 1, n)):\n                if j + nums[j] > max_jump:\n                    max_jump = j + nums[j]\n                    i = j\n                    break\n            \n            if max_jump == 0:\n                return -1\n        \n        return jumps"], ["class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(prices)\n        if n < 2:\n            return 0\n        if k > n / 2:\n            return self.maxProfit(n)\n        \n        buy = [0] * (k + 1)\n        sell = [0] * (k + 1)\n        buy[0] = -prices[0]\n        \n        for i in range(1, n):\n            buy[0] = max(buy[0], sell[0] - prices[i])\n            for j in range(1, k):\n                buy[j] = max(buy[j], sell[j] - prices[i])\n                sell[j] = max(sell[j], buy[j - 1] + prices[i])\n        return sell[k - 1]", "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(prices)\n        if k >= n // 2:\n            ans = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    ans += prices[i] - prices[i - 1]\n            return ans\n        \n        buy = [0] * (k + 1)\n        sell = [0] * (k + 1)\n        \n        for i in range(n):\n            buy[0] = max(-prices[i], buy[0])\n            sell[0] = max(sell[0], buy[0] + prices[i])\n            for j in range(1, k):\n                buy[j] = max(sell[j - 1] - prices[i], buy[j])\n                sell[j] = max(sell[j], buy[j] + prices[i])\n        return sell[k - 1]", "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(prices)\n        if n <= 1:\n            return 0\n        if k >= n / 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        \n        buy = [float('-inf')] * (k + 1)\n        sell = [0] * (k + 1)\n        \n        for price in prices:\n            for i in range(1, k + 1):\n                buy[i] = max(buy[i], sell[i - 1] - price)\n                sell[i] = max(sell[i], buy[i] + price)\n        \n        return sell[k]", "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(prices)\n        if n <= 1:\n            return 0\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        \n        buy = [0] * (k + 1)\n        sell = [0] * (k + 1)\n        \n        buy[0] = -prices[0]\n        for i in range(1, n):\n            buy[0] = max(buy[0], -prices[i])\n            sell[0] = max(sell[0], buy[0] + prices[i])\n            for j in range(1, k):\n                buy[j] = max(buy[j], sell[j - 1] - prices[i])\n                sell[j] = max(sell[j], buy[j] + prices[i])\n        return sell[k - 1]\n", "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(prices)\n        if n <= 1:\n            return 0\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        \n        buy = [float('-inf')] * (k + 1)\n        sell = [0] * (k + 1)\n        \n        for price in prices:\n            for i in range(1, k + 1):\n                buy[i] = max(buy[i], sell[i - 1] - price)\n                sell[i] = max(sell[i], buy[i] + price)\n        \n        return sell[k]"], ["class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        hex_digits = \"0123456789abcdef\"\n        hex_str = \"\"\n        \n        for i in range(8):\n            hex_str = hex_digits[num & 0xf] + hex_str\n            num >>= 4\n            \n            if num == 0:\n                break\n        \n        return hex_str.lstrip('0') or \"0\"\n", "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"0\"\n        \n        hex_digits = \"0123456789abcdef\"\n        result = \"\"\n        \n        for i in range(8):\n            result = hex_digits[num & 0xf] + result\n            num >>= 4\n            if num == 0:\n                break\n        \n        return result\n", "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"0\"\n        \n        hex_digits = \"0123456789abcdef\"\n        hex_str = \"\"\n        \n        for i in range(8):\n            hex_str = hex_digits[num & 0xf] + hex_str\n            num >>= 4\n            if num == 0:\n                break\n        \n        return hex_str", "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_digits = '0123456789abcdef'\n        hex_str = ''\n        \n        for i in range(8):\n            hex_str = hex_digits[num & 0xf] + hex_str\n            num >>= 4\n            \n            if num == 0:\n                break\n        \n        return hex_str\n", "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_digits = \"0123456789abcdef\"\n        hex_str = \"\"\n        \n        while num > 0:\n            hex_str = hex_digits[num % 16] + hex_str\n            num = num // 16\n        \n        return hex_str\n"], ["class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in s:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        for i in range(len(s)):\n            if d[s[i]] == 1:\n                return i\n        return -1", "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        for i in range(len(s)):\n            if s[i] not in s[i+1:] and s[i] not in s[:i]:\n                return i\n        return -1\n", "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in range(len(s)):\n            if s[i] not in d:\n                d[s[i]] = 1\n            else:\n                d[s[i]] += 1\n        for i in range(len(s)):\n            if d[s[i]] == 1:\n                return i\n        return -1\n", "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        \n        d = {}\n        for i in s:\n            if i not in d:\n                d[i] = 1\n            else:\n                d[i] += 1\n        \n        for i in range(len(s)):\n            if d[s[i]] == 1:\n                return i\n        \n        return -1\n", "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        \n        for i in range(len(s)):\n            if s[i] not in s[i+1:] and s[i] not in s[:i]:\n                return i\n        return -1"], ["class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(i - j) <= indexDiff and abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False\n", "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(i - j) <= indexDiff and abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False", "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(i - j) <= indexDiff and abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False\n", "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(i - j) <= indexDiff and abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False\n", "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(i - j) <= indexDiff and abs(nums[i] - nums[j]) <= valueDiff:\n                    return True\n        return False\n"], ["class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        i = 0\n        j = n - 1\n        k = 0\n        \n        while k <= j:\n            if nums[k] == 0:\n                nums[i], nums[k] = nums[k], nums[i]\n                i += 1\n                k += 1\n            elif nums[k] == 2:\n                nums[k], nums[j] = nums[j], nums[k]\n                j -= 1\n            else:\n                k += 1", "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        i = 0\n        j = 0\n        k = n - 1\n        \n        while j <= k:\n            if nums[j] == 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n                j += 1\n            elif nums[j] == 2:\n                nums[j], nums[k] = nums[k], nums[j]\n                k -= 1\n            else:\n                j += 1", "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Initialize pointers\n        p0 = 0\n        p2 = len(nums) - 1\n        i = 0\n        \n        # Iterate through the array\n        while i <= p2:\n            # If the current element is 0, swap it with the element at p0\n            if nums[i] == 0:\n                nums[i], nums[p0] = nums[p0], nums[i]\n                p0 += 1\n                i += 1\n            # If the current element is 2, swap it with the element at p2\n            elif nums[i] == 2:\n                nums[i], nums[p2] = nums[p2], nums[i]\n                p2 -= 1\n            # If the current element is 1, move to the next element\n            else:\n                i += 1", "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        i = 0\n        j = n - 1\n        k = 0\n        while k <= j:\n            if nums[k] == 0:\n                nums[i], nums[k] = nums[k], nums[i]\n                i += 1\n                k += 1\n            elif nums[k] == 2:\n                nums[k], nums[j] = nums[j], nums[k]\n                j -= 1\n            else:\n                k += 1", "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        i = 0\n        j = 0\n        k = n - 1\n        \n        while j <= k:\n            if nums[j] == 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n                j += 1\n            elif nums[j] == 2:\n                nums[j], nums[k] = nums[k], nums[j]\n                k -= 1\n            else:\n                j += 1"], ["class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_consecutive = 0\n        current_consecutive = 0\n        \n        for num in nums:\n            if num == 1:\n                current_consecutive += 1\n                max_consecutive = max(max_consecutive, current_consecutive)\n            else:\n                current_consecutive = 0\n        \n        return max_consecutive\n", "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_consecutive_ones = 0\n        current_consecutive_ones = 0\n        \n        for num in nums:\n            if num == 1:\n                current_consecutive_ones += 1\n                max_consecutive_ones = max(max_consecutive_ones, current_consecutive_ones)\n            else:\n                current_consecutive_ones = 0\n        \n        return max_consecutive_ones\n", "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_consecutive_ones = 0\n        current_consecutive_ones = 0\n        \n        for num in nums:\n            if num == 1:\n                current_consecutive_ones += 1\n            else:\n                max_consecutive_ones = max(max_consecutive_ones, current_consecutive_ones)\n                current_consecutive_ones = 0\n        \n        return max(max_consecutive_ones, current_consecutive_ones)", "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        max_count = max(max_count, count)\n        return max_count", "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        return max(max_count, count)\n"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        ans = \"\"\n        \n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            ans += str(carry % 10)\n            carry //= 10\n        \n        return ans[::-1]", "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the result and carry\n        result = \"\"\n        carry = 0\n        \n        # Pad the shorter string with leading zeros\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n        \n        # Iterate over the digits from right to left\n        for i in range(max_length - 1, -1, -1):\n            digit1 = int(num1[i])\n            digit2 = int(num2[i])\n            \n            # Calculate the sum of the digits and the carry\n            total = digit1 + digit2 + carry\n            carry = total // 10\n            result = str(total % 10) + result\n        \n        # If there is a carry left at the end, add it to the result\n        if carry:\n            result = str(carry) + result\n        \n        return result", "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(max(len(num1), len(num2))):\n            d1 = int(num1[i]) if i < len(num1) else 0\n            d2 = int(num2[i]) if i < len(num2) else 0\n            \n            total = d1 + d2 + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            \n        if carry:\n            res.append(str(carry))\n            \n        return \"\".join(res[::-1])\n", "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ans = \"\"\n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            ans += str(carry % 10)\n            carry //= 10\n        return ans[::-1]", "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            res = str(carry % 10) + res\n            carry //= 10\n        return res\n"], ["class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            elif s[i] == '+':\n                res += sign * num\n                sign = 1\n                num = 0\n            elif s[i] == '-':\n                res += sign * num\n                sign = -1\n                num = 0\n            elif s[i] == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif s[i] == ')':\n                res += sign * num\n                res *= stack.pop()\n                res += stack.pop()\n                num = 0\n        res += sign * num\n        return res\n", "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            elif s[i] == '+':\n                res += sign * num\n                num = 0\n                sign = 1\n            elif s[i] == '-':\n                res += sign * num\n                num = 0\n                sign = -1\n            elif s[i] == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif s[i] == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()\n                res += stack.pop()\n        return res + sign * num", "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        sign = '+'\n        num = 0\n        res = 0\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if s[i] in '+-*/' or i == len(s) - 1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    stack.append(int(stack.pop() / num))\n                sign = s[i]\n                num = 0\n        return sum(stack)\n", "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                res += sign * num\n                sign = 1\n                num = 0\n            elif c == '-':\n                res += sign * num\n                sign = -1\n                num = 0\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                res *= stack.pop()\n                res += stack.pop()\n                num = 0\n        res += sign * num\n        return res", "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                res += sign * num\n                sign = 1\n                num = 0\n            elif c == '-':\n                res += sign * num\n                sign = -1\n                num = 0\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                res *= stack.pop()\n                res += stack.pop()\n                num = 0\n        res += sign * num\n        return res"], ["class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(profits)\n        projects = sorted(zip(capital, profits))\n        \n        heap = []\n        i = 0\n        for _ in range(k):\n            while i < n and projects[i][0] <= w:\n                heapq.heappush(heap, -projects[i][1])\n                i += 1\n            if not heap:\n                break\n            w -= heapq.heappop(heap)\n        return w", "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(profits)\n        projects = sorted(zip(capital, profits))\n        \n        i = 0\n        heap = []\n        \n        while k > 0:\n            while i < n and projects[i][0] <= w:\n                heapq.heappush(heap, -projects[i][1])\n                i += 1\n            \n            if not heap:\n                break\n            \n            w -= heapq.heappop(heap)\n            k -= 1\n        \n        return w", "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        \n        # sort the projects by their capital requirement\n        projects = sorted(zip(capital, profits))\n        \n        # use a max heap to store the projects that can be started with the current capital\n        heap = []\n        \n        # iterate over the projects\n        for i in range(len(projects)):\n            # if the current project can be started with the current capital, add it to the heap\n            if projects[i][0] <= w:\n                heapq.heappush(heap, -projects[i][1])\n            # if the heap is not empty and we have not started k projects yet, start the project with the highest profit\n            elif heap and k > 0:\n                w -= heapq.heappop(heap)\n                k -= 1\n            # if the heap is empty and we have not started k projects yet, we cannot start any more projects\n            elif k == 0:\n                break\n        \n        # return the final capital\n        return w", "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(profits)\n        projects = [(capital[i], profits[i]) for i in range(n)]\n        projects.sort()\n        \n        heap = []\n        i = 0\n        for _ in range(k):\n            while i < n and projects[i][0] <= w:\n                heapq.heappush(heap, -projects[i][1])\n                i += 1\n            if not heap:\n                break\n            w -= heapq.heappop(heap)\n        return w", "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        \n        # sort the capital and profits by capital\n        capital.sort()\n        profits.sort()\n        \n        # create a min heap\n        heap = []\n        \n        # iterate through the capital\n        for i in range(len(capital)):\n            # if the capital is less than or equal to the current capital\n            if capital[i] <= w:\n                # push the profit to the heap\n                heapq.heappush(heap, -profits[i])\n            # if the heap is not empty\n            elif heap:\n                # pop the profit from the heap\n                w -= heapq.heappop(heap)\n                # push the profit to the heap\n                heapq.heappush(heap, -profits[i])\n            # if the heap is empty and the capital is greater than the current capital\n            elif not heap and capital[i] > w:\n                # break out of the loop\n                break\n        \n        # return the current capital\n        return w"], ["class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c == '(' or c == '{' or c == '[':\n                stack.append(c)\n            elif c == ')':\n                if not stack or stack[-1] != '(':\n                    return False\n                stack.pop()\n            elif c == '}':\n                if not stack or stack[-1] != '{':\n                    return False\n                stack.pop()\n            elif c == ']':\n                if not stack or stack[-1] != '[':\n                    return False\n                stack.pop()\n        return not stack", "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c == '(' or c == '[' or c == '{':\n                stack.append(c)\n            else:\n                if not stack:\n                    return False\n                if c == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif c == ']' and stack[-1] == '[':\n                    stack.pop()\n                elif c == '}' and stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n        return not stack\n", "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        \n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n        return not stack", "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        \n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n        \n        return not stack", "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c in \"([{\":\n                stack.append(c)\n            else:\n                if not stack:\n                    return False\n                if c == \")\" and stack[-1] == \"(\":\n                    stack.pop()\n                elif c == \"]\" and stack[-1] == \"[\":\n                    stack.pop()\n                elif c == \"}\" and stack[-1] == \"{\":\n                    stack.pop()\n                else:\n                    return False\n        return not stack"], ["class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1:] = reversed(nums[i + 1:])", "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        nums[i + 1:] = reversed(nums[i + 1:])", "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1:] = reversed(nums[i + 1:])", "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        i = n - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = n - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1:] = reversed(nums[i + 1:])", "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1:] = reversed(nums[i + 1:])"], ["class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        d = {}\n        for i, n in enumerate(nums):\n            if n in d and i - d[n] <= k:\n                return True\n            d[n] = i\n        return False\n", "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        d = {}\n        for i, n in enumerate(nums):\n            if n in d and i - d[n] <= k:\n                return True\n            d[n] = i\n        return False\n", "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        d = {}\n        for i, n in enumerate(nums):\n            if n in d and i - d[n] <= k:\n                return True\n            d[n] = i\n        return False", "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        d = {}\n        for i, n in enumerate(nums):\n            if n in d and i - d[n] <= k:\n                return True\n            d[n] = i\n        return False", "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        d = {}\n        for i, num in enumerate(nums):\n            if num in d and i - d[num] <= k:\n                return True\n            d[num] = i\n        return False"], ["class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap\n", "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap", "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap", "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap", "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        \n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        pairs = {}\n        for i in range(n):\n            pairs[row[i]] = i\n        \n        swaps = 0\n        for i in range(0, n, 2):\n            if row[i] // 2 != row[i + 1] // 2:\n                j = pairs[row[i] ^ 1]\n                row[j], row[i + 1] = row[i + 1], row[j]\n                pairs[row[i]] = i + 1\n                pairs[row[j]] = j\n                swaps += 1\n        \n        return swaps\n", "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        swaps = 0\n        for i in range(0, n, 2):\n            if row[i] % 2 == 0 and row[i + 1] != row[i] + 1:\n                swaps += 1\n            elif row[i] % 2 == 1 and row[i + 1] != row[i] - 1:\n                swaps += 1\n        return swaps", "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        swaps = 0\n        for i in range(0, n, 2):\n            if row[i] // 2 != row[i + 1] // 2:\n                swaps += 1\n        return swaps", "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                parent[px] = py\n                count[py] += count[px]\n        \n        parent = [i for i in range(n)]\n        count = [1] * n\n        \n        for i in range(0, n, 2):\n            union(row[i], row[i + 1])\n        \n        return n - max(count)", "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        swaps = 0\n        for i in range(0, n, 2):\n            if row[i] // 2 != row[i + 1] // 2:\n                for j in range(i + 1, n):\n                    if row[j] // 2 == row[i] // 2:\n                        row[i + 1], row[j] = row[j], row[i + 1]\n                        swaps += 1\n                        break\n        return swaps"], ["class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]", "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]", "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]\n", "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]\n", "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False\n        \n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[m][n]\n"], ["class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i", "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i\n", "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i\n", "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i", "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"], ["class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            word = word.lower()\n            if set(word).issubset(row1):\n                res.append(word)\n            elif set(word).issubset(row2):\n                res.append(word)\n            elif set(word).issubset(row3):\n                res.append(word)\n                \n        return res\n", "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        for word in words:\n            word = word.lower()\n            if all(c in row1 for c in word) or all(c in row2 for c in word) or all(c in row3 for c in word):\n                res.append(word)\n        return res", "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for word in words:\n            if len(set(word.lower()).intersection(set('qwertyuiop'))) and len(set(word.lower()).intersection(set('asdfghjkl'))) and len(set(word.lower()).intersection(set('zxcvbnm'))):\n                ans.append(word)\n        return ans\n", "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        for i in range(len(s), -1, -1):\n            if isPalindrome(s[:i]):\n                return s[i:][::-1] + s\n        return \"\"", "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        n = len(s)\n        for i in range(n, -1, -1):\n            if s[:i] == s[:i][::-1]:\n                return s[i:][::-1] + s", "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        for i in range(len(s), -1, -1):\n            if isPalindrome(s[:i]):\n                return s[i:][::-1] + s\n        \n        return \"\"", "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        n = len(s)\n        for i in range(n - 1, -1, -1):\n            if s[:i + 1] == s[:i + 1][::-1]:\n                return s[i + 1:][::-1] + s\n        return s[::-1]\n", "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        n = len(s)\n        for i in range(n, -1, -1):\n            if s[:i] == s[i:][::-1]:\n                return s[i:][::-1] + s\n        return \"\"\n"], ["class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if not s or not t:\n            return \"\"\n        \n        # Initialize the count of characters in t\n        countT = {}\n        for char in t:\n            countT[char] = countT.get(char, 0) + 1\n        \n        # Initialize the count of characters in the current window\n        countS = {}\n        \n        # Initialize the number of unique characters in t that are yet to be found in the window\n        required = len(countT)\n        \n        # Initialize the left and right pointers of the window\n        left, right = 0, 0\n        \n        # Initialize the minimum window size and the starting index of the minimum window\n        min_length = float('inf')\n        min_window = \"\"\n        \n        # Iterate over the characters in the string s\n        while right < len(s):\n            # Add the current character to the count of characters in the window\n            char = s[right]\n            countS[char] = countS.get(char, 0) + 1\n            \n            # If the current character is in t and its count in the window is equal to the count in t, decrement the required count\n            if char in countT and countS[char] == countT[char]:\n                required -= 1\n            \n            # If all the characters in t are found in the window, try to shrink the window\n            while required == 0:\n                # Update the minimum window size and the starting index of the minimum window\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    min_window = s[left:right+1]\n                \n                # Remove the leftmost character from the window\n                char = s[left]\n                countS[char] -= 1\n                \n                # If the leftmost character is in t and its count in the window is less than the count in t, increment the required count\n                if char in countT and countS[char] < countT[char]:\n                    required += 1\n                \n                # Move the left pointer to the right\n                left += 1\n            \n            # Move the right pointer to the right\n            right += 1\n        \n        # Return the minimum window substring\n        return min_window", "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if not t or not s:\n            return \"\"\n        \n        dict_t = Counter(t)\n        \n        required = len(dict_t)\n        \n        l, r = 0, 0\n        \n        formed = 0\n        \n        window_counts = {}\n        \n        ans = float(\"inf\"), None, None\n        \n        while r < len(s):\n            \n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            \n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n            \n            while l <= r and formed == required:\n                character = s[l]\n                \n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n                    \n                window_counts[character] -= 1\n                \n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n                \n                l += 1\n                \n            r += 1\n            \n        return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]", "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if not t or not s:\n            return \"\"\n\n        # Dictionary which keeps a count of all the unique characters in t.\n        dict_t = Counter(t)\n\n        # Number of unique characters in t, which need to be present in the desired window.\n        required = len(dict_t)\n\n        # Left and Right pointer\n        l, r = 0, 0\n\n        # formed is used to keep track of how many unique characters in t\n        # are present in the current window in its desired frequency.\n        # e.g. if t is \"AABC\" then the window must have two A's, one B and one C.\n        # Thus formed would be = 3 when all these conditions are met.\n        formed = 0\n\n        # Dictionary which keeps a count of all the unique characters in the current window.\n        window_counts = {}\n\n        # ans tuple of the form (window length, left, right)\n        ans = float(\"inf\"), None, None\n\n        while r < len(s):\n\n            # Add one character from the right to the window\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            # If the frequency of the current character added equals to the\n            # desired count in t then increment the formed count by 1.\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n\n            # Try and contract the window till the point where it ceases to be 'desirable'.\n            while l <= r and formed == required:\n                character = s[l]\n\n                # Save the smallest window until now.\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n\n                # The character at the position pointed by the\n                # `Left` pointer is no longer a part of the window.\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n\n                # Move the left pointer ahead, this would help to look for a new window.\n                l += 1    \n\n            # Keep expanding the window once we are done contracting.\n            r += 1    \n        \n        return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]", "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        from collections import Counter\n        \n        t_counter = Counter(t)\n        s_counter = Counter()\n        \n        min_length = float('inf')\n        min_window = \"\"\n        \n        left = 0\n        for right, char in enumerate(s):\n            s_counter[char] += 1\n            \n            while all(s_counter[c] >= t_counter[c] for c in t_counter):\n                window_length = right - left + 1\n                if window_length < min_length:\n                    min_length = window_length\n                    min_window = s[left:right + 1]\n                \n                s_counter[s[left]] -= 1\n                if s_counter[s[left]] == 0:\n                    del s_counter[s[left]]\n                left += 1\n        \n        return min_window\n", "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        t_count = Counter(t)\n        s_count = Counter()\n        \n        min_len = float('inf')\n        min_substring = \"\"\n        \n        left = 0\n        for right, char in enumerate(s):\n            s_count[char] += 1\n            \n            while all(s_count[c] >= t_count[c] for c in t_count):\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    min_substring = s[left:right + 1]\n                \n                s_count[s[left]] -= 1\n                left += 1\n        \n        return min_substring\n"], ["class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i - 1] == distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:\n                return True\n            if i >= 5 and distance[i - 2] >= distance[i - 4] and distance[i - 1] <= distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] + distance[i - 5] >= distance[i - 3]:\n                return True\n        return False\n", "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(distance)\n        if n < 4:\n            return False\n        \n        for i in range(3, n):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i - 1] == distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:\n                return True\n            if i >= 5 and distance[i - 2] >= distance[i - 4] and distance[i - 1] <= distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] + distance[i - 5] >= distance[i - 3]:\n                return True\n        \n        return False", "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i - 1] == distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:\n                return True\n            if i >= 5 and distance[i - 2] - distance[i - 4] >= 0 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] <= distance[i - 3] and distance[i - 1] >= distance[i - 3] - distance[i - 5]:\n                return True\n        return False\n", "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i - 1] == distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:\n                return True\n            if i >= 5 and distance[i - 2] - distance[i - 4] >= 0 and distance[i] >= distance[i - 2] - distance[i - 4] and distance[i - 1] >= distance[i - 3] - distance[i - 5] and distance[i - 1] <= distance[i - 3]:\n                return True\n        return False", "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i - 1] == distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:\n                return True\n            if i >= 5 and distance[i - 2] >= distance[i - 4] and distance[i - 1] <= distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] + distance[i - 5] >= distance[i - 3]:\n                return True\n        return False"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        count = collections.Counter(s)\n        for c in count:\n            ans += count[c] // 2 * 2\n            if ans % 2 == 0 and count[c] % 2 == 1:\n                ans += 1\n        return ans\n", "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        count = collections.Counter(s)\n        for c in count:\n            ans += count[c] // 2 * 2\n            if ans % 2 == 0 and count[c] % 2 == 1:\n                ans += 1\n        return ans", "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        count = collections.Counter(s)\n        \n        for v in count.values():\n            ans += v // 2 * 2\n            if ans % 2 == 0 and v % 2 == 1:\n                ans += 1\n        return ans", "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in s:\n            if i not in d:\n                d[i] = 1\n            else:\n                d[i] += 1\n        \n        ans = 0\n        odd = False\n        for i in d:\n            if d[i] % 2 == 0:\n                ans += d[i]\n            else:\n                ans += d[i] - 1\n                odd = True\n        \n        if odd:\n            ans += 1\n        \n        return ans\n", "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        odd = False\n        \n        for i in range(0, 26):\n            count += s.count(chr(i + 97))\n            count += s.count(chr(i + 65))\n            \n            if count % 2 != 0:\n                odd = True\n                count -= 1\n                \n        return count if not odd else count - 1\n"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = collections.deque([(start, 0)])\n            visited = set()\n            while q:\n                (x, y), d = q.popleft()\n                if (x, y) == end:\n                    return d\n                for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < len(forest) and 0 <= ny < len(forest[0]) and forest[nx][ny] and (nx, ny) not in visited:\n                        q.append(((nx, ny), d + 1))\n                        visited.add((nx, ny))\n            return -1\n        \n        trees = sorted([(h, i, j) for i, row in enumerate(forest) for j, h in enumerate(row) if h > 1])\n        ans = 0\n        x, y = 0, 0\n        for h, i, j in trees:\n            d = bfs((x, y), (i, j))\n            if d == -1:\n                return -1\n            ans += d\n            x, y = i, j\n        return ans", "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(forest)\n        n = len(forest[0])\n        \n        def bfs(i, j, k, l):\n            q = collections.deque([(i, j, 0)])\n            visited = set([(i, j)])\n            while q:\n                i, j, d = q.popleft()\n                for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited and forest[ni][nj]:\n                        if ni == k and nj == l:\n                            return d + 1\n                        visited.add((ni, nj))\n                        q.append((ni, nj, d + 1))\n            return -1\n        \n        trees = sorted([(forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1])\n        ans = 0\n        i, j = 0, 0\n        for h, k, l in trees:\n            d = bfs(i, j, k, l)\n            if d == -1:\n                return -1\n            ans += d\n            i, j = k, l\n        return ans\n", "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(forest), len(forest[0])\n        \n        def bfs(i, j, x, y):\n            q = [(i, j, 0)]\n            visited = set()\n            while q:\n                i, j, d = q.pop(0)\n                if i == x and j == y:\n                    return d\n                for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n and forest[ni][nj] and (ni, nj) not in visited:\n                        visited.add((ni, nj))\n                        q.append((ni, nj, d + 1))\n            return -1\n        \n        trees = sorted([(forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1])\n        \n        ans = 0\n        i, j = 0, 0\n        for _, x, y in trees:\n            d = bfs(i, j, x, y)\n            if d == -1:\n                return -1\n            ans += d\n            i, j = x, y\n        return ans", "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(forest), len(forest[0])\n        \n        def bfs(i, j, x, y):\n            q = collections.deque([(i, j, 0)])\n            visited = set([(i, j)])\n            while q:\n                i, j, d = q.popleft()\n                if i == x and j == y:\n                    return d\n                for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n and forest[ni][nj] and (ni, nj) not in visited:\n                        q.append((ni, nj, d + 1))\n                        visited.add((ni, nj))\n            return -1\n        \n        trees = sorted([(forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1])\n        ans = 0\n        i, j = 0, 0\n        for _, x, y in trees:\n            d = bfs(i, j, x, y)\n            if d == -1:\n                return -1\n            ans += d\n            i, j = x, y\n        return ans"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + nums[i]\n        \n        def mergeSort(left, right):\n            if left == right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(left, mid) + mergeSort(mid + 1, right)\n            i, j = left, mid + 1\n            while i <= mid:\n                while j <= right and prefix[j] - prefix[i] < lower:\n                    j += 1\n                while j <= right and prefix[j] - prefix[i] <= upper:\n                    j += 1\n                count += j - mid - 1\n                i += 1\n            \n            i, j = left, mid + 1\n            tmp = []\n            while i <= mid or j <= right:\n                if j > right or (i <= mid and prefix[i] < prefix[j]):\n                    tmp.append(prefix[i])\n                    i += 1\n                else:\n                    tmp.append(prefix[j])\n                    j += 1\n            \n            for i in range(left, right + 1):\n                prefix[i] = tmp[i - left]\n            \n            return count\n        \n        return mergeSort(0, n - 1)", "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        \n        def merge_sort(nums, lower, upper):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid], lower, upper)\n            right = merge_sort(nums[mid:], lower, upper)\n            return merge(left, right, lower, upper)\n        \n        def merge(left, right, lower, upper):\n            i, j, k = 0, 0, 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    nums[k] = left[i]\n                    i += 1\n                else:\n                    nums[k] = right[j]\n                    j += 1\n                k += 1\n            while i < len(left):\n                nums[k] = left[i]\n                i += 1\n                k += 1\n            while j < len(right):\n                nums[k] = right[j]\n                j += 1\n                k += 1\n            return nums\n        \n        def count_range(nums, lower, upper):\n            count = 0\n            for i in range(len(nums)):\n                for j in range(i + 1, len(nums)):\n                    if lower <= nums[j] - nums[i] <= upper:\n                        count += 1\n            return count\n        \n        nums = merge_sort(nums, lower, upper)\n        return count_range(nums, lower, upper)", "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        \n        # Create a list of cumulative sums\n        cumsum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            cumsum[i] = cumsum[i - 1] + nums[i - 1]\n        \n        # Sort the cumulative sums and count the number of pairs that satisfy the condition\n        cumsum.sort()\n        count = 0\n        for i in range(n):\n            j = bisect.bisect_right(cumsum, cumsum[i] + lower)\n            k = bisect.bisect_left(cumsum, cumsum[i] + upper + 1)\n            count += k - j\n        \n        return count", "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + nums[i]\n        \n        def merge_sort(arr):\n            if len(arr) <= 1:\n                return arr\n            mid = len(arr) // 2\n            left = merge_sort(arr[:mid])\n            right = merge_sort(arr[mid:])\n            \n            i, j, k = 0, 0, 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    arr[k] = left[i]\n                    i += 1\n                else:\n                    arr[k] = right[j]\n                    j += 1\n                k += 1\n            \n            while i < len(left):\n                arr[k] = left[i]\n                i += 1\n                k += 1\n            \n            while j < len(right):\n                arr[k] = right[j]\n                j += 1\n                k += 1\n            \n            return arr\n        \n        merge_sort(prefix)\n        \n        count = 0\n        for i in range(n):\n            left = bisect.bisect_left(prefix, prefix[i] + lower)\n            right = bisect.bisect_right(prefix, prefix[i] + upper)\n            count += right - left\n        \n        return count", "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + nums[i]\n        \n        def count_range(prefix, lower, upper):\n            count = 0\n            for i in range(len(prefix)):\n                j = i + 1\n                while j < len(prefix) and prefix[j] - prefix[i] <= upper:\n                    if prefix[j] - prefix[i] >= lower:\n                        count += 1\n                    j += 1\n            return count\n        \n        return count_range(prefix, lower, upper) - count_range(prefix, lower - 1, upper - 1)"], ["class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = n\n        while l <= r:\n            mid = (l + r) // 2\n            if (mid * (mid + 1)) / 2 <= n:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return r", "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, n\n        while left <= right:\n            mid = (left + right) // 2\n            curr = mid * (mid + 1) // 2\n            if curr == n:\n                return mid\n            if n < curr:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return right", "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        i = 1\n        while n > 0:\n            n -= i\n            i += 1\n        return i - 1 if n == 0 else i - 2\n", "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, n\n        while l <= r:\n            mid = (l + r) // 2\n            curr = mid * (mid + 1) // 2\n            if curr == n:\n                return mid\n            if n < curr:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return r\n", "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        i = 1\n        while n >= i:\n            n -= i\n            i += 1\n        return i - 1\n"], ["class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))", "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))", "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))", "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))", "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        if x < 0:\n            return False\n        \n        num = x\n        rev = 0\n        \n        while num > 0:\n            digit = num % 10\n            rev = rev * 10 + digit\n            num = num // 10\n            \n        return x == rev", "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        x = str(x)\n        \n        for i in range(len(x) // 2):\n            if x[i] != x[-i - 1]:\n                return False\n        \n        return True\n", "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        if x < 0:\n            return False\n        \n        num = x\n        reverse = 0\n        while num > 0:\n            reverse = reverse * 10 + num % 10\n            num //= 10\n        \n        return x == reverse\n", "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        if x < 0:\n            return False\n        \n        x_str = str(x)\n        \n        left, right = 0, len(x_str) - 1\n        \n        while left < right:\n            if x_str[left] != x_str[right]:\n                return False\n            left += 1\n            right -= 1\n        \n        return True\n", "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        rev = 0\n        temp = x\n        while temp != 0:\n            rev = rev * 10 + temp % 10\n            temp = temp // 10\n        \n        return rev == x\n"], ["class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 0 if s[0] == '0' else 1\n        \n        for i in range(2, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            two_digit = int(s[i - 2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i - 2]\n        return dp[n]", "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n                \n            two_digit = int(s[i - 2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i - 2]\n                \n        return dp[-1]", "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n                \n            two_digit = int(s[i - 2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i - 2]\n                \n        return dp[-1]", "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n                \n            two_digit = int(s[i - 2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i - 2]\n                \n        return dp[-1]", "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n                \n            two_digit = int(s[i - 2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i - 2]\n                \n        return dp[-1]\n"], ["class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for j in range(len(t)):\n            if i == len(s):\n                break\n            if s[i] == t[j]:\n                i += 1\n        return i == len(s)\n", "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)", "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for c in s:\n            i = t.find(c, i) + 1\n            if i == 0:\n                return False\n        return True", "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for j in range(len(t)):\n            if i == len(s):\n                return True\n            if s[i] == t[j]:\n                i += 1\n        return i == len(s)", "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"], ["class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        for i in range(1 << n):\n            ans.append(i ^ (i >> 1))\n        return ans", "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0]\n        for i in range(n):\n            for j in range(len(ans) - 1, -1, -1):\n                ans.append(ans[j] | (1 << i))\n        return ans\n", "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0]\n        for i in range(n):\n            for j in range(len(ans) - 1, -1, -1):\n                ans.append(ans[j] | (1 << i))\n        return ans", "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        def gray(n, ans, cur):\n            if n == 0:\n                ans.append(cur)\n                return\n            gray(n - 1, ans, cur)\n            gray(n - 1, ans, cur | (1 << (n - 1)))\n        gray(n, ans, 0)\n        return ans", "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0]\n        for i in range(n):\n            for j in range(len(ans) - 1, -1, -1):\n                ans.append(ans[j] | 1 << i)\n        return ans"], ["class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n            \n        return dp[n]\n", "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]\n", "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]", "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        \n        for i in range(3, n + 1):\n            c = a + b\n            a = b\n            b = c\n        \n        return b", "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        \n        for i in range(3, n + 1):\n            c = a + b\n            a = b\n            b = c\n        \n        return c"], ["class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if dp[i] and s[i:j] in wordDict:\n                    dp[j] = True\n        \n        return dp[-1]\n", "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[n]", "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]", "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]\n", "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[n]"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                ans.append(newInterval)\n                return ans + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                ans.append(intervals[i])\n            else:\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n        ans.append(newInterval)\n        return ans\n", "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        i = 0\n        n = len(intervals)\n        while i < n and intervals[i][1] < newInterval[0]:\n            ans.append(intervals[i])\n            i += 1\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        ans.append(newInterval)\n        while i < n:\n            ans.append(intervals[i])\n            i += 1\n        return ans", "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        i = 0\n        n = len(intervals)\n        while i < n and intervals[i][1] < newInterval[0]:\n            ans.append(intervals[i])\n            i += 1\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        ans.append(newInterval)\n        while i < n:\n            ans.append(intervals[i])\n            i += 1\n        return ans", "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                res.append(newInterval)\n                return res + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                res.append(intervals[i])\n            else:\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n        res.append(newInterval)\n        return res\n", "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        i = 0\n        n = len(intervals)\n        while i < n and intervals[i][1] < newInterval[0]:\n            ans.append(intervals[i])\n            i += 1\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        ans.append(newInterval)\n        while i < n:\n            ans.append(intervals[i])\n            i += 1\n        return ans"], ["class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(start, path):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i + 1]):\n                    path.append(s[start:i + 1])\n                    backtrack(i + 1, path)\n                    path.pop()\n        \n        result = []\n        backtrack(0, [])\n        return result", "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s, l, r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n        \n        def dfs(s, start, path, res):\n            if start == len(s):\n                res.append(path[:])\n                return\n            for i in range(start, len(s)):\n                if isPalindrome(s, start, i):\n                    path.append(s[start:i + 1])\n                    dfs(s, i + 1, path, res)\n                    path.pop()\n        \n        res = []\n        dfs(s, 0, [], res)\n        return res\n", "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(start, path):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i + 1]):\n                    path.append(s[start:i + 1])\n                    backtrack(i + 1, path)\n                    path.pop()\n        \n        result = []\n        backtrack(0, [])\n        return result\n", "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res", "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(start, path):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for end in range(start, len(s)):\n                if isPalindrome(s[start:end + 1]):\n                    path.append(s[start:end + 1])\n                    backtrack(end + 1, path)\n                    path.pop()\n        \n        result = []\n        backtrack(0, [])\n        return result\n"], ["class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        pq = []\n        for i in range(n):\n            heapq.heappush(pq, (nums[i][0], i, 0))\n        \n        ans = [-float('inf'), float('inf')]\n        max_val = max([nums[i][0] for i in range(n)])\n        \n        while pq:\n            val, i, j = heapq.heappop(pq)\n            if max_val - val < ans[1] - ans[0]:\n                ans = [val, max_val]\n            if j + 1 < len(nums[i]):\n                heapq.heappush(pq, (nums[i][j + 1], i, j + 1))\n                max_val = max(max_val, nums[i][j + 1])\n        \n        return ans", "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        min_heap = []\n        max_val = -float('inf')\n        for i, num in enumerate(nums):\n            heapq.heappush(min_heap, (num[0], i, 0))\n            max_val = max(max_val, num[0])\n        \n        min_val = min_heap[0][0]\n        ans = [min_val, max_val]\n        \n        while min_heap:\n            val, i, j = heapq.heappop(min_heap)\n            if j + 1 < len(nums[i]):\n                heapq.heappush(min_heap, (nums[i][j + 1], i, j + 1))\n                max_val = max(max_val, nums[i][j + 1])\n                if max_val - min_heap[0][0] < ans[1] - ans[0]:\n                    ans = [min_heap[0][0], max_val]\n            else:\n                break\n        \n        return ans\n", "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        heap = []\n        for i, num in enumerate(nums):\n            heapq.heappush(heap, (num[0], i, 0))\n        \n        max_val = max(num[0] for num in nums)\n        min_val = heap[0][0]\n        \n        while True:\n            val, i, j = heapq.heappop(heap)\n            if max_val - val < min_val - val:\n                min_val = val\n            \n            if j + 1 < len(nums[i]):\n                heapq.heappush(heap, (nums[i][j + 1], i, j + 1))\n                max_val = max(max_val, nums[i][j + 1])\n            else:\n                break\n        \n        return [min_val, max_val]"], ["class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        pigs = 0\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs", "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        pigs = 0\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs", "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        pigs = 0\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs", "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        pigs = 0\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs", "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        pigs = 0\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs"], ["class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        \n        def dfs(i, j, t):\n            if i < 0 or j < 0 or i >= n or j >= n or grid[i][j] > t or (i, j) in visited:\n                return False\n            \n            if i == n - 1 and j == n - 1:\n                return True\n            \n            visited.add((i, j))\n            \n            return dfs(i + 1, j, t) or dfs(i - 1, j, t) or dfs(i, j + 1, t) or dfs(i, j - 1, t)\n        \n        for t in range(n * n):\n            if dfs(0, 0, t):\n                return t", "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        \n        def dfs(i, j, t):\n            if i < 0 or j < 0 or i >= n or j >= n or (i, j) in visited or grid[i][j] > t:\n                return False\n            if i == n - 1 and j == n - 1:\n                return True\n            visited.add((i, j))\n            return dfs(i + 1, j, t) or dfs(i - 1, j, t) or dfs(i, j + 1, t) or dfs(i, j - 1, t)\n        \n        left, right = 0, n * n - 1\n        while left < right:\n            mid = (left + right) // 2\n            visited.clear()\n            if dfs(0, 0, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        \n        def dfs(i, j, t):\n            if i < 0 or j < 0 or i >= n or j >= n or grid[i][j] > t or (i, j) in visited:\n                return False\n            \n            if i == n - 1 and j == n - 1:\n                return True\n            \n            visited.add((i, j))\n            \n            return dfs(i + 1, j, t) or dfs(i - 1, j, t) or dfs(i, j + 1, t) or dfs(i, j - 1, t)\n        \n        for t in range(n * n):\n            if dfs(0, 0, t):\n                return t", "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        \n        def dfs(i, j, t):\n            if i < 0 or j < 0 or i >= n or j >= n or (i, j) in visited or grid[i][j] > t:\n                return False\n            if i == n - 1 and j == n - 1:\n                return True\n            visited.add((i, j))\n            return dfs(i + 1, j, t) or dfs(i - 1, j, t) or dfs(i, j + 1, t) or dfs(i, j - 1, t)\n        \n        low, high = 0, n * n - 1\n        while low < high:\n            mid = (low + high) // 2\n            visited.clear()\n            if dfs(0, 0, mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low", "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        visited.add((0, 0))\n        \n        def dfs(i, j, t):\n            if i == n - 1 and j == n - 1:\n                return True\n            \n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited and grid[x][y] <= t:\n                    visited.add((x, y))\n                    if dfs(x, y, t):\n                        return True\n                    visited.remove((x, y))\n            return False\n        \n        low = 0\n        high = n * n - 1\n        while low < high:\n            mid = (low + high) // 2\n            visited.clear()\n            visited.add((0, 0))\n            if dfs(0, 0, mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low\n"], ["class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]\n", "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]\n", "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[m - 1][n - 1]\n", "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[m - 1][n - 1]\n", "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]"], ["class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        ans = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1) - 1, -1, -1):\n            for j in range(len(num2) - 1, -1, -1):\n                ans[i + j + 1] += (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                ans[i + j] += ans[i + j + 1] // 10\n                ans[i + j + 1] %= 10\n        \n        i = 0\n        while i < len(ans) and ans[i] == 0:\n            i += 1\n        \n        return \"\".join(map(str, ans[i:]))", "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        ans = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1) - 1, -1, -1):\n            for j in range(len(num2) - 1, -1, -1):\n                ans[i + j + 1] += (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                ans[i + j] += ans[i + j + 1] // 10\n                ans[i + j + 1] %= 10\n        \n        i = 0\n        while i < len(ans) and ans[i] == 0:\n            i += 1\n        \n        return ''.join(map(str, ans[i:]))", "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        n1 = len(num1)\n        n2 = len(num2)\n        \n        ans = [0] * (n1 + n2)\n        \n        for i in range(n1 - 1, -1, -1):\n            for j in range(n2 - 1, -1, -1):\n                \n                d1 = int(num1[i])\n                d2 = int(num2[j])\n                \n                carry = ans[i + j + 1]\n                \n                product = d1 * d2 + carry\n                \n                ans[i + j + 1] = product % 10\n                ans[i + j] += product // 10\n                \n        \n        i = 0\n        while i < len(ans) and ans[i] == 0:\n            i += 1\n        \n        return \"\".join(map(str, ans[i:]))", "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        n1 = len(num1)\n        n2 = len(num2)\n        \n        ans = [0] * (n1 + n2)\n        \n        for i in range(n1 - 1, -1, -1):\n            for j in range(n2 - 1, -1, -1):\n                ans[i + j + 1] += int(num1[i]) * int(num2[j])\n                ans[i + j] += ans[i + j + 1] // 10\n                ans[i + j + 1] %= 10\n        \n        while len(ans) > 1 and ans[0] == 0:\n            ans.pop(0)\n        \n        return \"\".join(map(str, ans))", "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        n1 = len(num1)\n        n2 = len(num2)\n        \n        ans = [0] * (n1 + n2)\n        \n        for i in range(n1 - 1, -1, -1):\n            for j in range(n2 - 1, -1, -1):\n                ans[i + j + 1] += (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                ans[i + j] += ans[i + j + 1] // 10\n                ans[i + j + 1] %= 10\n        \n        i = 0\n        while i < len(ans) and ans[i] == 0:\n            i += 1\n        \n        return ''.join(map(str, ans[i:])) if i < len(ans) else '0'\n\n"], ["class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(prices)\n        \n        if n < 2:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for i in range(1, n):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            else:\n                max_profit = max(max_profit, prices[i] - min_price)\n        \n        return max_profit\n\n", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(prices)\n        \n        if n < 2:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for i in range(1, n):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            else:\n                max_profit = max(max_profit, prices[i] - min_price)\n        \n        return max_profit\n", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(prices)\n        if n < 2:\n            return 0\n        \n        buy1 = buy2 = float('-inf')\n        sell1 = sell2 = 0\n        \n        for price in prices:\n            buy1 = max(buy1, -price)\n            sell1 = max(sell1, buy1 + price)\n            buy2 = max(buy2, sell1 - price)\n            sell2 = max(sell2, buy2 + price)\n        \n        return sell2", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_profit = 0\n        n = len(prices)\n        for i in range(n):\n            for j in range(i + 1, n):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(prices)\n        \n        if n < 2:\n            return 0\n        \n        buy1 = buy2 = float('-inf')\n        sell1 = sell2 = 0\n        \n        for price in prices:\n            buy1 = max(buy1, -price)\n            sell1 = max(sell1, buy1 + price)\n            buy2 = max(buy2, sell1 - price)\n            sell2 = max(sell2, buy2 + price)\n        \n        return sell2"], ["class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, index, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i - 1]:\n                continue\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)\n", "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        candidates.sort()\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, index, path, res):\n        if target < 0:\n            return \n        if target == 0:\n            res.append(path)\n            return \n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i - 1]:\n                continue\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)\n", "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        ans = []\n        self.dfs(candidates, target, 0, [], ans)\n        return ans\n    \n    def dfs(self, nums, target, index, path, ans):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            ans.append(path)\n            return \n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], ans)", "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, index, path, res):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            res.append(path)\n            return \n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i - 1]:\n                continue\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)", "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        \n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur[:])\n                return\n            if i >= len(candidates) or total > target:\n                return\n            \n            cur.append(candidates[i])\n            dfs(i + 1, cur, total + candidates[i])\n            \n            cur.pop()\n            while i + 1 < len(candidates) and candidates[i] == candidates[i + 1]:\n                i += 1\n            dfs(i + 1, cur, total)\n            \n        dfs(0, [], 0)\n        return res\n"], ["class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        \n        if word[0].isupper() and word[1:].islower():\n            return True\n        \n        return False", "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        return word.isupper() or word.islower() or word.istitle()\n", "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        return word.isupper() or word.islower() or word.istitle()", "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        \n        if word[0].isupper() and word[1:].islower():\n            return True\n        \n        return False\n", "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        return word.isupper() or word.islower() or word.istitle()\n"], ["class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit\n", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit\n", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        \n        return max_profit", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        \n        return max_profit\n", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        \n        return max_profit\n"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        def remove(s, left, right):\n            stack = []\n            for c in s:\n                if c == '(':\n                    stack.append(c)\n                elif c == ')':\n                    if stack and stack[-1] == '(':\n                        stack.pop()\n                    else:\n                        stack.append(c)\n            return ''.join(stack)\n        \n        def backtrack(s, left, right):\n            if left == 0 and right == 0:\n                if isValid(s):\n                    res.append(s)\n                return\n            for i in range(len(s)):\n                if s[i] == '(' and left > 0:\n                    backtrack(s[:i] + s[i + 1:], left - 1, right)\n                if s[i] == ')' and right > 0:\n                    backtrack(s[:i] + s[i + 1:], left, right - 1)\n        \n        res = []\n        left = right = 0\n        for c in s:\n            if c == '(':\n                left += 1\n            elif c == ')':\n                if left > 0:\n                    left -= 1\n                else:\n                    right += 1\n        backtrack(s, left, right)\n        return res\n", "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        def remove(s, left, right):\n            if left == 0 and right == 0:\n                if isValid(s):\n                    res.append(s)\n                return\n            for i in range(len(s)):\n                if s[i] == '(' and left > 0:\n                    remove(s[:i] + s[i + 1:], left - 1, right)\n                if s[i] == ')' and right > 0:\n                    remove(s[:i] + s[i + 1:], left, right - 1)\n        \n        res = []\n        remove(s, 0, 0)\n        return res\n", "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        def remove(s, left, right):\n            if left == 0 and right == 0:\n                if isValid(s):\n                    res.append(s)\n                return\n            for i in range(len(s)):\n                if left > 0 and s[i] == '(':\n                    remove(s[:i] + s[i+1:], left-1, right)\n                if right > 0 and s[i] == ')':\n                    remove(s[:i] + s[i+1:], left, right-1)\n        \n        res = []\n        remove(s, 0, 0)\n        return res\n", "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_valid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        def remove(s, i, j):\n            res = []\n            for k in range(i, j + 1):\n                if s[k] != '(' and s[k] != ')':\n                    continue\n                res.append(s[:k] + s[k + 1:])\n            return res\n        \n        queue = [s]\n        visited = set([s])\n        found = False\n        \n        while queue:\n            cur = queue.pop(0)\n            if is_valid(cur):\n                found = True\n                res.append(cur)\n            if found:\n                continue\n            for i in range(len(cur)):\n                if cur[i] != '(' and cur[i] != ')':\n                    continue\n                for nxt in remove(cur, i, i):\n                    if nxt not in visited:\n                        visited.add(nxt)\n                        queue.append(nxt)\n        return res\n", "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_valid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        def remove_parentheses(s, left_rem, right_rem):\n            if left_rem == 0 and right_rem == 0:\n                if is_valid(s):\n                    ans.append(s)\n                return\n            \n            for i in range(len(s)):\n                if s[i] == '(' and left_rem > 0:\n                    remove_parentheses(s[:i] + s[i+1:], left_rem - 1, right_rem)\n                elif s[i] == ')' and right_rem > 0:\n                    remove_parentheses(s[:i] + s[i+1:], left_rem, right_rem - 1)\n        \n        ans = []\n        remove_parentheses(s, 0, 0)\n        return ans"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [i for i in range(n)]\n        for i in range(n):\n            for j in range(i + 1):\n                if s[j:i + 1] == s[j:i + 1][::-1]:\n                    dp[i] = min(dp[i], dp[j - 1] + 1)\n        return dp[-1]\n", "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[n] = -1\n        for i in range(n - 1, -1, -1):\n            minCut = i\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i < 2 or dp[i + 1] == dp[j]):\n                    minCut = min(minCut, dp[j + 1] + 1)\n            dp[i] = minCut\n        return dp[0]\n", "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = -1\n        for i in range(n):\n            for j in range(i, n):\n                if s[i:j + 1] == s[i:j + 1][::-1]:\n                    dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n        return dp[-1]\n", "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [i for i in range(n)]\n        for i in range(n):\n            for j in range(i + 1):\n                if s[j:i + 1] == s[j:i + 1][::-1]:\n                    dp[i] = min(dp[i], dp[j - 1] + 1)\n        return dp[-1]\n", "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [i for i in range(n)]\n        for i in range(n):\n            for j in range(i + 1):\n                if s[j:i + 1] == s[j:i + 1][::-1]:\n                    dp[i] = min(dp[i], dp[j - 1] + 1)\n        return dp[-1]"], ["class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n > 0:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 5 * k\n        while left <= right:\n            mid = (left + right) // 2\n            zeroes = count_zeroes(mid)\n            if zeroes == k:\n                return 5\n            elif zeroes < k:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return 0\n", "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n > 0:\n                if n % 10 == 0:\n                    count += 1\n                n //= 10\n            return count\n        \n        left, right = 0, k + 1\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return 5", "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return sum(x // i for i in range(1, 5))\n        \n        left, right = 0, k + 1\n        while left < right:\n            mid = (left + right) // 2\n            if f(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return 5 if f(left) == k else 0\n", "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 5 * k\n        while left <= right:\n            mid = left + (right - left) // 2\n            zeroes = count_zeroes(mid)\n            if zeroes == k:\n                return 5\n            elif zeroes < k:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return 0\n", "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(x):\n            count = 0\n            while x > 0:\n                if x % 10 == 0:\n                    count += 1\n                x //= 10\n            return count\n        \n        left, right = 0, 5 * k + 1\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return 5 if count_zeroes(left) == k else 0"], ["class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        def find_palindromes(word, i):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                if is_palindrome(prefix) and is_palindrome(suffix):\n                    yield (i, len(words) - 1 - j)\n                if is_palindrome(suffix) and is_palindrome(prefix):\n                    yield (len(words) - 1 - j, i)\n        \n        word_to_index = {word: i for i, word in enumerate(words)}\n        \n        pairs = []\n        for i, word in enumerate(words):\n            for pair in find_palindromes(word, i):\n                pairs.append(pair)\n        \n        return pairs", "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPalindromePairs(word):\n            pairs = []\n            for i in range(len(word) + 1):\n                prefix = word[:i]\n                suffix = word[i:]\n                if isPalindrome(prefix):\n                    suffix_reversed = suffix[::-1]\n                    if suffix_reversed != word and suffix_reversed in word_to_index:\n                        pairs.append([word_to_index[suffix_reversed], word_to_index[word]])\n                if isPalindrome(suffix):\n                    prefix_reversed = prefix[::-1]\n                    if prefix_reversed != word and prefix_reversed in word_to_index:\n                        pairs.append([word_to_index[word], word_to_index[prefix_reversed]])\n            return pairs\n        \n        word_to_index = {word: i for i, word in enumerate(words)}\n        pairs = []\n        for word in words:\n            pairs.extend(getPalindromePairs(word))\n        return pairs\n", "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        def find_palindrome_pairs(words):\n            pairs = []\n            for i in range(len(words)):\n                for j in range(len(words)):\n                    if i != j and is_palindrome(words[i] + words[j]):\n                        pairs.append([i, j])\n            return pairs\n        \n        return find_palindrome_pairs(words)", "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        def find_palindrome_pairs(words):\n            pairs = []\n            for i in range(len(words)):\n                for j in range(i + 1, len(words)):\n                    if is_palindrome(words[i] + words[j]):\n                        pairs.append([i, j])\n                    if is_palindrome(words[j] + words[i]):\n                        pairs.append([j, i])\n            return pairs\n        \n        return find_palindrome_pairs(words)", "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        def find_palindrome_pairs(words):\n            pairs = []\n            for i in range(len(words)):\n                for j in range(i + 1, len(words)):\n                    if is_palindrome(words[i] + words[j]):\n                        pairs.append([i, j])\n                    if is_palindrome(words[j] + words[i]):\n                        pairs.append([j, i])\n            return pairs\n        \n        return find_palindrome_pairs(words)"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, visited):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] == 0 or (i, j) in visited:\n                return\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                dfs(i + di, j + dj, visited)\n        \n        def spread(i, j, visited):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] == 1 or (i, j) in visited:\n                return\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                spread(i + di, j + dj, visited)\n        \n        def remove_walls(i, j, visited):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] == 1 or (i, j) in visited:\n                return\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                remove_walls(i + di, j + dj, visited)\n        \n        def remove_walls_from_neighbors(i, j, visited):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] == 1 or (i, j) in visited:\n                return\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                remove_walls_from_neighbors(i + di, j + dj, visited)\n        \n        def remove_walls_from_neighbors(i, j, visited):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] == 1 or (i, j) in visited:\n                return\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                remove_walls_from_neighbors(i + di, j + dj, visited)\n        \n        def remove_walls_from_neighbors(i, j, visited):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] == 1 or (i, j) in visited:\n                return\n            visited.add((i, j))", "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, visited):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] == 0 or (i, j) in visited:\n                return\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                dfs(i + di, j + dj, visited)\n\n        def spread_virus(i, j):\n            visited = set()\n            dfs(i, j, visited)\n            for x, y in visited:\n                isInfected[x][y] = 2\n\n        def find_neighbors(i, j):\n            neighbors = []\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                x, y = i + di, j + dj\n                if 0 <= x < len(isInfected) and 0 <= y < len(isInfected[0]) and isInfected[x][y] == 1:\n                    neighbors.append((x, y))\n            return neighbors\n\n        def find_neighbors_of_neighbors(i, j):\n            neighbors = []\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                x, y = i + di, j + dj\n                if 0 <= x < len(isInfected) and 0 <= y < len(isInfected[0]) and isInfected[x][y] == 1:\n                    neighbors.append((x, y))\n            return neighbors\n\n        def find_neighbors_of_neighbors_of_neighbors(i, j):\n            neighbors = []\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                x, y = i + di, j + dj\n                if 0 <= x < len(isInfected) and 0 <= y < len(isInfected[0]) and isInfected[x][y] == 1:\n                    neighbors.append((x, y))\n            return neighbors\n\n        def find_neighbors_of_neighbors_of_neighbors_of_neighbors(i, j):\n            neighbors = []\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                x, y = i + di, j + dj\n                if 0 <= x < len(isInfected) and 0 <= y < len(isInfected[0]) and isInfected[x][y] == 1:\n                    neighbors.append((x, y))\n            return neighbors\n\n        def find_neighbors_of_neighbors_of_neighbors_of_neighbors_of_neighbors(i, j):\n            neighbors = []\n            for di, dj in [(0, ", "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"], ["class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        def dfs(i, j):\n            if dp[i][j] != 0:\n                return dp[i][j]\n            \n            directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n            \n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(ni, nj))\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                dfs(i, j)\n        \n        return max(max(row) for row in dp)", "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        def dfs(i, j):\n            if not dp[i][j]:\n                val = matrix[i][j]\n                dp[i][j] = 1 + max(\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\n                    dfs(i + 1, j) if i < m - 1 and val > matrix[i + 1][j] else 0,\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\n                    dfs(i, j + 1) if j < n - 1 and val > matrix[i][j + 1] else 0,\n                )\n            return dp[i][j]\n        \n        dp = [[0] * n for _ in range(m)]\n        return max(dfs(x, y) for x in range(m) for y in range(n))", "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if not dp[i][j]:\n                val = matrix[i][j]\n                dp[i][j] = 1 + max(\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\n                    dfs(i + 1, j) if i < M - 1 and val > matrix[i + 1][j] else 0,\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\n                    dfs(i, j + 1) if j < N - 1 and val > matrix[i][j + 1] else 0,\n                )\n            return dp[i][j]\n        \n        if not matrix or not matrix[0]: return 0\n        M, N = len(matrix), len(matrix[0])\n        dp = [[0] * N for _ in matrix]\n        return max(dfs(x, y) for x in range(M) for y in range(N))", "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        def dfs(i, j):\n            if dp[i][j] != 0:\n                return dp[i][j]\n            \n            dp[i][j] = 1\n            \n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            \n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                dfs(i, j)\n        \n        return max(max(row) for row in dp)\n", "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        def dfs(i, j):\n            if dp[i][j] != 0:\n                return dp[i][j]\n            \n            res = 1\n            \n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    res = max(res, 1 + dfs(x, y))\n                    \n            dp[i][j] = res\n            return res\n        \n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n                \n        return ans"], ["class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 1:\n            return 0\n        \n        s = str(n)\n        \n        res = 0\n        \n        for i in range(len(s)):\n            \n            if s[i] == '0':\n                continue\n            \n            if i == 0:\n                res += int(s[i]) * 10 ** (len(s) - 1)\n                \n            else:\n                res += int(s[i]) * 10 ** (len(s) - i - 1) + 10 ** (len(s) - i)\n                \n            if s[i] == '1':\n                res += n % (10 ** i) + 1\n                \n        return res", "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(1, n + 1):\n            ans += str(i).count('1')\n        return ans\n", "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(n + 1):\n            ans += str(i).count('1')\n        return ans", "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        ans = 0\n        \n        for i in range(1, n + 1):\n            ans += self.countDigitOneInNumber(i)\n        \n        return ans\n    \n    def countDigitOneInNumber(self, n):\n        \n        ans = 0\n        \n        while n > 0:\n            if n % 10 == 1:\n                ans += 1\n            n = n // 10\n        \n        return ans\n", "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(1, n + 1):\n            ans += str(i).count('1')\n        return ans"], ["class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(s, wordDict, memo):\n            if s in memo:\n                return memo[s]\n            \n            res = []\n            for word in wordDict:\n                if s.startswith(word):\n                    suffix = s[len(word):]\n                    if not suffix:\n                        res.append(word)\n                    else:\n                        for suffix_word in dfs(suffix, wordDict, memo):\n                            res.append(word + ' ' + suffix_word)\n            memo[s] = res\n            return res\n        \n        return dfs(s, wordDict, {})", "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(s, wordDict, memo):\n            if s in memo:\n                return memo[s]\n            \n            if not s:\n                return [[]]\n            \n            res = []\n            for word in wordDict:\n                if s.startswith(word):\n                    for sub_res in dfs(s[len(word):], wordDict, memo):\n                        res.append([word] + sub_res)\n            \n            memo[s] = res\n            return res\n        \n        return [\" \".join(words) for words in dfs(s, wordDict, {})]\n", "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        def dfs(s, wordDict, memo):\n            if s in memo:\n                return memo[s]\n            \n            if not s:\n                return []\n            \n            res = []\n            for word in wordDict:\n                if s.startswith(word):\n                    for sub in dfs(s[len(word):], wordDict, memo):\n                        res.append(word + (sub and ' ' + sub))\n            memo[s] = res\n            return res\n        \n        return dfs(s, wordDict, {})\n", "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(s, wordDict, memo):\n            if s in memo:\n                return memo[s]\n            \n            res = []\n            for word in wordDict:\n                if s.startswith(word):\n                    suffix = s[len(word):]\n                    if not suffix:\n                        res.append(word)\n                    else:\n                        for suffix_word in dfs(suffix, wordDict, memo):\n                            res.append(word + ' ' + suffix_word)\n            memo[s] = res\n            return res\n        \n        return dfs(s, wordDict, {})", "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        def dfs(s, wordDict, memo):\n            if s in memo:\n                return memo[s]\n            \n            res = []\n            for word in wordDict:\n                if s.startswith(word):\n                    if len(s) == len(word):\n                        res.append(word)\n                    else:\n                        suffix = s[len(word):]\n                        for suffix_word in dfs(suffix, wordDict, memo):\n                            res.append(word + \" \" + suffix_word)\n            memo[s] = res\n            return res\n        \n        return dfs(s, wordDict, {})"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for h in range(12):\n            for m in range(60):\n                if (bin(h) + bin(m)).count('1') == turnedOn:\n                    ans.append('%d:%02d' % (h, m))\n        return ans\n", "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.append('%d:%02d' % (h, m))\n        return res", "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.append('%d:%02d' % (h, m))\n        return res", "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.append('%d:%02d' % (h, m))\n        return res\n", "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    ans.append('%d:%02d' % (h, m))\n        return ans"], ["class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        ans = [[1]]\n        \n        for i in range(1, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(ans[i - 1][j - 1] + ans[i - 1][j])\n            row.append(1)\n            ans.append(row)\n        \n        return ans\n", "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        for i in range(numRows):\n            ans.append([])\n            for j in range(i + 1):\n                if j == 0 or j == i:\n                    ans[i].append(1)\n                else:\n                    ans[i].append(ans[i - 1][j - 1] + ans[i - 1][j])\n        return ans\n", "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1, 1]]\n        \n        ans = [[1], [1, 1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(ans[i - 1][j - 1] + ans[i - 1][j])\n            temp.append(1)\n            ans.append(temp)\n        \n        return ans", "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        \n        ans = [[1]]\n        \n        for i in range(1, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(ans[i - 1][j - 1] + ans[i - 1][j])\n            temp.append(1)\n            ans.append(temp)\n        \n        return ans\n", "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        ans = [[1]]\n        \n        for i in range(1, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(ans[i - 1][j - 1] + ans[i - 1][j])\n            temp.append(1)\n            ans.append(temp)\n        \n        return ans"], ["class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1\n", "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1\n", "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1\n", "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1\n", "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1\n"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        pq = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heappush(pq, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        ans = 0\n        while pq:\n            h, i, j = heappop(pq)\n            for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    ans += max(0, h - heightMap[x][y])\n                    heappush(pq, (max(h, heightMap[x][y]), x, y))\n                    visited[x][y] = True\n        \n        return ans", "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(heightMap)\n        n = len(heightMap[0])\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        pq = []\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heappush(pq, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        ans = 0\n        while pq:\n            h, i, j = heappop(pq)\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    visited[x][y] = True\n                    if heightMap[x][y] < h:\n                        ans += h - heightMap[x][y]\n                    heappush(pq, (max(h, heightMap[x][y]), x, y))\n        \n        return ans", "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        pq = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(pq, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        res = 0\n        while pq:\n            h, i, j = heapq.heappop(pq)\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    visited[x][y] = True\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(pq, (max(h, heightMap[x][y]), x, y))\n        \n        return res\n", "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        pq = []\n        \n        # Add all the boundary cells to the priority queue\n        for i in range(m):\n            pq.append((heightMap[i][0], i, 0))\n            pq.append((heightMap[i][n - 1], i, n - 1))\n            visited[i][0] = visited[i][n - 1] = True\n        for j in range(1, n - 1):\n            pq.append((heightMap[0][j], 0, j))\n            pq.append((heightMap[m - 1][j], m - 1, j))\n            visited[0][j] = visited[m - 1][j] = True\n        \n        # Sort the priority queue\n        pq.sort()\n        \n        # Use a stack to keep track of the cells that are currently being processed\n        stack = []\n        \n        # Use a variable to keep track of the total amount of trapped water\n        total_water = 0\n        \n        # Process the cells in the priority queue\n        while pq:\n            height, i, j = pq.pop(0)\n            \n            # If the current cell is not a boundary cell, add it to the stack\n            if not (i == 0 or i == m - 1 or j == 0 or j == n - 1):\n                stack.append((height, i, j))\n            \n            # Process the cells in the stack\n            while stack:\n                current_height, current_i, current_j = stack.pop()\n                \n                # Check the neighboring cells\n                for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    ni, nj = current_i + di, current_j + dj\n                    \n                    # If the neighboring cell is not visited and has a lower height, add it to the priority queue and the stack\n                    if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and heightMap[ni][nj] < current_height:\n                        pq.append((heightMap[ni][nj], ni, nj))\n                        stack.append((heightMap[ni][nj], ni, nj))\n                        visited[ni][nj] = True\n                \n                # If the neighboring cell has a higher height, add the difference to the total amount of trapped water\n                for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    ni, nj = current_i + di, current_j + dj\n                    if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and heightMap[ni][nj] > current_height:\n                        total_water += current_height - heightMap[ni][nj]\n                        heightMap[ni][nj] = current_height\n        \n        return total_water", "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        pq = []\n        \n        # Add all the boundary cells to the priority queue\n        for i in range(m):\n            pq.append((heightMap[i][0], i, 0))\n            pq.append((heightMap[i][n - 1], i, n - 1))\n            visited[i][0] = visited[i][n - 1] = True\n        for j in range(1, n - 1):\n            pq.append((heightMap[0][j], 0, j))\n            pq.append((heightMap[m - 1][j], m - 1, j))\n            visited[0][j] = visited[m - 1][j] = True\n        \n        # Sort the priority queue based on the height\n        pq.sort()\n        \n        # Initialize the answer and the maximum height seen so far\n        ans = 0\n        max_height = 0\n        \n        # Process the cells in the priority queue\n        while pq:\n            height, i, j = pq.pop(0)\n            max_height = max(max_height, height)\n            \n            # Check the neighboring cells\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:\n                    visited[ni][nj] = True\n                    pq.append((heightMap[ni][nj], ni, nj))\n                    ans += max(0, max_height - heightMap[ni][nj])\n        \n        return ans\n"], ["class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = ''.join(c for c in s if c.isalnum())\n        return s == s[::-1]\n", "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = ''.join(filter(str.isalnum, s))\n        return s == s[::-1]", "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = ''.join(c.lower() for c in s if c.isalnum())\n        return s == s[::-1]\n", "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = ''.join(c.lower() for c in s if c.isalnum())\n        return s == s[::-1]", "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = ''.join(filter(str.isalnum, s))\n        return s == s[::-1]"], ["class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        res = []\n        for i in range(len(nums) - k + 1):\n            res.append(self.getMedian(nums[i:i + k]))\n        return res\n\n    def getMedian(self, nums):\n        nums.sort()\n        n = len(nums)\n        if n % 2 == 0:\n            return (nums[n // 2] + nums[n // 2 - 1]) / 2.0\n        else:\n            return nums[n // 2]\n", "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        n = len(nums)\n        ans = []\n        for i in range(n - k + 1):\n            ans.append(self.median(nums[i:i + k]))\n        return ans\n\n    def median(self, nums):\n        nums.sort()\n        n = len(nums)\n        if n % 2 == 1:\n            return nums[n // 2]\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2.0\n", "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        n = len(nums)\n        ans = []\n        for i in range(n - k + 1):\n            ans.append(self.findMedian(nums[i:i + k]))\n        return ans\n    \n    def findMedian(self, nums):\n        nums.sort()\n        n = len(nums)\n        if n % 2 == 0:\n            return (nums[n // 2] + nums[n // 2 - 1]) / 2.0\n        else:\n            return nums[n // 2]", "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        res = []\n        \n        for i in range(len(nums) - k + 1):\n            res.append(self.getMedian(nums[i:i+k]))\n        \n        return res\n    \n    def getMedian(self, nums):\n        nums.sort()\n        \n        if len(nums) % 2 == 0:\n            return (nums[len(nums)//2] + nums[len(nums)//2 - 1]) / 2.0\n        else:\n            return nums[len(nums)//2]", "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        res = []\n        for i in range(len(nums) - k + 1):\n            res.append(self.median(nums[i:i + k]))\n        return res\n    \n    def median(self, nums):\n        nums.sort()\n        n = len(nums)\n        if n % 2 == 0:\n            return (nums[n // 2] + nums[n // 2 - 1]) / 2.0\n        else:\n            return nums[n // 2]"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        for i in [2, 3, 5]:\n            while n % i == 0:\n                n /= i\n        return n == 1\n", "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        for p in [2, 3, 5]:\n            while n % p == 0:\n                n /= p\n        return n == 1", "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        for p in [2, 3, 5]:\n            while n % p == 0:\n                n /= p\n        return n == 1\n", "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        for p in [2, 3, 5]:\n            while n % p == 0:\n                n /= p\n        return n == 1\n", "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        for i in [2, 3, 5]:\n            while n % i == 0:\n                n /= i\n        return n == 1\n"], ["class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(positions)\n        for i in range(n):\n            for j in range(i + 1, n):\n                ans += len({a[i], a[j], a[k]}) == 3\n        return ans", "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(positions)\n        for i in range(n):\n            left, sideLength = positions[i]\n            right = left + sideLength\n            height = sideLength\n            for j in range(i + 1, n):\n                left2, sideLength2 = positions[j]\n                right2 = left2 + sideLength2\n                if left2 <= left and right <= right2:\n                    height = max(height, sideLength2)\n                elif left2 <= right and right <= right2:\n                    height = max(height, sideLength2 - (right - left))\n                elif left <= left2 and right2 <= right:\n                    height = max(height, sideLength - (right2 - right))\n            ans.append(height)\n        return ans", "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(positions)\n        for i in range(n):\n            for j in range(i + 1, n):\n                ans += len({a[i], a[j], a[k]}) == 3\n        return ans", "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(positions)\n        for i in range(n):\n            left, sideLength = positions[i]\n            right = left + sideLength\n            height = 0\n            for j in range(i):\n                l, s = positions[j]\n                r = l + s\n                if l < right and left < r:\n                    height = max(height, ans[j])\n            height += sideLength\n            ans.append(height)\n        return ans"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        for i in range(m):\n            for j in range(1, n):\n                matrix[i][j] += matrix[i][j - 1]\n        \n        for j in range(n):\n            for i in range(1, m):\n                matrix[i][j] += matrix[i - 1][j]\n        \n        ans = float('-inf')\n        for i in range(m):\n            for j in range(n):\n                for x in range(i, m):\n                    for y in range(j, n):\n                        s = matrix[x][y]\n                        if i > 0:\n                            s -= matrix[i - 1][y]\n                        if j > 0:\n                            s -= matrix[x][j - 1]\n                        if i > 0 and j > 0:\n                            s += matrix[i - 1][j - 1]\n                        if s <= k:\n                            ans = max(ans, s)\n        return ans\n", "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # transpose matrix\n        matrix = zip(*matrix)\n        \n        # iterate over columns\n        for i in range(n):\n            \n            # calculate prefix sum\n            for j in range(1, m):\n                matrix[i][j] += matrix[i][j-1]\n        \n        # iterate over rows\n        for i in range(m):\n            \n            # calculate prefix sum\n            for j in range(1, n):\n                matrix[i][j] += matrix[i][j-1]\n        \n        # iterate over rows\n        for i in range(m):\n            \n            # iterate over columns\n            for j in range(n):\n                \n                # iterate over rows\n                for k in range(i, m):\n                    \n                    # iterate over columns\n                    for l in range(j, n):\n                        \n                        # calculate sum\n                        sum = matrix[k][l]\n                        \n                        # subtract previous row\n                        if i > 0:\n                            sum -= matrix[i-1][l]\n                        \n                        # subtract previous column\n                        if j > 0:\n                            sum -= matrix[k][j-1]\n                        \n                        # add previous row and column\n                        if i > 0 and j > 0:\n                            sum += matrix[i-1][j-1]\n                        \n                        # check if sum is less than k\n                        if sum <= k:\n                            return sum\n        \n        return -1", "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # Calculate the prefix sum for each row\n        for i in range(m):\n            for j in range(1, n):\n                matrix[i][j] += matrix[i][j - 1]\n        \n        # Calculate the prefix sum for each column\n        for j in range(n):\n            for i in range(1, m):\n                matrix[i][j] += matrix[i - 1][j]\n        \n        # Find the maximum sum of a submatrix with sum <= k\n        max_sum = float('-inf')\n        for i1 in range(m):\n            for j1 in range(n):\n                for i2 in range(i1, m):\n                    for j2 in range(j1, n):\n                        # Calculate the sum of the submatrix\n                        sub_sum = matrix[i2][j2]\n                        if i1 > 0:\n                            sub_sum -= matrix[i1 - 1][j2]\n                        if j1 > 0:\n                            sub_sum -= matrix[i2][j1 - 1]\n                        if i1 > 0 and j1 > 0:\n                            sub_sum += matrix[i1 - 1][j1 - 1]\n                        \n                        # Check if the sum is <= k\n                        if sub_sum <= k:\n                            max_sum = max(max_sum, sub_sum)\n        \n        return max_sum", "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        for i in range(m):\n            for j in range(1, n):\n                matrix[i][j] += matrix[i][j - 1]\n        \n        for j in range(n):\n            for i in range(1, m):\n                matrix[i][j] += matrix[i - 1][j]\n        \n        ans = float('-inf')\n        for i in range(m):\n            for j in range(n):\n                for x in range(i, m):\n                    for y in range(j, n):\n                        s = matrix[x][y]\n                        if i > 0:\n                            s -= matrix[i - 1][y]\n                        if j > 0:\n                            s -= matrix[x][j - 1]\n                        if i > 0 and j > 0:\n                            s += matrix[i - 1][j - 1]\n                        if s <= k:\n                            ans = max(ans, s)\n        return ans", "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        for i in range(m):\n            for j in range(1, n):\n                matrix[i][j] += matrix[i][j - 1]\n        \n        for j in range(n):\n            for i in range(1, m):\n                matrix[i][j] += matrix[i - 1][j]\n        \n        ans = float('-inf')\n        for i in range(m):\n            for j in range(n):\n                for x in range(i, m):\n                    for y in range(j, n):\n                        s = matrix[x][y]\n                        if i > 0:\n                            s -= matrix[i - 1][y]\n                        if j > 0:\n                            s -= matrix[x][j - 1]\n                        if i > 0 and j > 0:\n                            s += matrix[i - 1][j - 1]\n                        if s <= k:\n                            ans = max(ans, s)\n        return ans\n"], ["class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == divisor:\n            return 1\n        \n        if divisor == 1:\n            return dividend\n        \n        if divisor == -1:\n            if dividend > 2**31 - 1 or dividend < -2**31:\n                return 2**31 - 1\n            return -dividend\n        \n        if divisor == 0:\n            return 0\n        \n        if dividend > 0 and divisor > 0:\n            return self.divide(dividend - divisor, divisor) + 1\n        \n        if dividend > 0 and divisor < 0:\n            return self.divide(dividend, divisor + 1) - 1\n        \n        if dividend < 0 and divisor > 0:\n            return self.divide(dividend + divisor, divisor) - 1\n        \n        if dividend < 0 and divisor < 0:\n            return self.divide(dividend, divisor - 1) + 1\n        \n        return 0", "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if divisor == -1:\n            if dividend > 2**31 - 1:\n                return 2**31 - 1\n            if dividend < -2**31:\n                return -2**31\n            return -dividend\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        if dividend > 0 and divisor > 0:\n            return self.divide(dividend - divisor, divisor) + 1\n        if dividend < 0 and divisor < 0:\n            return self.divide(-dividend, -divisor)\n        if dividend > 0 and divisor < 0:\n            return -self.divide(dividend, -divisor)\n        if dividend < 0 and divisor > 0:\n            return -self.divide(-dividend, divisor)", "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == divisor:\n            return 1\n        \n        if divisor == 1:\n            return dividend\n        \n        if divisor == -1:\n            if dividend > 0:\n                return -dividend\n            else:\n                return dividend\n        \n        if divisor == 0:\n            return float('inf')\n        \n        if dividend == float('inf'):\n            if divisor > 0:\n                return float('inf')\n            else:\n                return float('-inf')\n        \n        if dividend == float('-inf'):\n            if divisor > 0:\n                return float('-inf')\n            else:\n                return float('inf')\n        \n        if divisor == float('inf'):\n            return 0\n        \n        if divisor == float('-inf'):\n            return 0\n        \n        if dividend > 0 and divisor > 0:\n            return self.divide(dividend - divisor, divisor) + 1\n        \n        if dividend < 0 and divisor < 0:\n            return self.divide(-dividend, -divisor)\n        \n        if dividend > 0 and divisor < 0:\n            return -self.divide(dividend, -divisor)\n        \n        if dividend < 0 and divisor > 0:\n            return -self.divide(-dividend, divisor)\n        \n        return 0", "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if divisor == -1:\n            if dividend > 2**31 - 1:\n                return 2**31 - 1\n            if dividend < -2**31:\n                return -2**31\n            return -dividend\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        \n        if dividend > 0 and divisor > 0:\n            sign = 1\n        elif dividend < 0 and divisor < 0:\n            sign = 1\n        else:\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        \n        while dividend >= divisor:\n            dividend -= divisor\n            quotient += 1\n        \n        return sign * quotient", "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        sign = 1\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0):\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        ans = 0\n        while dividend >= divisor:\n            x = 0\n            while dividend >= (divisor << x):\n                x += 1\n            x -= 1\n            ans += 1 << x\n            dividend -= divisor << x\n        \n        return sign * ans"], ["class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'A'\n            dfs(i - 1, j)\n            dfs(i + 1, j)\n            dfs(i, j - 1)\n            dfs(i, j + 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'", "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or j < 0 or i >= m or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'A'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'", "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or j < 0 or i >= m or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'A'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'", "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'A'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'", "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'A'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'A':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'"], ["class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        d = {}\n        for i, num in enumerate(nums):\n            if target - num in d:\n                return [d[target - num], i]\n            d[num] = i", "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        d = {}\n        for i, n in enumerate(nums):\n            if target - n in d:\n                return [d[target - n], i]\n            d[n] = i\n", "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        d = {}\n        for i, num in enumerate(nums):\n            if target - num in d:\n                return [d[target - num], i]\n            d[num] = i\n", "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        d = {}\n        for i, num in enumerate(nums):\n            if target - num in d:\n                return [d[target - num], i]\n            d[num] = i\n        return []\n", "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        d = {}\n        for i, n in enumerate(nums):\n            if target - n in d:\n                return [d[target - n], i]\n            d[n] = i"], ["class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    c = a + b, a - b, b - a, a * b\n                    if a: c += b / a,\n                    if b: c += a / b,\n                    for k in range(len(c)):\n                        if dfs(cards[:i] + cards[i + 1:j] + cards[j + 1:] + [c[k]]):\n                            return True\n            return False\n        return dfs(cards)", "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    c = a + b, a - b, b - a, a * b\n                    if a: c += b / a,\n                    if b: c += a / b,\n                    for k in range(len(c)):\n                        if dfs(cards[:i] + cards[i + 1:j] + cards[j + 1:] + [c[k]]):\n                            return True\n            return False\n        return dfs(cards)\n", "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(cards) == 1:\n            return abs(cards[0] - 24) < 1e-6\n        for i in range(len(cards)):\n            for j in range(i + 1, len(cards)):\n                a, b = cards[i], cards[j]\n                c = cards[:i] + cards[i + 1:j] + cards[j + 1:]\n                for x in [a + b, a - b, b - a, a * b]:\n                    if self.judgePoint24(c + [x]):\n                        return True\n                if a and b:\n                    if self.judgePoint24(c + [a / b]):\n                        return True\n                    if self.judgePoint24(c + [b / a]):\n                        return True\n        return False", "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    c = a + b, a - b, b - a, a * b\n                    if a: c += b / a,\n                    if b: c += a / b,\n                    for k in range(len(c)):\n                        if dfs(cards[:i] + cards[i + 1:j] + cards[j + 1:] + [c[k]]):\n                            return True\n            return False\n        return dfs(cards)\n", "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(cards) == 1:\n            return abs(cards[0] - 24) < 1e-6\n        for i in range(len(cards)):\n            for j in range(i + 1, len(cards)):\n                a, b = cards[i], cards[j]\n                c = cards[:i] + cards[i + 1:j] + cards[j + 1:]\n                for x in [a + b, a - b, b - a, a * b]:\n                    if self.judgePoint24(c + [x]):\n                        return True\n                if b != 0 and self.judgePoint24(c + [a / b]):\n                    return True\n                if a != 0 and self.judgePoint24(c + [b / a]):\n                    return True\n        return False"], ["class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        n = len(s)\n        m = len(p)\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n        for i in range(1, m + 1):\n            if p[i - 1] == '*':\n                dp[0][i] = dp[0][i - 1]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n        return dp[n][m]\n", "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        n = len(s)\n        m = len(p)\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n        for i in range(1, m + 1):\n            if p[i - 1] == '*':\n                dp[0][i] = dp[0][i - 1]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n        return dp[n][m]\n", "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or (i > 0 and dp[i - 1][j])\n                else:\n                    dp[i][j] = i > 0 and dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '?')\n        return dp[m][n]", "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or (i > 0 and dp[i - 1][j])\n                else:\n                    dp[i][j] = i > 0 and dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '?')\n        return dp[m][n]\n", "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        m = len(s)\n        n = len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n        return dp[m][n]"], ["class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate\n", "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate\n", "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate\n", "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = {}\n        for i in nums:\n            if i in count:\n                count[i] += 1\n            else:\n                count[i] = 1\n        \n        max_count = max(count.values())\n        for i in count:\n            if count[i] == max_count:\n                return i", "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate\n"], ["class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets)[::-1]:\n            graph[a].append(b)\n        \n        route = []\n        def visit(a):\n            while graph[a]:\n                visit(graph[a].pop())\n            route.append(a)\n        \n        visit('JFK')\n        return route[::-1]", "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets)[::-1]:\n            graph[a].append(b)\n        \n        route = []\n        def dfs(a):\n            while graph[a]:\n                dfs(graph[a].pop())\n            route.append(a)\n        \n        dfs('JFK')\n        return route[::-1]", "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets)[::-1]:\n            graph[a].append(b)\n        route = []\n        def dfs(a):\n            while graph[a]:\n                dfs(graph[a].pop())\n            route.append(a)\n        dfs('JFK')\n        return route[::-1]", "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets)[::-1]:\n            graph[a].append(b)\n        \n        route = []\n        def dfs(a):\n            while graph[a]:\n                dfs(graph[a].pop(0))\n            route.append(a)\n        \n        dfs('JFK')\n        return route[::-1]"], ["class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                l, r = j + 1, len(nums) - 1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s < target:\n                        l += 1\n                    elif s > target:\n                        r -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l - 1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r + 1]:\n                            r -= 1\n        return res\n", "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                l, r = j + 1, len(nums) - 1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s < target:\n                        l += 1\n                    elif s > target:\n                        r -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l - 1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r + 1]:\n                            r -= 1\n        return res", "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, len(nums) - 1\n                while left < right:\n                    s = nums[i] + nums[j] + nums[left] + nums[right]\n                    if s < target:\n                        left += 1\n                    elif s > target:\n                        right -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n        return res\n", "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        ans = []\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    for l in range(k + 1, n):\n                        if nums[i] + nums[j] + nums[k] + nums[l] == target:\n                            ans.append([nums[i], nums[j], nums[k], nums[l]])\n        return ans", "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, len(nums) - 1\n                while left < right:\n                    s = nums[i] + nums[j] + nums[left] + nums[right]\n                    if s < target:\n                        left += 1\n                    elif s > target:\n                        right -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n        return res"], ["class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # create a list of (height, right edge) pairs\n        # where height is the height of the building at the left edge\n        # and right edge is the right edge of the building\n        # we use a negative sign because we want to sort by right edge in descending order\n        buildings = [(b[2], -b[1]) for b in buildings]\n        \n        # create a list of (height, right edge) pairs\n        # where height is the height of the building at the right edge\n        # and right edge is the right edge of the building\n        # we use a negative sign because we want to sort by right edge in descending order\n        buildings.extend([(-b[2], -b[0]) for b in buildings])\n        \n        # sort the buildings by right edge in descending order\n        buildings.sort(key=lambda x: x[1], reverse=True)\n        \n        # create a list of (height, right edge) pairs\n        # where height is the height of the building at the right edge\n        # and right edge is the right edge of the building\n        # we use a negative sign because we want to sort by right edge in descending order\n        buildings.extend([(b[2], b[0]) for b in buildings])\n        \n        # create a list of (height, right edge) pairs\n        # where height is the height of the building at the right edge\n        # and right edge is the right edge of the building\n        # we use a negative sign because we want to sort by right edge in descending order\n        buildings.extend([(-b[2], b[1]) for b in buildings])\n        \n        # create a list of (height, right edge) pairs\n        # where height is the height of the building at the right edge\n        # and right edge is the right edge of the building\n        # we use a negative sign because we want to sort by right edge in descending order\n        buildings.extend([(b[2], b[1]) for b in buildings])\n        \n        # create a list of (height, right edge) pairs\n        # where height is the height of the building at the right edge\n        # and right edge is the right edge of the building\n        # we use a negative sign because we want to sort by right edge in descending order\n        buildings.extend([(-b[2], b[0]) for b in buildings])\n        \n        # create a list of (height, right edge) pairs\n        # where height is the height of the building at the right edge\n        # and right edge is the right edge of the building\n        # we use a negative sign because we want to sort by right edge in descending order\n        buildings.extend([(b[2], b[0]) for b in buildings])\n        \n        # create a list of (height, right edge) pairs\n        # where height is the height of the building at the right edge\n        # and right edge is the right edge of the building\n        # we use a negative sign because we want to sort by right edge in descending order\n        buildings.extend([(-b[2], b[1]) for b in buildings])\n        \n        # create a list of (height, right edge) pairs\n        # where height is the height of the building at the right edge\n        # and right edge is the right edge of the building\n        # we use a negative sign because we want to sort by right edge in descending", "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"], ["class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        s.reverse()", "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        s.reverse()", "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        s.reverse()\n", "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        s.reverse()\n", "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        s.reverse()\n"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(triangle)\n        dp = [0] * n\n        dp[0] = triangle[0][0]\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + triangle[i][i]\n            for j in range(i - 1, 0, -1):\n                dp[j] = min(dp[j - 1], dp[j]) + triangle[i][j]\n            dp[0] += triangle[i][0]\n        return min(dp)\n", "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(triangle)\n        dp = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1):\n                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n        return dp[0]", "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(triangle)\n        dp = [0] * n\n        dp[0] = triangle[0][0]\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + triangle[i][i]\n            for j in range(i - 1, 0, -1):\n                dp[j] = min(dp[j - 1], dp[j]) + triangle[i][j]\n            dp[0] += triangle[i][0]\n        return min(dp)\n", "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(triangle)\n        dp = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1):\n                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n        return dp[0]\n", "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(triangle)\n        dp = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1):\n                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n        return dp[0]"], ["class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        units = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 10:\n                return units[num]\n            elif num < 20:\n                return teens[num - 10]\n            elif num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            elif num < 1000:\n                return units[num // 100] + \" Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()", "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        units = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 10:\n                return units[num]\n            elif num < 20:\n                return teens[num - 10]\n            elif num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            elif num < 1000:\n                return units[num // 100] + \" Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()", "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        units = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 10:\n                return units[num]\n            elif num < 20:\n                return teens[num - 10]\n            elif num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            else:\n                return units[num // 100] + \" Hundred \" + helper(num % 100)\n        \n        result = \"\"\n        for i in range(len(thousands)):\n            if num % 1000 != 0:\n                result = helper(num % 1000) + \" \" + thousands[i] + \" \" + result\n            num //= 1000\n        \n        return result.strip()", "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        units = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 10:\n                return units[num]\n            elif num < 20:\n                return teens[num - 10]\n            elif num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            elif num < 1000:\n                return units[num // 100] + \" Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()\n", "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        nums = [\n            (1000000000, \"Billion\"),\n            (1000000, \"Million\"),\n            (1000, \"Thousand\"),\n            (100, \"Hundred\"),\n            (90, \"Ninety\"),\n            (80, \"Eighty\"),\n            (70, \"Seventy\"),\n            (60, \"Sixty\"),\n            (50, \"Fifty\"),\n            (40, \"Forty\"),\n            (30, \"Thirty\"),\n            (20, \"Twenty\"),\n            (19, \"Nineteen\"),\n            (18, \"Eighteen\"),\n            (17, \"Seventeen\"),\n            (16, \"Sixteen\"),\n            (15, \"Fifteen\"),\n            (14, \"Fourteen\"),\n            (13, \"Thirteen\"),\n            (12, \"Twelve\"),\n            (11, \"Eleven\"),\n            (10, \"Ten\"),\n            (9, \"Nine\"),\n            (8, \"Eight\"),\n            (7, \"Seven\"),\n            (6, \"Six\"),\n            (5, \"Five\"),\n            (4, \"Four\"),\n            (3, \"Three\"),\n            (2, \"Two\"),\n            (1, \"One\")\n        ]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            for n, word in nums:\n                if num >= n:\n                    if n >= 100:\n                        return helper(num // n) + \" \" + word + \" \" + helper(num % n)\n                    else:\n                        return word + \" \" + helper(num % n)\n        \n        return helper(num).strip()"], ["class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10 ** 9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD\n                if j >= i:\n                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + MOD) % MOD\n        return dp[n][k]", "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(k + 1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % (10 ** 9 + 7)\n                if j >= i:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - i]) % (10 ** 9 + 7)\n        return dp[n][k]", "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        mod = 10 ** 9 + 7\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod\n                if j >= i:\n                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod\n        return dp[n][k]", "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10 ** 9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n                if j >= i:\n                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + MOD) % MOD\n        return dp[n][k]\n", "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10 ** 9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n                if j >= i:\n                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + MOD) % MOD\n        return dp[n][k]"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n + 1)]\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            parent[x] = y\n        \n        candidate_1 = None\n        candidate_2 = None\n        \n        for i, (u, v) in enumerate(edges):\n            if find(u) == find(v):\n                candidate_1 = i\n            else:\n                union(find(u), find(v))\n        \n        parent = [i for i in range(n + 1)]\n        \n        for i, (u, v) in enumerate(edges):\n            if candidate_1 == i:\n                continue\n            if find(u) == find(v):\n                candidate_2 = i\n            else:\n                union(find(u), find(v))\n        \n        if candidate_2 is None:\n            return edges[candidate_1]\n        else:\n            return edges[candidate_2]", "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [0] * (n + 1)\n        candidate = []\n        for i in range(n):\n            if parent[edges[i][1]] == 0:\n                parent[edges[i][1]] = edges[i][0]\n            else:\n                candidate.append([parent[edges[i][1]], edges[i][1]])\n                candidate.append([edges[i][0], edges[i][1]])\n                edges[i][1] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][0] == 0:\n                edges[i][0] = edges[i][1]\n                edges[i][1] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][0] == 0:\n                edges[i][0] = edges[i][1]\n                edges[i][1] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                edges[i][0] = 0\n        \n        for i in range(n):\n            if edges[i][1] == 0:\n                edges[i][1] = edges[i][0]\n                ", "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [0] * (n + 1)\n        candidate = []\n        for u, v in edges:\n            if parent[v] > 0:\n                candidate = [parent[v], v]\n                u1 = u\n                v1 = v\n            parent[v] = u\n        \n        parent = [0] * (n + 1)\n        for u, v in edges:\n            if u == u1 and v == v1:\n                continue\n            if parent[u] > 0:\n                return [parent[u], u]\n            parent[u] = v\n        return candidate", "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [0] * (n + 1)\n        candidate = []\n        for u, v in edges:\n            if parent[v] > 0:\n                candidate = [parent[v], v]\n                u1 = parent[v]\n                u2 = v\n            parent[v] = u\n        \n        uf = UnionFind(n + 1)\n        for u, v in edges:\n            if u == u1 and v == u2:\n                continue\n            if uf.union(u, v):\n                return [u, v]\n        return candidate", "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [0] * (n + 1)\n        candidate1 = None\n        candidate2 = None\n        \n        for u, v in edges:\n            if parent[v] == 0:\n                parent[v] = u\n            else:\n                candidate1 = [parent[v], v]\n                candidate2 = [u, v]\n                u = parent[v]\n                break\n        \n        for u, v in edges:\n            if u == candidate1[0] and v == candidate1[1]:\n                continue\n            while parent[u] != 0:\n                u = parent[u]\n            if u == v:\n                return candidate1 if candidate1 else [u, v]\n            parent[v] = u\n        \n        return candidate2"], ["class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(start, end):\n            if start == end:\n                ans.append(nums[:])\n            else:\n                for i in range(start, end):\n                    if nums[start] == nums[i] and start != i:\n                        continue\n                    nums[start], nums[i] = nums[i], nums[start]\n                    backtrack(start + 1, end)\n                    nums[start], nums[i] = nums[i], nums[start]\n        \n        ans = []\n        nums.sort()\n        backtrack(0, len(nums))\n        return ans", "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, temp, res):\n            if not nums:\n                res.append(temp)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i - 1]:\n                    continue\n                backtrack(nums[:i] + nums[i + 1:], temp + [nums[i]], res)\n        \n        res = []\n        nums.sort()\n        backtrack(nums, [], res)\n        return res", "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, temp, ans):\n            if not nums:\n                ans.append(temp)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i - 1]:\n                    continue\n                backtrack(nums[:i] + nums[i + 1:], temp + [nums[i]], ans)\n        \n        ans = []\n        backtrack(sorted(nums), [], ans)\n        return ans", "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(start):\n            if start == len(nums):\n                ans.append(nums[:])\n                return\n            \n            seen = set()\n            for i in range(start, len(nums)):\n                if nums[i] in seen:\n                    continue\n                seen.add(nums[i])\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n        \n        ans = []\n        backtrack(0)\n        return ans\n", "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output\n"], ["class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num\n", "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        \n        return num % 9 or 9", "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num >= 10:\n            num = sum(int(i) for i in str(num))\n        return num\n", "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(int(i) for i in str(num))\n        return num\n", "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num >= 10:\n            num = sum(int(digit) for digit in str(num))\n        return num"], ["class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2 * sum(set(nums)) - sum(nums)\n", "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in nums:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        for i in d:\n            if d[i] == 1:\n                return i", "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in nums:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        for i in d:\n            if d[i] == 1:\n                return i", "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(len(nums)):\n            ans ^= nums[i]\n        return ans\n", "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2 * sum(set(nums)) - sum(nums)"], ["class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        \n        if not s:\n            return 0\n        \n        return len(s.split()[-1])", "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        \n        if not s:\n            return 0\n        \n        return len(s.split()[-1])", "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.strip().split(' ')[-1])\n", "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.strip().split(' ')[-1])", "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        \n        if len(s) == 0:\n            return 0\n        \n        return len(s.split()[-1])\n"], ["class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(2)]\n        dp[0][0][0] = grid[0][0]\n        for turn in range(1, 2 * n):\n            for i in range(n):\n                for j in range(n):\n                    k = turn - i - j\n                    if k < 0 or k >= n or grid[i][j] == -1:\n                        continue\n                    for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] != -1:\n                            dp[turn % 2][i][j] = max(dp[turn % 2][i][j], dp[(turn - 1) % 2][ni][nj] + (grid[i][j] if i == j else grid[i][j] + grid[ni][nj]))\n        return max(dp[(2 * n - 1) % 2][n - 1][n - 1], 0)", "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(2)]\n        dp[0][0][0] = grid[0][0]\n        for t in range(1, 2 * n):\n            for i in range(n):\n                for j in range(n):\n                    k = t - i - j\n                    if k < 0 or k >= n or grid[i][j] == -1:\n                        dp[t % 2][i][j] = float('-inf')\n                        continue\n                    dp[t % 2][i][j] = grid[i][j]\n                    for di, dj in [(-1, 0), (0, -1)]:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] != -1:\n                            dp[t % 2][i][j] = max(dp[t % 2][i][j], dp[(t - 1) % 2][ni][nj])\n                    if k > 0:\n                        dp[t % 2][i][j] += dp[(t - 1) % 2][i][j]\n        return max(0, dp[(2 * n - 1) % 2][n - 1][n - 1])\n\n\n", "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(2)]\n        dp[0][0][0] = grid[0][0]\n        for t in range(1, 2 * n):\n            for i in range(n):\n                for j in range(n):\n                    k = t - i - j\n                    if k < 0 or k >= n or grid[i][j] == -1:\n                        dp[t % 2][i][j] = float('-inf')\n                        continue\n                    dp[t % 2][i][j] = grid[i][j] + max(dp[(t - 1) % 2][x][y] for x in range(i + 1) for y in range(j + 1) if grid[x][y] != -1)\n        return max(dp[(2 * n - 1) % 2][i][j] for i in range(n) for j in range(n))", "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(2)]\n        dp[0][0][0] = grid[0][0]\n        for t in range(1, 2 * n - 1):\n            for i in range(n):\n                for j in range(n):\n                    k = t - i - j\n                    if k < 0 or k >= n or grid[i][j] == -1 or (i > 0 and grid[i - 1][j] == -1) or (j > 0 and grid[i][j - 1] == -1):\n                        dp[t % 2][i][j] = float('-inf')\n                        continue\n                    if i > 0:\n                        dp[t % 2][i][j] = max(dp[t % 2][i][j], dp[(t - 1) % 2][i - 1][j])\n                    if j > 0:\n                        dp[t % 2][i][j] = max(dp[t % 2][i][j], dp[(t - 1) % 2][i][j - 1])\n                    if i > 0 and j > 0:\n                        dp[t % 2][i][j] = max(dp[t % 2][i][j], dp[(t - 1) % 2][i - 1][j - 1])\n                    dp[t % 2][i][j] += grid[i][j]\n        return max(0, dp[(2 * n - 2) % 2][n - 1][n - 1])", "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(2)]\n        dp[0][0][0] = grid[0][0]\n        for t in range(1, 2 * n):\n            for i in range(n):\n                for j in range(n):\n                    k = t - i - j\n                    if k < 0 or k >= n or grid[i][j] == -1:\n                        dp[t % 2][i][j] = float('-inf')\n                        continue\n                    dp[t % 2][i][j] = grid[i][j] + max(dp[(t - 1) % 2][x][y] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2) if 0 <= x < n and 0 <= y < n)\n        return max(0, dp[(2 * n - 1) % 2][n - 1][n - 1])"], ["class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10 ** 9 + 7\n        \n        # dp[i][j][k] = number of ways to get i P's, j A's, and k L's\n        dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(n + 1)]\n        \n        # base case: 1 way to get 0 P's, 0 A's, and 0 L's\n        dp[0][0][0] = 1\n        \n        # iterate over the number of P's\n        for i in range(1, n + 1):\n            # iterate over the number of A's\n            for j in range(2):\n                # iterate over the number of L's\n                for k in range(3):\n                    # if we can add a P\n                    if i - 1 >= 0:\n                        dp[i][j][k] += dp[i - 1][j][k]\n                    # if we can add an A\n                    if j < 1:\n                        dp[i][j + 1][k] += dp[i - 1][j][k]\n                    # if we can add a L\n                    if k < 2:\n                        dp[i][j][k + 1] += dp[i - 1][j][k]\n                    # modulo the result\n                    dp[i][j][k] %= mod\n        \n        # return the number of ways to get n P's, 0 A's, and 0 L's\n        return dp[n][0][0]\n", "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [1] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] * 2\n            if i >= 2 and dp[i - 2] == 2:\n                dp[i] -= 1\n            if i >= 3 and dp[i - 3] == 2:\n                dp[i] -= 1\n        return dp[n] % (10 ** 9 + 7)", "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10 ** 9 + 7\n        \n        # dp[i][j][k] = number of ways to get i Ps, j As, and k Ls\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(n + 1)]\n        \n        # base cases\n        dp[0][0][0] = 1\n        \n        # fill in the dp table\n        for i in range(1, n + 1):\n            for j in range(2):\n                for k in range(3):\n                    # if we can take a P\n                    if j > 0 or k > 0:\n                        dp[i][j][k] += dp[i - 1][j][k]\n                    # if we can take an A\n                    if j < 1:\n                        dp[i][j + 1][0] += dp[i - 1][j][k]\n                    # if we can take a L\n                    if k < 2:\n                        dp[i][j][k + 1] += dp[i - 1][j][k]\n                    \n                    dp[i][j][k] %= MOD\n        \n        # sum up the number of ways to get n Ps, n As, and n Ls\n        return sum(dp[n][j][k] for j in range(2) for k in range(3)) % MOD\n", "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10 ** 9 + 7\n        \n        # dp[i][j][k] = number of ways to get i Ps, j As, and k Ls\n        dp = [[[0] * 3 for _ in range(2)] for _ in range(n + 1)]\n        \n        # base case: 1 way to get 0 Ps, 0 As, and 0 Ls\n        dp[0][0][0] = 1\n        \n        # iterate over the number of Ps, As, and Ls\n        for i in range(n):\n            for j in range(2):\n                for k in range(3):\n                    # add the number of ways to get i Ps, j As, and k Ls\n                    dp[i + 1][j][k] += dp[i][j][k]\n                    dp[i + 1][j][k] %= MOD\n                    \n                    # add the number of ways to get i Ps, j + 1 As, and k Ls\n                    if j < 1:\n                        dp[i + 1][j + 1][k] += dp[i][j][k]\n                        dp[i + 1][j + 1][k] %= MOD\n                    \n                    # add the number of ways to get i Ps, j As, and k + 1 Ls\n                    if k < 2:\n                        dp[i + 1][j][k + 1] += dp[i][j][k]\n                        dp[i + 1][j][k + 1] %= MOD\n        \n        # return the number of ways to get n Ps, 0 As, and 0 Ls\n        return dp[n][0][0]", "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * 3 for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]\n            dp[i][1] = dp[i - 1][0]\n            dp[i][2] = dp[i - 1][1]\n        return dp[n][0] % (10 ** 9 + 7)"], ["class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def getNext(n):\n            totalSum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                totalSum += digit ** 2\n            return totalSum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = getNext(n)\n        \n        return n == 1\n", "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1\n", "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1\n", "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1\n", "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1\n"], ["class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n", "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l", "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n        return l\n", "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n", "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return m\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n        return l\n"], ["class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(nums)\n        last = n - 1\n        for i in range(n - 1, -1, -1):\n            if i + nums[i] >= last:\n                last = i\n        return last == 0\n", "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(nums)\n        max_reach = 0\n        for i in range(n):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True", "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(nums)\n        furthest = 0\n        for i in range(n):\n            if i > furthest:\n                return False\n            furthest = max(furthest, i + nums[i])\n        return True\n", "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n", "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n"], ["class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j - 1]\n                elif j == 0:\n                    grid[i][j] += grid[i - 1][j]\n                else:\n                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        \n        return grid[m - 1][n - 1]\n", "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j - 1]\n                elif j == 0:\n                    grid[i][j] += grid[i - 1][j]\n                else:\n                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        \n        return grid[m - 1][n - 1]\n", "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j - 1]\n                elif j == 0:\n                    grid[i][j] += grid[i - 1][j]\n                else:\n                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        \n        return grid[m - 1][n - 1]\n", "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(grid)\n        n = len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j - 1]\n                elif j == 0:\n                    grid[i][j] += grid[i - 1][j]\n                else:\n                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        return grid[m - 1][n - 1]\n", "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(grid)\n        n = len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j - 1]\n                elif j == 0:\n                    grid[i][j] += grid[i - 1][j]\n                else:\n                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        return grid[-1][-1]"], ["class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n - 1)\n        \n        res = \"\"\n        \n        i = 0\n        while i < len(prev):\n            count = 1\n            while i + 1 < len(prev) and prev[i] == prev[i + 1]:\n                count += 1\n                i += 1\n            res += str(count) + prev[i]\n            i += 1\n        \n        return res", "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n - 1)\n        res = \"\"\n        \n        i = 0\n        while i < len(prev):\n            count = 1\n            while i + 1 < len(prev) and prev[i] == prev[i + 1]:\n                count += 1\n                i += 1\n            res += str(count) + prev[i]\n            i += 1\n        \n        return res", "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n - 1)\n        \n        res = \"\"\n        \n        i = 0\n        while i < len(prev):\n            count = 1\n            while i + 1 < len(prev) and prev[i] == prev[i + 1]:\n                i += 1\n                count += 1\n            res += str(count) + prev[i]\n            i += 1\n        \n        return res", "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n - 1)\n        res = \"\"\n        \n        i = 0\n        while i < len(prev):\n            count = 1\n            while i + 1 < len(prev) and prev[i] == prev[i + 1]:\n                count += 1\n                i += 1\n            res += str(count) + prev[i]\n            i += 1\n        \n        return res", "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n - 1)\n        \n        res = \"\"\n        \n        i = 0\n        while i < len(prev):\n            count = 1\n            while i + 1 < len(prev) and prev[i] == prev[i + 1]:\n                count += 1\n                i += 1\n            res += str(count) + prev[i]\n            i += 1\n        \n        return res"], ["class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(x):\n            cnt, cur = 1, 0\n            for i in nums:\n                if cur + i > x:\n                    cnt += 1\n                    cur = i\n                else:\n                    cur += i\n            return cnt <= k\n        \n        l, r = max(nums), sum(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if check(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def possible(m):\n            cnt, cur = 1, 0\n            for x in nums:\n                if cur + x > m:\n                    cnt += 1\n                    cur = x\n                else:\n                    cur += x\n            return cnt <= k\n        \n        lo, hi = max(nums), sum(nums)\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if possible(mi):\n                hi = mi\n            else:\n                lo = mi + 1\n        return lo", "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def possible(m):\n            count, total = 1, 0\n            for x in nums:\n                total += x\n                if total > m:\n                    total = x\n                    count += 1\n            return count <= k\n        \n        lo, hi = max(nums), sum(nums)\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if possible(mi):\n                hi = mi\n            else:\n                lo = mi + 1\n        return lo\n", "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(x):\n            cnt = 1\n            cur = 0\n            for i in range(len(nums)):\n                if cur + nums[i] > x:\n                    cnt += 1\n                    cur = nums[i]\n                else:\n                    cur += nums[i]\n            return cnt <= k\n        \n        l = max(nums)\n        r = sum(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if check(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def possible(m):\n            cnt = 1\n            cur = 0\n            for x in nums:\n                if cur + x > m:\n                    cnt += 1\n                    cur = x\n                else:\n                    cur += x\n            return cnt <= k\n        \n        lo = max(nums)\n        hi = sum(nums)\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if possible(mi):\n                hi = mi\n            else:\n                lo = mi + 1\n        return lo\n"], ["class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] >= nums[l]:\n                if target >= nums[l] and target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if target > nums[mid] and target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return -1", "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return -1", "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        \n        while l <= r:\n            mid = (l + r) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[l] <= nums[mid]:\n                if nums[l] <= target and target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target and target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        \n        return -1", "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1", "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] >= nums[l]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return -1"], ["class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"pqrs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\"\n        }\n        \n        def backtrack(index, path):\n            if len(path) == len(digits):\n                result.append(\"\".join(path))\n                return\n            \n            for letter in digit_to_letters[digits[index]]:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n        \n        result = []\n        backtrack(0, [])\n        return result", "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"pqrs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\"\n        }\n        \n        def backtrack(index, path):\n            if len(path) == len(digits):\n                result.append(\"\".join(path))\n                return\n            \n            for letter in digit_to_letters[digits[index]]:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n        \n        result = []\n        backtrack(0, [])\n        return result\n", "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(index, path):\n            if len(path) == len(digits):\n                result.append(''.join(path))\n                return\n            \n            for letter in digit_to_letters[digits[index]]:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n        \n        result = []\n        backtrack(0, [])\n        return result\n", "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        d = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(i, cur):\n            if i == len(digits):\n                ans.append(cur)\n                return\n            \n            for c in d[digits[i]]:\n                backtrack(i + 1, cur + c)\n        \n        ans = []\n        backtrack(0, '')\n        return ans", "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(index, path):\n            if len(path) == len(digits):\n                result.append(''.join(path))\n                return\n            \n            for letter in digit_to_letters[digits[index]]:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n        \n        result = []\n        backtrack(0, [])\n        return result\n"], ["class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(remain, comb, start):\n            if remain == 0:\n                output.append(list(comb))\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > remain:\n                    break\n                comb.append(candidates[i])\n                backtrack(remain - candidates[i], comb, i)\n                comb.pop()\n        \n        output = []\n        backtrack(target, [], 0)\n        return output\n", "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        \n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            \n            if i >= len(candidates) or total > target:\n                return\n            \n            cur.append(candidates[i])\n            dfs(i, cur, total + candidates[i])\n            \n            cur.pop()\n            dfs(i + 1, cur, total)\n            \n        dfs(0, [], 0)\n        return res", "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        candidates.sort()\n        self.dfs(candidates, target, 0, [], ans)\n        return ans\n    \n    def dfs(self, nums, target, index, path, ans):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            ans.append(path)\n            return \n        for i in range(index, len(nums)):\n            self.dfs(nums, target - nums[i], i, path + [nums[i]], ans)\n", "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(remain, start, comb, res):\n            if remain == 0:\n                res.append(list(comb))\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > remain:\n                    break\n                comb.append(candidates[i])\n                backtrack(remain - candidates[i], i, comb, res)\n                comb.pop()\n        \n        res = []\n        backtrack(target, 0, [], res)\n        return res", "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(i, cur, total):\n            if total == target:\n                ans.append(cur.copy())\n                return\n            if i >= len(candidates) or total > target:\n                return\n            cur.append(candidates[i])\n            dfs(i, cur, total + candidates[i])\n            cur.pop()\n            dfs(i + 1, cur, total)\n        \n        ans = []\n        dfs(0, [], 0)\n        return ans"], ["class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        if len(n) == 1:\n            return str(int(n) - 1)\n        \n        num = int(n)\n        \n        if num < 10:\n            return str(num - 1)\n        \n        if num > 10 ** 18:\n            return str(num - 1)\n        \n        if num == 10 ** 18:\n            return str(10 ** 18 - 1)\n        \n        if num == 10 ** 17:\n            return str(10 ** 17 - 1)\n        \n        if num == 10 ** 16:\n            return str(10 ** 16 - 1)\n        \n        if num == 10 ** 15:\n            return str(10 ** 15 - 1)\n        \n        if num == 10 ** 14:\n            return str(10 ** 14 - 1)\n        \n        if num == 10 ** 13:\n            return str(10 ** 13 - 1)\n        \n        if num == 10 ** 12:\n            return str(10 ** 12 - 1)\n        \n        if num == 10 ** 11:\n            return str(10 ** 11 - 1)\n        \n        if num == 10 ** 10:\n            return str(10 ** 10 - 1)\n        \n        if num == 10 ** 9:\n            return str(10 ** 9 - 1)\n        \n        if num == 10 ** 8:\n            return str(10 ** 8 - 1)\n        \n        if num == 10 ** 7:\n            return str(10 ** 7 - 1)\n        \n        if num == 10 ** 6:\n            return str(10 ** 6 - 1)\n        \n        if num == 10 ** 5:\n            return str(10 ** 5 - 1)\n        \n        if num == 10 ** 4:\n            return str(10 ** 4 - 1)\n        \n        if num == 10 ** 3:\n            return str(10 ** 3 - 1)\n        \n        if num == 10 ** 2:\n            return str(10 ** 2 - 1)\n        \n        if num == 10 ** 1:\n            return str(10 ** 1 - 1)\n        \n        if num == 10 ** 0:\n            return str(10 ** 0 - 1)\n        \n        if num == 10 ** -1:\n            return str(10 ** -1 - 1)\n        \n        if num == 10 ** -2:\n            return str(10 ** -2 - 1)\n        \n        if num == 10 ** -3:\n            return str(10 ** -3 - 1)\n        \n        if num == 10 ** -4:\n            return str(10 ** -4 - 1)\n        \n        if num == 10 ** -5:\n            return str(10 ** -5 - 1)\n        \n        if num == 10 ** -6:\n            return str(10 ** -6 - 1)\n        \n        if num == 10 ** -7:\n            return str(10 ** -7 - 1)\n        \n        if num == 10 ** -8:\n            return str(10 ** -8 - 1)\n        \n        if num == 10 ** -9:\n            return str(10 ** -9 - 1)\n        \n        if num == 10 ** -10:\n            return str(10 ** -10 - 1)\n        \n        if num == 10 ** -11:\n            return str(10 ** -11 - 1)\n        \n        if num == 10 ** -12:\n            return str(10 ** -12 - 1)\n        \n        if num == 10 ** -13:\n            return str(10 ** -13 - 1)\n        \n        if num == 10 ** -14:\n            return str(10 ** -14 - 1)\n        \n        if num == 10 ** -15:\n            return str(10 ** -15 - 1)\n        \n        if num == 10 ** -16:\n            return str(10 ** -16 - 1)\n        \n        if num == 10 ** -17:\n            return str(10 ** -17 - 1)\n        \n        if num == 10 ** -18:\n            return str(10 ** -18 - 1)\n        \n        if num == 10 ** -19:\n            return str(10 ** -19 - 1)\n        \n        if num == 10 ** -20:\n            return str(10 ** -20 - 1)\n        \n        if num == 10 ** -21:\n            return str(10 ** -21 - 1)\n        \n        if num == 10 ** -22:\n            return str(10 ** -22 - 1)\n        \n        if num == 10 ** -23:\n            return str(10 ** -23 - 1)\n        \n        if num == 10 ** -24:\n            return str(10 ** -24 - 1)\n        \n        if num == 10 ** -25:\n            return str(10 ** -25 - 1)\n        \n        if num == 10 ** -", "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        if len(n) == 1:\n            return str(int(n) - 1)\n        \n        if n == \"1\" + \"0\" * (len(n) - 1) + \"1\":\n            return \"11\"\n        \n        if n == \"9\" * len(n):\n            return str(int(n) - 2)\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"1\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"1\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"9\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"9\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"8\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"9\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"7\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"8\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"6\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"7\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"5\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"6\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"4\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"5\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"3\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"4\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"2\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"3\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"1\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"2\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"0\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"1\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"9\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"0\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"8\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"1\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"7\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"2\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"6\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"3\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"5\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"4\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"4\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"5\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"3\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"6\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"2\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"7\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"1\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"8\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"0\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"9\"\n        \n        if n == \"1\" + \"0\" * (len(n) - 2) + \"9\":\n            return \"10\" + \"0\" * (len(n) - 2) + \"0\"\n        ", "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        if n == \"1\":\n            return \"0\"\n        \n        n = int(n)\n        \n        if n < 10:\n            return str(n - 1)\n        \n        if n < 100:\n            return str(n - 11)\n        \n        if n < 1000:\n            return str(n - 111)\n        \n        if n < 10000:\n            return str(n - 1111)\n        \n        if n < 100000:\n            return str(n - 11111)\n        \n        if n < 1000000:\n            return str(n - 111111)\n        \n        if n < 10000000:\n            return str(n - 1111111)\n        \n        if n < 100000000:\n            return str(n - 11111111)\n        \n        if n < 1000000000:\n            return str(n - 111111111)\n        \n        if n < 10000000000:\n            return str(n - 1111111111)\n        \n        if n < 100000000000:\n            return str(n - 11111111111)\n        \n        if n < 1000000000000:\n            return str(n - 111111111111)\n        \n        if n < 10000000000000:\n            return str(n - 1111111111111)\n        \n        if n < 100000000000000:\n            return str(n - 11111111111111)\n        \n        if n < 1000000000000000:\n            return str(n - 111111111111111)\n        \n        if n < 10000000000000000:\n            return str(n - 1111111111111111)\n        \n        if n < 100000000000000000:\n            return str(n - 11111111111111111)\n        \n        if n < 1000000000000000000:\n            return str(n - 111111111111111111)\n        \n        if n < 10000000000000000000:\n            return str(n - 1111111111111111111)\n        \n        if n < 100000000000000000000:\n            return str(n - 11111111111111111111)\n        \n        if n < 1000000000000000000000:\n            return str(n - 111111111111111111111)\n        \n        if n < 10000000000000000000000:\n            return str(n - 1111111111111111111111)\n        \n        if n < 100000000000000000000000:\n            return str(n - 11111111111111111111111)\n        \n        if n < 1000000000000000000000000:\n            return str(n - 111111111111111111111111)\n        \n        if n < 10000000000000000000000000:\n            return str(n - 1111111111111111111111111)\n        \n        if n < 100000000000000000000000000:\n            return str(n - 11111111111111111111111111)\n        \n        if n < 1000000000000000000000000000:\n            return str(n - 111111111111111111111111111)\n        \n        if n < 10000000000000000000000000000:\n            return str(n - 1111111111111111111111111111)\n        \n        if n < 100000000000000000000000000000:\n            return str(n - 11111111111111111111111111111)\n        \n        if n < 1000000000000000000000000000000:\n            return str(n - 111111111111111111111111111111)\n        \n        if n < 10000000000000000000000000000000:\n            return str(n - 1111111111111111111111111111111)\n        \n        if n < 100000000000000000000000000000000:\n            return str(n - 11111111111111111111111111111111)\n        \n        if n < 1000000000000000000000000000000000:\n            return str(n - 111111111111111111111111111111111)\n        \n        if n < 10000000000000000000000000000000000:\n            return str(n - 1111111111111111111111111111111111)\n        \n        if n < 100000000000000000000000000000000000:\n            return str(n - 11111111111111111111111111111111111)\n        \n        if n < 1000000000000000000000000000000000000:\n            return str(n - 111111111111111111111111111111111111)\n        \n        if n < 10000000000000000000000000000000000000:\n            return str(n - 1111111111111111111111111111111111111)\n        \n        if n < 100000000000000000000000000000000000000:\n            return str(n - 111111111111111111", "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        if len(n) == 1:\n            return str(int(n) - 1)\n        \n        if n[0] == '1' and n[1:] == '0' * (len(n) - 1):\n            return '9' * len(n)\n        \n        if n[0] == '9':\n            return '1' + '0' * (len(n) - 1) + '1'\n        \n        if n[0] == '1':\n            return '9' * (len(n) - 1) + '1'\n        \n        if n[0] == '2':\n            return '1' + '0' * (len(n) - 1) + '2'\n        \n        if n[0] == '3':\n            return '1' + '0' * (len(n) - 1) + '3'\n        \n        if n[0] == '4':\n            return '1' + '0' * (len(n) - 1) + '4'\n        \n        if n[0] == '5':\n            return '1' + '0' * (len(n) - 1) + '5'\n        \n        if n[0] == '6':\n            return '1' + '0' * (len(n) - 1) + '6'\n        \n        if n[0] == '7':\n            return '1' + '0' * (len(n) - 1) + '7'\n        \n        if n[0] == '8':\n            return '1' + '0' * (len(n) - 1) + '8'\n        \n        if n[0] == '9':\n            return '1' + '0' * (len(n) - 1) + '9'\n        \n        if n[0] == '0':\n            return '1' + '0' * (len(n) - 1) + '0'\n        \n        if n[0] == '1':\n            return '1' + '0' * (len(n) - 1) + '1'\n        \n        if n[0] == '2':\n            return '1' + '0' * (len(n) - 1) + '2'\n        \n        if n[0] == '3':\n            return '1' + '0' * (len(n) - 1) + '3'\n        \n        if n[0] == '4':\n            return '1' + '0' * (len(n) - 1) + '4'\n        \n        if n[0] == '5':\n            return '1' + '0' * (len(n) - 1) + '5'\n        \n        if n[0] == '6':\n            return '1' + '0' * (len(n) - 1) + '6'\n        \n        if n[0] == '7':\n            return '1' + '0' * (len(n) - 1) + '7'\n        \n        if n[0] == '8':\n            return '1' + '0' * (len(n) - 1) + '8'\n        \n        if n[0] == '9':\n            return '1' + '0' * (len(n) - 1) + '9'\n        \n        if n[0] == '0':\n            return '1' + '0' * (len(n) - 1) + '0'\n        \n        if n[0] == '1':\n            return '1' + '0' * (len(n) - 1) + '1'\n        \n        if n[0] == '2':\n            return '1' + '0' * (len(n) - 1) + '2'\n        \n        if n[0] == '3':\n            return '1' + '0' * (len(n) - 1) + '3'\n        \n        if n[0] == '4':\n            return '1' + '0' * (len(n) - 1) + '4'\n        \n        if n[0] == '5':\n            return '1' + '0' * (len(n) - 1) + '5'\n        \n        if n[0] == '6':\n            return '1' + '0' * (len(n) - 1) + '6'\n        \n        if n[0] == '7':\n            return '1' + '0' * (len(n) - 1) + '7'\n        \n        if n[0] == '8':\n            return '1' + '0' * (len(n) - 1) + '8'\n        \n        if n[0] == '9':\n            return '1' + '0' * (len(n) - 1) + '9'\n        \n        if n[0] == '0':\n            return '1' + '0' * (len(n) - 1) + '0'\n        \n        if n[0] == '1':\n            return '1' + '", "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        if len(n) == 1:\n            return str(int(n) - 1)\n        \n        n = int(n)\n        \n        if n < 10:\n            return str(n - 1)\n        \n        if n > 10 ** 18:\n            return str(n - 1)\n        \n        if n == 10 ** 18:\n            return str(10 ** 18 - 1)\n        \n        if n == 10 ** 17:\n            return str(10 ** 17 - 1)\n        \n        if n == 10 ** 16:\n            return str(10 ** 16 - 1)\n        \n        if n == 10 ** 15:\n            return str(10 ** 15 - 1)\n        \n        if n == 10 ** 14:\n            return str(10 ** 14 - 1)\n        \n        if n == 10 ** 13:\n            return str(10 ** 13 - 1)\n        \n        if n == 10 ** 12:\n            return str(10 ** 12 - 1)\n        \n        if n == 10 ** 11:\n            return str(10 ** 11 - 1)\n        \n        if n == 10 ** 10:\n            return str(10 ** 10 - 1)\n        \n        if n == 10 ** 9:\n            return str(10 ** 9 - 1)\n        \n        if n == 10 ** 8:\n            return str(10 ** 8 - 1)\n        \n        if n == 10 ** 7:\n            return str(10 ** 7 - 1)\n        \n        if n == 10 ** 6:\n            return str(10 ** 6 - 1)\n        \n        if n == 10 ** 5:\n            return str(10 ** 5 - 1)\n        \n        if n == 10 ** 4:\n            return str(10 ** 4 - 1)\n        \n        if n == 10 ** 3:\n            return str(10 ** 3 - 1)\n        \n        if n == 10 ** 2:\n            return str(10 ** 2 - 1)\n        \n        if n == 10 ** 1:\n            return str(10 ** 1 - 1)\n        \n        if n == 10 ** 0:\n            return str(10 ** 0 - 1)\n        \n        if n == 10 ** -1:\n            return str(10 ** -1 - 1)\n        \n        if n == 10 ** -2:\n            return str(10 ** -2 - 1)\n        \n        if n == 10 ** -3:\n            return str(10 ** -3 - 1)\n        \n        if n == 10 ** -4:\n            return str(10 ** -4 - 1)\n        \n        if n == 10 ** -5:\n            return str(10 ** -5 - 1)\n        \n        if n == 10 ** -6:\n            return str(10 ** -6 - 1)\n        \n        if n == 10 ** -7:\n            return str(10 ** -7 - 1)\n        \n        if n == 10 ** -8:\n            return str(10 ** -8 - 1)\n        \n        if n == 10 ** -9:\n            return str(10 ** -9 - 1)\n        \n        if n == 10 ** -10:\n            return str(10 ** -10 - 1)\n        \n        if n == 10 ** -11:\n            return str(10 ** -11 - 1)\n        \n        if n == 10 ** -12:\n            return str(10 ** -12 - 1)\n        \n        if n == 10 ** -13:\n            return str(10 ** -13 - 1)\n        \n        if n == 10 ** -14:\n            return str(10 ** -14 - 1)\n        \n        if n == 10 ** -15:\n            return str(10 ** -15 - 1)\n        \n        if n == 10 ** -16:\n            return str(10 ** -16 - 1)\n        \n        if n == 10 ** -17:\n            return str(10 ** -17 - 1)\n        \n        if n == 10 ** -18:\n            return str(10 ** -18 - 1)\n        \n        if n == 10 ** -19:\n            return str(10 ** -19 - 1)\n        \n        if n == 10 ** -20:\n            return str(10 ** -20 - 1)\n        \n        if n == 10 ** -21:\n            return str(10 ** -21 - 1)\n        \n        if n == 10 ** -22:\n            return str(10 ** -22 - 1)\n        \n        if n == 10 ** -23:\n            return str(10 ** -23 - 1)\n        \n        if n == 10 ** -24:\n            return str(10 ** -24 - 1)\n        \n        if n == 10 ** -25:\n            return str(10 ** -25 - 1)\n        \n        if n == 10 ** -"], ["class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        left, right = 0, n - 1\n        top, bottom = 0, n - 1\n        num = 1\n        \n        while left <= right and top <= bottom:\n            \n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n                \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n                \n        return matrix\n", "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for _ in range(n)] for _ in range(n)]\n        \n        left, right = 0, n - 1\n        top, bottom = 0, n - 1\n        num = 1\n        \n        while left <= right and top <= bottom:\n            \n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n        \n        return matrix", "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = [[0] * n for _ in range(n)]\n        \n        x, y, dx, dy = 0, 0, 1, 0\n        \n        for i in range(n * n):\n            ans[x][y] = i + 1\n            if ans[(x + dx) % n][(y + dy) % n]:\n                dx, dy = dy, -dx\n            x += dx\n            y += dy\n        \n        return ans\n", "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        \n        return matrix", "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = [[0] * n for _ in range(n)]\n        \n        left, right = 0, n - 1\n        top, bottom = 0, n - 1\n        num = 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                ans[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                ans[i][right] = num\n                num += 1\n            right -= 1\n            \n            if not (left <= right and top <= bottom):\n                break\n            \n            for i in range(right, left - 1, -1):\n                ans[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                ans[i][left] = num\n                num += 1\n            left += 1\n        \n        return ans\n"], ["class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n            x = -x\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x /= 10\n        \n        if rev > 2**31 - 1:\n            return 0\n        \n        return sign * rev\n", "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n            x = -x\n        else:\n            sign = 1\n        \n        rev = 0\n        while x != 0:\n            pop = x % 10\n            x /= 10\n            if rev > INT_MAX / 10 or (rev == INT_MAX / 10 and pop > 7):\n                return 0\n            if rev < INT_MIN / 10 or (rev == INT_MIN / 10 and pop < -8):\n                return 0\n            rev = rev * 10 + pop\n        \n        return sign * rev\n", "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n            x = -x\n        else:\n            sign = 1\n        \n        rev = 0\n        while x != 0:\n            pop = x % 10\n            x /= 10\n            if rev > INT_MAX / 10 or (rev == INT_MAX / 10 and pop > 7):\n                return 0\n            if rev < INT_MIN / 10 or (rev == INT_MIN / 10 and pop < -8):\n                return 0\n            rev = rev * 10 + pop\n        \n        return sign * rev", "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            return -self.reverse(-x)\n        \n        reversed_num = 0\n        while x > 0:\n            reversed_num = reversed_num * 10 + x % 10\n            x /= 10\n        \n        if reversed_num > 2**31 - 1:\n            return 0\n        \n        return reversed_num", "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            return -self.reverse(-x)\n        \n        reversed_num = 0\n        while x > 0:\n            reversed_num = reversed_num * 10 + x % 10\n            x //= 10\n        \n        if reversed_num > 2**31 - 1:\n            return 0\n        \n        return reversed_num"], ["class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            matrix[i].reverse()", "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            matrix[i].reverse()", "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i + 1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            matrix[i].reverse()", "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i + 1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            matrix[i].reverse()", "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            matrix[i].reverse()"], ["class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr = nums[i]\n            \n            temp = max(curr, max_product * curr, min_product * curr)\n            min_product = min(curr, max_product * curr, min_product * curr)\n            \n            max_product = temp\n            \n            result = max(max_product, result)\n        \n        return result", "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        ans = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            \n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            \n            ans = max(ans, max_product)\n        \n        return ans\n", "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        ans = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            ans = max(ans, max_product)\n        return ans\n", "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            temp = max_product\n            max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n            min_product = min(nums[i], temp * nums[i], min_product * nums[i])\n            result = max(result, max_product)\n        return result", "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        ans = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n                \n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            \n            ans = max(ans, max_product)\n        \n        return ans"], ["class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(stones)\n        dp = [set() for _ in range(n)]\n        dp[0].add(0)\n        for i in range(n):\n            for j in range(i):\n                k = stones[i] - stones[j]\n                if k > j + 1 or k < dp[j]:\n                    continue\n                dp[i].add(k)\n                if i == n - 1:\n                    return True\n        return False\n", "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(stones)\n        if n == 1:\n            return True\n        if stones[1] != 1:\n            return False\n        \n        dp = [[False] * n for _ in range(n)]\n        dp[0][1] = True\n        \n        for i in range(1, n):\n            for j in range(i):\n                k = stones[i] - stones[j]\n                if k < n and dp[j][k]:\n                    dp[i][k] = True\n                    if k + 1 < n:\n                        dp[i][k + 1] = True\n                    if k - 1 >= 0:\n                        dp[i][k - 1] = True\n        \n        return any(dp[-1])\n", "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stones = {s: i for i, s in enumerate(stones)}\n        n = len(stones)\n        dp = [set() for _ in range(n)]\n        dp[0].add(0)\n        for i in range(n):\n            for j in dp[i]:\n                for k in range(j - 1, j + 2):\n                    if k > 0 and stones[i] + k in stones:\n                        dp[stones[i] + k].add(k)\n        return bool(dp[-1])"], ["class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        n = len(score)\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        \n        # assign the rank to each score\n        for i in range(n):\n            if i == 0:\n                rank_dict[score[i]] = \"Gold Medal\"\n            elif i == 1:\n                rank_dict[score[i]] = \"Silver Medal\"\n            elif i == 2:\n                rank_dict[score[i]] = \"Bronze Medal\"\n            else:\n                rank_dict[score[i]] = str(i + 1)\n        \n        # create a list to store the rank of each score\n        rank = []\n        \n        # iterate through the original score list and append the rank to the rank list\n        for i in range(n):\n            rank.append(rank_dict[score[i]])\n        \n        return rank\n", "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        n = len(score)\n        \n        # Create a dictionary to store the original indices of the scores\n        score_dict = {score[i]: i for i in range(n)}\n        \n        # Sort the scores in descending order\n        sorted_scores = sorted(score, reverse=True)\n        \n        # Create a list to store the relative ranks\n        relative_ranks = [None] * n\n        \n        # Assign the relative ranks based on the sorted scores\n        for i, s in enumerate(sorted_scores):\n            if i == 0:\n                relative_ranks[score_dict[s]] = \"Gold Medal\"\n            elif i == 1:\n                relative_ranks[score_dict[s]] = \"Silver Medal\"\n            elif i == 2:\n                relative_ranks[score_dict[s]] = \"Bronze Medal\"\n            else:\n                relative_ranks[score_dict[s]] = str(i + 1)\n        \n        return relative_ranks\n\n\n", "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        n = len(score)\n        ans = [0] * n\n        \n        for i in range(n):\n            ans[i] = score[i]\n        \n        ans.sort(reverse = True)\n        \n        for i in range(n):\n            if ans[i] == score[0]:\n                score[0] = \"Gold Medal\"\n            elif ans[i] == score[1]:\n                score[1] = \"Silver Medal\"\n            elif ans[i] == score[2]:\n                score[2] = \"Bronze Medal\"\n            else:\n                score[i] = str(ans.index(score[i]) + 1)\n        \n        return score", "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        n = len(score)\n        rank = [0] * n\n        for i in range(n):\n            rank[i] = i\n        rank.sort(key=lambda x: score[x], reverse=True)\n        \n        ans = [0] * n\n        for i in range(n):\n            if i == 0:\n                ans[rank[i]] = \"Gold Medal\"\n            elif i == 1:\n                ans[rank[i]] = \"Silver Medal\"\n            elif i == 2:\n                ans[rank[i]] = \"Bronze Medal\"\n            else:\n                ans[rank[i]] = str(i + 1)\n        return ans\n\n", "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        n = len(score)\n        ans = [0] * n\n        \n        for i in range(n):\n            ans[i] = score[i]\n        \n        ans.sort(reverse=True)\n        \n        for i in range(n):\n            if ans[i] == score[0]:\n                score[i] = \"Gold Medal\"\n            elif ans[i] == score[1]:\n                score[i] = \"Silver Medal\"\n            elif ans[i] == score[2]:\n                score[i] = \"Bronze Medal\"\n            else:\n                score[i] = str(ans.index(score[i]) + 1)\n        \n        return score"], ["class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if len(set(s[i:j])) == j - i:\n                    ans = max(ans, j - i)\n        return ans", "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if len(set(s[i:j])) == j - i:\n                    ans = max(ans, j - i)\n        return ans\n", "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        n = len(s)\n        i = 0\n        j = 0\n        while i < n and j < n:\n            if s[j] not in s[i:j]:\n                j += 1\n                ans = max(ans, j - i)\n            else:\n                i += 1\n        return ans\n", "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        n = len(s)\n        i = 0\n        j = 0\n        while i < n and j < n:\n            if s[j] not in s[i:j]:\n                j += 1\n            else:\n                i += 1\n            ans = max(ans, j - i)\n        return ans", "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        n = len(s)\n        i = 0\n        j = 0\n        while i < n and j < n:\n            if s[j] not in s[i:j]:\n                j += 1\n            else:\n                i += 1\n            ans = max(ans, j - i)\n        return ans"], ["class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(s)\n        k = len(words)\n        m = len(words[0])\n        for i in range(n - k * m + 1):\n            seen = {}\n            for j in range(k):\n                w = s[i + j * m:i + (j + 1) * m]\n                if w in words:\n                    seen[w] = seen.get(w, 0) + 1\n                    if seen[w] > words.count(w):\n                        break\n                else:\n                    break\n            else:\n                ans.append(i)\n        return ans", "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(s)\n        m = len(words)\n        k = len(words[0])\n        \n        for i in range(n - m * k + 1):\n            seen = {}\n            for j in range(m):\n                word = s[i + j * k:i + (j + 1) * k]\n                if word in words:\n                    seen[word] = seen.get(word, 0) + 1\n                    if seen[word] > words.count(word):\n                        break\n                else:\n                    break\n            else:\n                ans.append(i)\n        return ans", "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(s)\n        k = len(words)\n        l = len(words[0])\n        \n        for i in range(n - k * l + 1):\n            seen = {}\n            for j in range(k):\n                w = s[i + j * l:i + (j + 1) * l]\n                if w in words:\n                    seen[w] = seen.get(w, 0) + 1\n                    if seen[w] > words.count(w):\n                        break\n                else:\n                    break\n            else:\n                ans.append(i)\n        return ans", "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(s)\n        k = len(words)\n        l = len(words[0])\n        for i in range(n - k * l + 1):\n            if self.isConcat(s[i:i + k * l], words):\n                ans.append(i)\n        return ans\n\n    def isConcat(self, s, words):\n        words = words[:]\n        for i in range(0, len(s), len(words[0])):\n            if words.count(s[i:i + len(words[0])]) == 0:\n                return False\n            words.remove(s[i:i + len(words[0])])\n        return True\n", "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(s)\n        m = len(words)\n        k = len(words[0])\n        for i in range(n - m * k + 1):\n            d = collections.Counter(words)\n            for j in range(m):\n                w = s[i + j * k:i + (j + 1) * k]\n                if w in d and d[w] > 0:\n                    d[w] -= 1\n                else:\n                    break\n            else:\n                ans.append(i)\n        return ans"], ["class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_so_far = 0\n        count = 0\n        for i in range(len(arr)):\n            max_so_far = max(max_so_far, arr[i])\n            if max_so_far == i:\n                count += 1\n        return count", "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = 0\n        ans = 0\n        for i, val in enumerate(arr):\n            max_val = max(max_val, val)\n            if max_val == i:\n                ans += 1\n        return ans", "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_so_far = 0\n        ans = 0\n        for i in range(len(arr)):\n            max_so_far = max(max_so_far, arr[i])\n            if max_so_far == i:\n                ans += 1\n        return ans\n", "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        max_so_far = 0\n        for i, x in enumerate(arr):\n            max_so_far = max(max_so_far, x)\n            if max_so_far == i:\n                ans += 1\n        return ans\n", "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_so_far = 0\n        count = 0\n        for i in range(len(arr)):\n            max_so_far = max(max_so_far, arr[i])\n            if max_so_far == i:\n                count += 1\n        return count"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            \n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n        return res", "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        nums.sort()\n        \n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            \n            l, r = i + 1, len(nums) - 1\n            \n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l + 1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r - 1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res", "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n        return res\n", "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res", "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"], ["class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            dp[i][0] = i\n        \n        for j in range(n + 1):\n            dp[0][j] = j\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]", "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            dp[i][0] = i\n        for j in range(1, n + 1):\n            dp[0][j] = j\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]", "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            dp[i][0] = i\n        \n        for j in range(1, n + 1):\n            dp[0][j] = j\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]\n\n", "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m][n]", "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m][n]"], ["class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        return bin(x ^ y).count('1')", "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        return bin(x ^ y).count('1')", "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        return bin(x ^ y).count('1')\n", "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        return bin(x ^ y).count('1')\n", "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        return bin(x ^ y).count('1')"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            i, j, count = 0, 0, 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    nums[i + j] = left[i]\n                    i += 1\n                else:\n                    nums[i + j] = right[j]\n                    j += 1\n                    count += len(left) - i\n            while i < len(left):\n                nums[i + j] = left[i]\n                i += 1\n            while j < len(right):\n                nums[i + j] = right[j]\n                j += 1\n            return count\n        \n        return merge_sort(nums)\n", "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge_sort(nums, start, end):\n            if start >= end:\n                return 0\n            \n            mid = (start + end) // 2\n            count = merge_sort(nums, start, mid) + merge_sort(nums, mid + 1, end)\n            \n            i, j = start, mid + 1\n            while i <= mid and j <= end:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            \n            nums[start:end + 1] = sorted(nums[start:end + 1])\n            return count\n        \n        return merge_sort(nums, 0, len(nums) - 1)\n", "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge_sort(nums, left, right):\n            if left >= right:\n                return 0\n            \n            mid = (left + right) // 2\n            count = merge_sort(nums, left, mid) + merge_sort(nums, mid + 1, right)\n            \n            i, j = left, mid + 1\n            while i <= mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            \n            nums[left:right + 1] = sorted(nums[left:right + 1])\n            return count\n        \n        return merge_sort(nums, 0, len(nums) - 1)", "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i = j = k = 0\n            count = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= 2 * right[j]:\n                    i += 1\n                else:\n                    count += len(left) - i\n                    j += 1\n            merged = left[i:] + right[j:]\n            return merged, count\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums, 0\n            mid = len(nums) // 2\n            left, c1 = merge_sort(nums[:mid])\n            right, c2 = merge_sort(nums[mid:])\n            merged, c3 = merge(left, right)\n            return merged, c1 + c2 + c3\n        \n        _, count = merge_sort(nums)\n        return count\n", "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            ans = 0\n            while i < len(left) and j < len(right):\n                if left[i] > right[j] * 2:\n                    ans += len(left) - i\n                    j += 1\n                else:\n                    i += 1\n            return ans + merge(left, right[j:]) + merge(left[i:], right)\n        \n        return merge(nums, nums[::-1])"], ["class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        while tx >= sx and ty >= sy:\n            if tx == ty:\n                break\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    return (tx - sx) % ty == 0\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    return (ty - sy) % tx == 0\n        return tx == sx and ty == sy", "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        while tx >= sx and ty >= sy:\n            if tx == ty:\n                break\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    return (tx - sx) % ty == 0\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    return (ty - sy) % tx == 0\n        return tx == sx and ty == sy\n", "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == ty:\n                break\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    return (tx - sx) % ty == 0\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    return (ty - sy) % tx == 0\n        return tx == sx and ty == sy\n", "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        while tx >= sx and ty >= sy:\n            if tx == ty:\n                break\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    return (tx - sx) % ty == 0\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    return (ty - sy) % tx == 0\n        return tx == sx and ty == sy", "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        while tx >= sx and ty >= sy:\n            if tx == ty:\n                break\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    return (tx - sx) % ty == 0\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    return (ty - sy) % tx == 0\n        return tx == sx and ty == sy"], ["class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            v1_val = v1[i] if i < len(v1) else 0\n            v2_val = v2[i] if i < len(v2) else 0\n            \n            if v1_val < v2_val:\n                return -1\n            elif v1_val > v2_val:\n                return 1\n        \n        return 0", "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            v1_val = v1[i] if i < len(v1) else 0\n            v2_val = v2[i] if i < len(v2) else 0\n            \n            if v1_val > v2_val:\n                return 1\n            elif v1_val < v2_val:\n                return -1\n        \n        return 0", "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i >= len(v1):\n                v1.append(0)\n            if i >= len(v2):\n                v2.append(0)\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        return 0", "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            \n            if i >= len(v1):\n                v1.append('0')\n                \n            if i >= len(v2):\n                v2.append('0')\n                \n            if int(v1[i]) > int(v2[i]):\n                return 1\n                \n            elif int(v1[i]) < int(v2[i]):\n                return -1\n                \n        return 0", "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            v1_val = v1[i] if i < len(v1) else 0\n            v2_val = v2[i] if i < len(v2) else 0\n            \n            if v1_val < v2_val:\n                return -1\n            elif v1_val > v2_val:\n                return 1\n        \n        return 0\n\n"], ["class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(1, len(prices)):\n            ans += max(0, prices[i] - prices[i - 1])\n        return ans", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(len(prices) - 1):\n            if prices[i + 1] > prices[i]:\n                ans += prices[i + 1] - prices[i]\n        return ans\n", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        n = len(prices)\n        for i in range(n):\n            for j in range(i + 1, n):\n                ans = max(ans, prices[j] - prices[i])\n        return ans\n", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        n = len(prices)\n        for i in range(n):\n            for j in range(i + 1, n):\n                ans = max(ans, prices[j] - prices[i])\n        return ans\n", "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_profit = 0\n        for i in range(len(prices) - 1):\n            if prices[i + 1] > prices[i]:\n                max_profit += prices[i + 1] - prices[i]\n        return max_profit\n"], ["class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        \n        q = []\n        \n        time = 0\n        \n        for duration, lastDay in courses:\n            heapq.heappush(q, -duration)\n            time += duration\n            \n            if time > lastDay:\n                time += heapq.heappop(q)\n        \n        return len(q)", "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        \n        heap = []\n        time = 0\n        \n        for duration, lastDay in courses:\n            time += duration\n            heapq.heappush(heap, -duration)\n            \n            if time > lastDay:\n                time += heapq.heappop(heap)\n        \n        return len(heap)", "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for duration, lastDay in courses:\n            time += duration\n            heapq.heappush(heap, -duration)\n            if time > lastDay:\n                time += heapq.heappop(heap)\n        return len(heap)", "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        \n        heap = []\n        time = 0\n        \n        for duration, lastDay in courses:\n            time += duration\n            heapq.heappush(heap, -duration)\n            \n            if time > lastDay:\n                time += heapq.heappop(heap)\n        \n        return len(heap)", "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        \n        heap = []\n        time = 0\n        \n        for duration, lastDay in courses:\n            time += duration\n            heapq.heappush(heap, -duration)\n            \n            if time > lastDay:\n                time += heapq.heappop(heap)\n        \n        return len(heap)"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        return s in (s + s)[1:-1]\n", "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s in (s + s)[1:-1]", "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s in (s + s)[1:-1]\n", "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        return s in (s + s)[1:-1]\n", "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        return s in (s + s)[1:-1]\n"], ["class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        \n        return dp[n]", "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        \n        return dp[n]", "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        return dp[n]", "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        return dp[n]", "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        \n        return dp[n]"], ["class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in nums:\n            if i not in d:\n                d[i] = 1\n            else:\n                d[i] += 1\n        \n        for i in d:\n            if d[i] == 1:\n                return i\n\n", "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in nums:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        for i in d:\n            if d[i] == 1:\n                return i", "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in nums:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        for i in d:\n            if d[i] == 1:\n                return i", "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(32):\n            bit_sum = sum((num >> i) & 1 for num in nums)\n            if bit_sum % 3:\n                ans |= 1 << i\n        return ans if ans <= 2 ** 31 - 1 else ans - 2 ** 32", "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in nums:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        for i in d:\n            if d[i] == 1:\n                return i"], ["class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def count(s):\n            c = [0] * 26\n            for ch in s:\n                c[ord(ch) - ord('a')] += 1\n            return c\n        \n        memo = {}\n        \n        def dp(t):\n            if t == 0:\n                return 0\n            if t in memo:\n                return memo[t]\n            \n            res = float('inf')\n            for sticker in stickers:\n                new_t = t[:]\n                for ch in sticker:\n                    while new_t[ord(ch) - ord('a')] > 0:\n                        new_t[ord(ch) - ord('a')] -= 1\n                        t[ord(ch) - ord('a')] -= 1\n                if any(t):\n                    res = min(res, dp(t) + 1)\n                for ch in sticker:\n                    t[ord(ch) - ord('a')] += 1\n                \n            memo[t] = res\n            return res\n        \n        return dp(count(target)) if any(target) else 0", "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def count(s):\n            c = [0] * 26\n            for ch in s:\n                c[ord(ch) - ord('a')] += 1\n            return c\n        \n        stickers = [count(s) for s in stickers]\n        \n        @lru_cache(None)\n        def dp(t):\n            if t == 0:\n                return 0\n            res = float('inf')\n            for s in stickers:\n                if s[t - 1] > 0:\n                    t1 = t\n                    for i in range(26):\n                        if s[i] > 0:\n                            t1 -= min(s[i], target[i])\n                    res = min(res, dp(t1) + 1)\n            return res\n        \n        res = dp(len(target))\n        return res if res < float('inf') else -1", "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # Build a dictionary of the stickers\n        stickers_dict = {}\n        for sticker in stickers:\n            for char in sticker:\n                if char in stickers_dict:\n                    stickers_dict[char] += 1\n                else:\n                    stickers_dict[char] = 1\n        \n        # Build a dictionary of the target\n        target_dict = {}\n        for char in target:\n            if char in target_dict:\n                target_dict[char] += 1\n            else:\n                target_dict[char] = 1\n        \n        # Build a dictionary of the target that is not in the stickers\n        target_not_in_stickers = {}\n        for char in target_dict:\n            if char not in stickers_dict:\n                target_not_in_stickers[char] = target_dict[char]\n        \n        # Build a dictionary of the target that is in the stickers\n        target_in_stickers = {}\n        for char in target_dict:\n            if char in stickers_dict:\n                target_in_stickers[char] = target_dict[char]\n        \n        # Build a dictionary of the target that is in the stickers and not in the target\n        target_in_stickers_not_in_target = {}\n        for char in target_in_stickers:\n            if char not in target_not_in_stickers:\n                target_in_stickers_not_in_target[char] = target_in_stickers[char]\n        \n        # Build a dictionary of the target that is in the stickers and not in the target and not in the stickers\n        target_in_stickers_not_in_target_not_in_stickers = {}\n        for char in target_in_stickers_not_in_target:\n            if char not in stickers_dict:\n                target_in_stickers_not_in_target_not_in_stickers[char] = target_in_stickers_not_in_target[char]\n        \n        # Build a dictionary of the target that is in the stickers and not in the target and not in the stickers and not in the target\n        target_in_stickers_not_in_target_not_in_stickers_not_in_target = {}\n        for char in target_in_stickers_not_in_target_not_in_stickers:\n            if char not in target_dict:\n                target_in_stickers_not_in_target_not_in_stickers_not_in_target[char] = target_in_stickers_not_in_target_not_in_stickers[char]\n        \n        # Build a dictionary of the target that is in the stickers and not in the target and not in the stickers and not in the target and not in the target\n        target_in_stickers_not_in_target_not_in_stickers_not_in_target_not_in_target = {}\n        for char in target_in_stickers_not_in_target_not_in_stickers_not_in_target:\n            if char not in target_dict:\n                target_in_stickers_not_in_target_not_in_stickers_not_in_target_not_in_target[char] = target_in_stickers_not_in_target_not_in_stickers_not_in_target[char]\n        \n        # Build a dictionary of the target that is in the stickers and not in the target and not in the stickers and not in the target and not in the target and not in the target\n        target_in_stickers_not_in_target_not_in_stickers_not_in_target_not_in_target_not_in_target = {}\n        for char in target_in_stickers_not_in_target_not_in_stickers_not_in_target_not_in_target:\n            if char not in target_dict:\n                target_in_stickers_not_in_target_not_in_stickers_not_in_target_not_in_target_not_in_target[char] = target_in_stickers_not_in_target_not_in_stickers_not_in_target_not_in_target[char]\n        \n        #", "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # Build a dictionary of the stickers\n        stickers_dict = {}\n        for sticker in stickers:\n            for letter in sticker:\n                if letter in stickers_dict:\n                    stickers_dict[letter] += 1\n                else:\n                    stickers_dict[letter] = 1\n        \n        # Build a dictionary of the target\n        target_dict = {}\n        for letter in target:\n            if letter in target_dict:\n                target_dict[letter] += 1\n            else:\n                target_dict[letter] = 1\n        \n        # Build a dictionary of the target minus the stickers\n        target_minus_stickers_dict = {}\n        for letter in target_dict:\n            if letter in stickers_dict:\n                if target_dict[letter] > stickers_dict[letter]:\n                    target_minus_stickers_dict[letter] = target_dict[letter] - stickers_dict[letter]\n            else:\n                target_minus_stickers_dict[letter] = target_dict[letter]\n        \n        # Build a dictionary of the stickers minus the target\n        stickers_minus_target_dict = {}\n        for letter in stickers_dict:\n            if letter in target_dict:\n                if stickers_dict[letter] > target_dict[letter]:\n                    stickers_minus_target_dict[letter] = stickers_dict[letter] - target_dict[letter]\n            else:\n                stickers_minus_target_dict[letter] = stickers_dict[letter]\n        \n        # Build a dictionary of the target minus the stickers minus the target\n        target_minus_stickers_minus_target_dict = {}\n        for letter in target_minus_stickers_dict:\n            if letter in stickers_minus_target_dict:\n                if target_minus_stickers_dict[letter] > stickers_minus_target_dict[letter]:\n                    target_minus_stickers_minus_target_dict[letter] = target_minus_stickers_dict[letter] - stickers_minus_target_dict[letter]\n            else:\n                target_minus_stickers_minus_target_dict[letter] = target_minus_stickers_dict[letter]\n        \n        # Build a dictionary of the stickers minus the target minus the target\n        stickers_minus_target_minus_target_dict = {}\n        for letter in stickers_minus_target_dict:\n            if letter in target_minus_stickers_dict:\n                if stickers_minus_target_dict[letter] > target_minus_stickers_dict[letter]:\n                    stickers_minus_target_minus_target_dict[letter] = stickers_minus_target_dict[letter] - target_minus_stickers_dict[letter]\n            else:\n                stickers_minus_target_minus_target_dict[letter] = stickers_minus_target_dict[letter]\n        \n        # Build a dictionary of the target minus the stickers minus the target minus the target\n        target_minus_stickers_minus_target_minus_target_dict = {}\n        for letter in target_minus_stickers_minus_target_dict:\n            if letter in stickers_minus_target_minus_target_dict:\n                if target_minus_stickers_minus_target_dict[letter] > stickers_minus_target_minus_target_dict[letter]:\n                    target_minus_stickers_minus_target_minus_target_dict[letter] = target_minus_stickers_minus_target_dict[letter] - stickers_minus_target_minus_target_dict[letter]\n            else:\n                target_minus_stickers_minus_target_minus_target_dict[letter] = target_minus_stickers_minus_target_dict[letter]\n        \n        # Build a dictionary of the stickers minus the target minus the target minus the target\n        stickers_minus_target_minus_target_minus_target_dict = {}\n        for letter in stickers_minus_target_minus_target_dict:\n            if letter in target_minus_stickers_minus_target_dict:\n                if stickers_minus_target_minus_target_dict[letter] > target_minus_stickers_minus_target_dict[letter]:\n                    stickers_minus_", "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def count(s):\n            c = [0] * 26\n            for ch in s:\n                c[ord(ch) - ord('a')] += 1\n            return c\n        \n        stickers = [count(s) for s in stickers]\n        \n        @lru_cache(None)\n        def dp(t):\n            if t == 0:\n                return 0\n            res = float('inf')\n            for s in stickers:\n                if s[t - ord('a')] > 0:\n                    res = min(res, dp(t - ord('a')) + 1)\n            return res\n        \n        res = dp(ord(target[-1]))\n        return res if res != float('inf') else -1"], ["class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][k - 1] + dp[k][j] for k in range(i + 1, j + 1))\n        \n        return dp[0][n - 1]", "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                dp[i][j] = dp[i + 1][j] + 1\n                for k in range(i + 1, j + 1):\n                    if s[k] == s[i]:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j])\n        return dp[0][n - 1]", "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][k] + dp[k + 1][j] for k in range(i, j))\n        return dp[0][n - 1]", "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                dp[i][j] = dp[i + 1][j] + 1\n                for k in range(i + 1, j + 1):\n                    if s[k] == s[i]:\n                        dp[i][j] = min(dp[i][j], dp[i + 1][k - 1] + dp[k][j])\n        return dp[0][n - 1]\n", "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                dp[i][j] = dp[i + 1][j] + 1\n                for k in range(i + 1, j + 1):\n                    if s[i] == s[k]:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k][j])\n        \n        return dp[0][n - 1]"], ["class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            pivot = left + (right - left) // 2\n            num = pivot * pivot\n            \n            if num > x:\n                right = pivot - 1\n            elif num < x:\n                left = pivot + 1\n            else:\n                return pivot\n        \n        return right\n", "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        while left <= right:\n            pivot = left + (right - left) // 2\n            if pivot > x // pivot:\n                right = pivot - 1\n            else:\n                left = pivot + 1\n        return right\n", "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            pivot = left + (right - left) // 2\n            num = pivot * pivot\n            \n            if num > x:\n                right = pivot - 1\n            elif num < x:\n                left = pivot + 1\n            else:\n                return pivot\n        \n        return right\n", "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            pivot = left + (right - left) // 2\n            num = pivot * pivot\n            \n            if num > x:\n                right = pivot - 1\n            elif num < x:\n                left = pivot + 1\n            else:\n                return pivot\n        \n        return right\n", "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right\n"], ["class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        \n        res = 0\n        \n        for i in range(len(s)):\n            if i > 0 and roman[s[i]] > roman[s[i-1]]:\n                res += roman[s[i]] - 2 * roman[s[i-1]]\n            else:\n                res += roman[s[i]]\n        \n        return res", "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        \n        res = 0\n        \n        for i in range(len(s)):\n            if i > 0 and roman[s[i]] > roman[s[i-1]]:\n                res += roman[s[i]] - 2 * roman[s[i-1]]\n            else:\n                res += roman[s[i]]\n                \n        return res\n", "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        d = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        \n        ans = 0\n        \n        for i in range(len(s)):\n            if i < len(s) - 1 and d[s[i]] < d[s[i + 1]]:\n                ans -= d[s[i]]\n            else:\n                ans += d[s[i]]\n                \n        return ans", "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        for i in range(len(s)):\n            if i + 1 < len(s) and roman[s[i]] < roman[s[i + 1]]:\n                ans -= roman[s[i]]\n            else:\n                ans += roman[s[i]]\n        return ans", "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        d = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        ans = 0\n        \n        for i in range(len(s) - 1):\n            if d[s[i]] < d[s[i + 1]]:\n                ans -= d[s[i]]\n            else:\n                ans += d[s[i]]\n        \n        ans += d[s[-1]]\n        \n        return ans"], ["class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(set(nums)) != len(nums)\n", "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(set(nums)) != len(nums)\n", "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return len(set(nums)) != len(nums)\n", "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(set(nums)) != len(nums)\n", "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(set(nums)) != len(nums)\n"], ["class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        q = collections.deque()\n        out = []\n        for i in range(n):\n            while q and q[0] <= i - k:\n                q.popleft()\n            while q and nums[q[-1]] <= nums[i]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                out.append(nums[q[0]])\n        return out\n", "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        q = collections.deque()\n        out = []\n        for i in range(n):\n            while q and q[0] < i - k + 1:\n                q.popleft()\n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                out.append(nums[q[0]])\n        return out", "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        q = collections.deque()\n        out = []\n        for i in range(n):\n            while q and q[0] <= i - k:\n                q.popleft()\n            while q and nums[q[-1]] <= nums[i]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                out.append(nums[q[0]])\n        return out", "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        n = len(nums)\n        for i in range(n - k + 1):\n            ans.append(max(nums[i:i + k]))\n        return ans", "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        q = collections.deque()\n        out = []\n        for i in range(n):\n            while q and q[0] < i - k + 1:\n                q.popleft()\n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                out.append(nums[q[0]])\n        return out\n"], ["class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums = sorted(nums1 + nums2)\n        n = len(nums)\n        if n % 2 == 0:\n            return (nums[n // 2 - 1] + nums[n // 2]) / 2.0\n        else:\n            return nums[n // 2]", "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums = sorted(nums1 + nums2)\n        n = len(nums)\n        if n % 2 == 0:\n            return (nums[n // 2 - 1] + nums[n // 2]) / 2.0\n        else:\n            return nums[n // 2]", "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        \n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]", "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums = sorted(nums1 + nums2)\n        n = len(nums)\n        \n        if n % 2 == 1:\n            return nums[n // 2]\n        else:\n            return (nums[n // 2 - 1] + nums[n // 2]) / 2.0\n", "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums = sorted(nums1 + nums2)\n        n = len(nums)\n        if n % 2 == 0:\n            return (nums[n // 2 - 1] + nums[n // 2]) / 2.0\n        else:\n            return nums[n // 2]\n"], ["class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        \n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        return nums[l]\n", "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            else:\n                r = mid\n        return nums[l]\n", "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            else:\n                r = mid\n        return nums[l]\n", "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        return nums[l]", "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            else:\n                r = mid\n        return nums[l]\n"], ["class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [1]\n        for i in range(rowIndex):\n            ans = [1] + [ans[i] + ans[i + 1] for i in range(len(ans) - 1)] + [1]\n        return ans", "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [1]\n        for i in range(rowIndex):\n            ans = [x + y for x, y in zip([0] + ans, ans + [0])]\n        return ans\n", "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [1]\n        for i in range(rowIndex):\n            res.append(res[-1] * (rowIndex - i) // (i + 1))\n        return res", "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [1]\n        for i in range(rowIndex):\n            ans = [1] + [ans[j] + ans[j + 1] for j in range(i)] + [1]\n        return ans", "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [1]\n        for i in range(rowIndex):\n            res = [x + y for x, y in zip([0] + res, res + [0])]\n        return res"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(int(math.sqrt(area)), 0, -1):\n            if area % i == 0:\n                return [area / i, i]", "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        w = int(math.sqrt(area))\n        while area % w != 0:\n            w -= 1\n        return [area / w, w]", "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        w = int(math.sqrt(area))\n        while area % w != 0:\n            w -= 1\n        return [area / w, w]", "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        w = int(math.sqrt(area))\n        while area % w != 0:\n            w -= 1\n        return [area / w, w]"], ["class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        ans = []\n        wordList = set(wordList)\n        if endWord not in wordList:\n            return ans\n        \n        wordList.add(beginWord)\n        \n        prev = {beginWord}\n        next = set()\n        \n        while prev:\n            wordList -= prev\n            for word in prev:\n                for i in range(len(word)):\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\n                        new_word = word[:i] + c + word[i + 1:]\n                        if new_word in wordList:\n                            if new_word == endWord:\n                                ans.append([new_word, word])\n                            else:\n                                next.add(new_word)\n                                \n            if ans:\n                break\n            prev, next = next, set()\n            \n        return [list(reversed(path)) for path in ans]", "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1\n", "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1\n", "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1\n", "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        \n        return n == 1", "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n > 1:\n            if n % 2 != 0:\n                return False\n            n /= 2\n        return True\n"], ["class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        def backtrack(i, subset):\n            if i == len(nums):\n                res.append(subset[:])\n                return\n            \n            # Include nums[i]\n            subset.append(nums[i])\n            backtrack(i + 1, subset)\n            \n            # Exclude nums[i]\n            subset.pop()\n            \n            # Skip duplicates\n            while i + 1 < len(nums) and nums[i] == nums[i + 1]:\n                i += 1\n            \n            backtrack(i + 1, subset)\n        \n        backtrack(0, [])\n        return res\n\n", "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        def dfs(i, subset):\n            if i == len(nums):\n                res.append(subset[:])\n                return\n            \n            dfs(i + 1, subset)\n            \n            if i > 0 and nums[i] == nums[i - 1]:\n                return\n            \n            subset.append(nums[i])\n            dfs(i + 1, subset)\n            subset.pop()\n        \n        dfs(0, [])\n        return res", "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        def backtrack(start, path):\n            res.append(path)\n            \n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i - 1]:\n                    continue\n                backtrack(i + 1, path + [nums[i]])\n        \n        backtrack(0, [])\n        return res\n", "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, 0, [], res)\n        return res\n    \n    def dfs(self, nums, index, path, res):\n        res.append(path)\n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i - 1]:\n                continue\n            self.dfs(nums, i + 1, path + [nums[i]], res)", "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        def dfs(i, subset):\n            if i == len(nums):\n                res.append(subset[:])\n                return\n            \n            dfs(i + 1, subset)\n            \n            if i > 0 and nums[i] == nums[i - 1]:\n                return\n            \n            subset.append(nums[i])\n            dfs(i + 1, subset)\n            subset.pop()\n            \n        dfs(0, [])\n        return res"], ["class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            start = i\n            while stack and stack[-1][1] > heights[i]:\n                index, height = stack.pop()\n                max_area = max(max_area, height * (i - index))\n                start = index\n            stack.append((start, heights[i]))\n        \n        for i, h in stack:\n            max_area = max(max_area, h * (len(heights) - i))\n        \n        return max_area\n", "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(heights)\n        left = [0] * n\n        right = [0] * n\n        \n        stack = []\n        \n        for i in range(n):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            left[i] = stack[-1] if stack else -1\n            stack.append(i)\n        \n        stack = []\n        \n        for i in range(n - 1, -1, -1):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            right[i] = stack[-1] if stack else n\n            stack.append(i)\n        \n        max_area = 0\n        for i in range(n):\n            max_area = max(max_area, heights[i] * (right[i] - left[i] - 1))\n        \n        return max_area\n", "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(heights)\n        left = [0] * n\n        right = [0] * n\n        \n        stack = []\n        \n        for i in range(n):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            if stack:\n                left[i] = stack[-1] + 1\n            else:\n                left[i] = 0\n            stack.append(i)\n        \n        stack = []\n        \n        for i in range(n - 1, -1, -1):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            if stack:\n                right[i] = stack[-1] - 1\n            else:\n                right[i] = n - 1\n            stack.append(i)\n        \n        max_area = 0\n        for i in range(n):\n            max_area = max(max_area, heights[i] * (right[i] - left[i] + 1))\n        \n        return max_area", "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(heights)\n        left = [0] * n\n        right = [0] * n\n        \n        stack = []\n        for i in range(n):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            left[i] = stack[-1] + 1 if stack else 0\n            stack.append(i)\n        \n        stack = []\n        for i in range(n - 1, -1, -1):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            right[i] = stack[-1] - 1 if stack else n - 1\n            stack.append(i)\n        \n        max_area = 0\n        for i in range(n):\n            max_area = max(max_area, heights[i] * (right[i] - left[i] + 1))\n        \n        return max_area\n", "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        \n        n = len(heights)\n        \n        left = [0] * n\n        right = [0] * n\n        \n        stack = []\n        \n        for i in range(n):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n                \n            if stack:\n                left[i] = stack[-1] + 1\n            else:\n                left[i] = 0\n                \n            stack.append(i)\n            \n        stack = []\n        \n        for i in range(n - 1, -1, -1):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n                \n            if stack:\n                right[i] = stack[-1] - 1\n            else:\n                right[i] = n - 1\n                \n            stack.append(i)\n            \n        ans = 0\n        for i in range(n):\n            ans = max(ans, heights[i] * (right[i] - left[i] + 1))\n            \n        return ans"], ["class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(a) / b))\n            else:\n                stack.append(int(token))\n        return stack[0]", "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for i in tokens:\n            if i == '+':\n                stack.append(stack.pop() + stack.pop())\n            elif i == '-':\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif i == '*':\n                stack.append(stack.pop() * stack.pop())\n            elif i == '/':\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(b / a))\n            else:\n                stack.append(int(i))\n        return stack.pop()\n", "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(a) / b))\n            else:\n                stack.append(int(token))\n        return stack.pop()\n", "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for i in tokens:\n            if i == '+':\n                stack.append(stack.pop() + stack.pop())\n            elif i == '-':\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif i == '*':\n                stack.append(stack.pop() * stack.pop())\n            elif i == '/':\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(b / a))\n            else:\n                stack.append(int(i))\n        return stack.pop()\n", "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(a) / b))\n            else:\n                stack.append(int(token))\n        return stack[0]"], ["class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x1 = y1 = float('inf')\n        x2 = y2 = float('-inf')\n        \n        area = 0\n        \n        points = set()\n        \n        for x, y, xx, yy in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, xx)\n            y2 = max(y2, yy)\n            \n            area += (xx - x) * (yy - y)\n            \n            points.add((x, y))\n            points.add((x, yy))\n            points.add((xx, y))\n            points.add((xx, yy))\n        \n        if (x1, y1) not in points or (x1, y2) not in points or (x2, y1) not in points or (x2, y2) not in points:\n            return False\n        \n        points.remove((x1, y1))\n        points.remove((x1, y2))\n        points.remove((x2, y1))\n        points.remove((x2, y2))\n        \n        if len(points) != 4:\n            return False\n        \n        return area == (x2 - x1) * (y2 - y1)", "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x1 = y1 = float('inf')\n        x2 = y2 = float('-inf')\n        area = 0\n        \n        count = collections.Counter()\n        for x, y, xx, yy in rectangles:\n            area += (xx - x) * (yy - y)\n            count[(x, y)] += 1\n            count[(x, yy)] -= 1\n            count[(xx, y)] -= 1\n            count[(xx, yy)] += 1\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, xx)\n            y2 = max(y2, yy)\n        \n        if area != (x2 - x1) * (y2 - y1):\n            return False\n        \n        for x, y in count:\n            if count[(x, y)] != 0:\n                if count[(x, y)] % 2 != 0:\n                    return False\n                if (x, y) in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)] and count[(x, y)] != 4:\n                    return False\n        \n        return True", "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        area = 0\n        x1, y1, x2, y2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n        \n        for x, y, a, b in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, a)\n            y2 = max(y2, b)\n            area += (a - x) * (b - y)\n        \n        if x1 != x2 or y1 != y2:\n            return False\n        \n        for x, y, a, b in rectangles:\n            if (x, y) not in [(x, y1), (x1, y), (x1, y1), (x, y1), (x, b), (a, y), (a, y1), (a, b), (x2, y), (x2, y1), (x2, b), (a, b)]:\n                return False\n        \n        return area == (x2 - x1) * (y2 - y1)", "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x1 = y1 = float('inf')\n        x2 = y2 = float('-inf')\n        \n        area = 0\n        \n        points = set()\n        \n        for x, y, xx, yy in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, xx)\n            y2 = max(y2, yy)\n            \n            area += (xx - x) * (yy - y)\n            \n            points.add((x, y))\n            points.add((xx, yy))\n            points.add((x, yy))\n            points.add((xx, y))\n        \n        if (x1, y1) not in points or (x2, y2) not in points:\n            return False\n        \n        points.remove((x1, y1))\n        points.remove((x2, y2))\n        \n        if len(points) != 4:\n            return False\n        \n        for x, y in points:\n            if (x, y) not in points:\n                return False\n        \n        return area == (x2 - x1) * (y2 - y1)\n", "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x1, y1, x2, y2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        \n        points = set()\n        \n        for x1, y1, x2, y2 in rectangles:\n            area += (x2 - x1) * (y2 - y1)\n            \n            for x, y in ((x1, y1), (x1, y2), (x2, y1), (x2, y2)):\n                if (x, y) in points:\n                    points.remove((x, y))\n                else:\n                    points.add((x, y))\n                    \n        if len(points) != 4 or (x1, y1) not in points or (x1, y2) not in points or (x2, y1) not in points or (x2, y2) not in points:\n            return False\n        \n        return area == (x2 - x1) * (y2 - y1)"], ["class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res", "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            ans = chr(columnNumber % 26 + ord('A')) + ans\n            columnNumber //= 26\n        return ans", "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            ans = chr(columnNumber % 26 + ord('A')) + ans\n            columnNumber //= 26\n        return ans", "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            ans = chr(columnNumber % 26 + ord('A')) + ans\n            columnNumber //= 26\n        return ans", "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            ans = chr(columnNumber % 26 + ord('A')) + ans\n            columnNumber //= 26\n        return ans"], ["class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum\n", "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = nums[0]\n        cur = nums[0]\n        for i in range(1, len(nums)):\n            cur = max(nums[i], cur + nums[i])\n            ans = max(ans, cur)\n        return ans\n", "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum\n", "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        current_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            current_sum = max(nums[i], current_sum + nums[i])\n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum\n", "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        for i in range(1, len(nums)):\n            curr_sum = max(curr_sum + nums[i], nums[i])\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n"], ["class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def get_neighbors(board):\n            neighbors = []\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        if i > 0:\n                            neighbors.append((i - 1, j))\n                        if i < 1:\n                            neighbors.append((i + 1, j))\n                        if j > 0:\n                            neighbors.append((i, j - 1))\n                        if j < 2:\n                            neighbors.append((i, j + 1))\n            return neighbors\n        \n        def swap(board, i, j, k, l):\n            board[i][j], board[k][l] = board[k][l], board[i][j]\n            return board\n        \n        def get_state(board):\n            state = ''\n            for i in range(2):\n                for j in range(3):\n                    state += str(board[i][j])\n            return state\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, steps = queue.pop(0)\n                state = get_state(board)\n                if state == '123450':\n                    return steps\n                if state in visited:\n                    continue\n                visited.add(state)\n                for i, j in get_neighbors(board):\n                    new_board = swap(board, i, j, i, j)\n                    queue.append((new_board, steps + 1))\n            return -1\n        \n        return bfs(board)", "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def get_neighbors(board):\n            neighbors = []\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        if i > 0:\n                            neighbors.append((i - 1, j))\n                        if i < 1:\n                            neighbors.append((i + 1, j))\n                        if j > 0:\n                            neighbors.append((i, j - 1))\n                        if j < 2:\n                            neighbors.append((i, j + 1))\n            return neighbors\n        \n        def swap(board, i, j, k, l):\n            board[i][j], board[k][l] = board[k][l], board[i][j]\n            return board\n        \n        def get_state(board):\n            return tuple(map(tuple, board))\n        \n        def get_board(state):\n            return [list(row) for row in state]\n        \n        def get_moves(board):\n            moves = []\n            for i, j in get_neighbors(board):\n                for k, l in get_neighbors(board):\n                    if (i, j) != (k, l):\n                        moves.append((i, j, k, l))\n            return moves\n        \n        def get_next_states(board):\n            next_states = []\n            for i, j, k, l in get_moves(board):\n                next_board = swap(board, i, j, k, l)\n                next_states.append(get_state(next_board))\n            return next_states\n        \n        def bfs(start, end):\n            queue = [(start, 0)]\n            visited = set()\n            while queue:\n                state, moves = queue.pop(0)\n                if state == end:\n                    return moves\n                visited.add(state)\n                for next_state in get_next_states(get_board(state)):\n                    if next_state not in visited:\n                        queue.append((next_state, moves + 1))\n            return -1\n        \n        start = get_state(board)\n        end = ((1, 2, 3), (4, 5, 0))\n        return bfs(start, end)", "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i // 3][i % 3], board[j // 3][j % 3] = board[j // 3][j % 3], board[i // 3][i % 3]\n            return board\n        \n        def get_neighbors(board):\n            neighbors = []\n            for i in range(6):\n                for j in range(i + 1, 6):\n                    if board[i // 3][i % 3] != 0 and board[j // 3][j % 3] == 0:\n                        neighbors.append(swap(board[:], i, j))\n            return neighbors\n        \n        def get_state(board):\n            return tuple(map(tuple, board))\n        \n        start = get_state(board)\n        end = ((1, 2, 3), (4, 5, 0))\n        \n        visited = set()\n        queue = collections.deque([(start, 0)])\n        \n        while queue:\n            state, steps = queue.popleft()\n            if state == end:\n                return steps\n            \n            for neighbor in get_neighbors(list(state)):\n                neighbor_state = get_state(neighbor)\n                if neighbor_state not in visited:\n                    visited.add(neighbor_state)\n                    queue.append((neighbor_state, steps + 1))\n        \n        return -1"], ["class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_to_t and t[i] not in t_to_s:\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n            elif s[i] in s_to_t and t[i] in t_to_s:\n                if s_to_t[s[i]] != t[i] or t_to_s[t[i]] != s[i]:\n                    return False\n            else:\n                return False\n        \n        return True\n", "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_to_t and t[i] not in t_to_s:\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n            elif s[i] in s_to_t and t[i] in t_to_s:\n                if s_to_t[s[i]] != t[i] or t_to_s[t[i]] != s[i]:\n                    return False\n            else:\n                return False\n        \n        return True", "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_to_t and t[i] not in t_to_s:\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n            elif s[i] in s_to_t and t[i] in t_to_s:\n                if s_to_t[s[i]] != t[i] or t_to_s[t[i]] != s[i]:\n                    return False\n            else:\n                return False\n        \n        return True", "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_to_t and t[i] not in t_to_s:\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n            elif s[i] in s_to_t and t[i] in t_to_s:\n                if s_to_t[s[i]] != t[i] or t_to_s[t[i]] != s[i]:\n                    return False\n            else:\n                return False\n        \n        return True", "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_to_t and t[i] not in t_to_s:\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n            elif s[i] in s_to_t and t[i] in t_to_s:\n                if s_to_t[s[i]] != t[i] or t_to_s[t[i]] != s[i]:\n                    return False\n            else:\n                return False\n        \n        return True"], ["class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            while l < mid and nums[l] == nums[mid]:\n                l += 1\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return False\n", "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            if nums[l] == nums[mid] == nums[r]:\n                l += 1\n                r -= 1\n            elif nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return False\n", "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            while l < mid and nums[l] == nums[mid]:\n                l += 1\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return False\n", "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] == nums[left] and nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[mid] >= nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n", "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            if nums[l] == nums[mid] == nums[r]:\n                l += 1\n                r -= 1\n            elif nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return False\n"], ["class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[m - 1][n - 1]\n", "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            if obstacleGrid[i][0] == 1:\n                break\n            dp[i][0] = 1\n        \n        for j in range(n):\n            if obstacleGrid[0][j] == 1:\n                break\n            dp[0][j] = 1\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[m - 1][n - 1]\n", "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[m - 1][n - 1]", "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i - 1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j - 1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m - 1][n - 1]\n", "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\n            return 0\n        obstacleGrid[0][0] = 1\n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i - 1][0] == 1)\n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j - 1] == 1)\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]\n        return obstacleGrid[m - 1][n - 1]\n"], ["class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1 if s[0] != '0' else 0\n        \n        for i in range(2, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if 10 <= int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        return dp[n]", "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            \n            two_digit = int(s[i - 2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[n]", "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1 if s[0] != '0' else 0\n        \n        for i in range(2, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if 10 <= int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        return dp[n]", "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n                \n            two_digit = int(s[i - 2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i - 2]\n                \n        return dp[n]\n", "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] in '0123456'):\n                dp[i] += dp[i - 2]\n        \n        return dp[n]\n"], ["class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        closest = float('inf')\n        for i in range(n - 2):\n            left, right = i + 1, n - 1\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                if abs(target - current_sum) < abs(target - closest):\n                    closest = current_sum\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    return target\n        return closest\n", "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        ans = nums[0] + nums[1] + nums[2]\n        for i in range(n):\n            l = i + 1\n            r = n - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(ans - target):\n                    ans = s\n                if s < target:\n                    l += 1\n                elif s > target:\n                    r -= 1\n                else:\n                    return target\n        return ans\n", "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        ans = nums[0] + nums[1] + nums[2]\n        for i in range(n - 2):\n            j, k = i + 1, n - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if abs(s - target) < abs(ans - target):\n                    ans = s\n                if s < target:\n                    j += 1\n                elif s > target:\n                    k -= 1\n                else:\n                    return s\n        return ans", "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        ans = float('inf')\n        for i in range(n):\n            j = i + 1\n            k = n - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if abs(s - target) < abs(ans - target):\n                    ans = s\n                if s < target:\n                    j += 1\n                elif s > target:\n                    k -= 1\n                else:\n                    return target\n        return ans\n", "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        closest = float('inf')\n        for i in range(n - 2):\n            left, right = i + 1, n - 1\n            while left < right:\n                s = nums[i] + nums[left] + nums[right]\n                if abs(target - s) < abs(target - closest):\n                    closest = s\n                if s < target:\n                    left += 1\n                elif s > target:\n                    right -= 1\n                else:\n                    return target\n        return closest"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return [i for i in nums1 if i in nums2]\n", "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        d = {}\n        for i in nums1:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        \n        ans = []\n        for i in nums2:\n            if i in d and d[i] > 0:\n                ans.append(i)\n                d[i] -= 1\n        \n        return ans\n", "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        for i in nums1:\n            if i in nums2:\n                ans.append(i)\n                nums2.remove(i)\n        return ans\n", "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = j = 0\n        \n        result = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        \n        return result\n", "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        for i in nums1:\n            if i in nums2:\n                ans.append(i)\n                nums2.remove(i)\n        return ans\n"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle in haystack:\n            return haystack.index(needle)\n        else:\n            return -1\n", "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        return -1", "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        return haystack.find(needle)\n", "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle not in haystack:\n            return -1\n        \n        return haystack.index(needle)", "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle in haystack:\n            return haystack.index(needle)\n        else:\n            return -1\n"], ["class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(password)\n        missing_types = 3\n        if any(c.islower() for c in password):\n            missing_types -= 1\n        if any(c.isupper() for c in password):\n            missing_types -= 1\n        if any(c.isdigit() for c in password):\n            missing_types -= 1\n        \n        replace = 0\n        for i in range(1, n):\n            if password[i] == password[i - 1]:\n                replace += 1\n        \n        if n < 6:\n            add = max(0, 6 - n)\n            return add + max(0, missing_types - add)\n        elif n <= 20:\n            return max(0, replace) + max(0, missing_types)\n        else:\n            delete = n - 20\n            return delete + max(replace - delete, 0) + max(missing_types, 3)", "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(password)\n        missing_types = 3\n        \n        if any(c.islower() for c in password):\n            missing_types -= 1\n        if any(c.isupper() for c in password):\n            missing_types -= 1\n        if any(c.isdigit() for c in password):\n            missing_types -= 1\n        \n        if n < 6:\n            return max(missing_types, 6 - n)\n        elif n <= 20:\n            return max(missing_types, 0)\n        else:\n            replace = n - 20\n            change = [0, 0, 0]\n            \n            for c in password:\n                if c.islower() or c.isupper() or c.isdigit():\n                    change[0] += 1\n                else:\n                    change[2] += 1\n                \n                if change[0] >= 3:\n                    replace -= 1\n                    change[0] -= 3\n                if change[2] >= 3:\n                    replace -= 1\n                    change[2] -= 3\n            \n            change = min(replace, sum(change))\n            return replace + max(missing_types, change)", "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        \n        n = len(password)\n        missing_types = 3\n        if any(c.islower() for c in password):\n            missing_types -= 1\n        if any(c.isupper() for c in password):\n            missing_types -= 1\n        if any(c.isdigit() for c in password):\n            missing_types -= 1\n        \n        replace = 0\n        for i in range(1, n):\n            if password[i] == password[i - 1]:\n                replace += 1\n        \n        if n < 6:\n            return max(missing_types, 6 - n)\n        elif n <= 20:\n            return max(missing_types, replace)\n        else:\n            reduce = n - 20\n            replace = min(replace, reduce)\n            erase = reduce - replace\n            \n            erase_5 = min(erase, n - 18)\n            erase -= erase_5\n            replace -= erase_5\n            \n            erase_3 = min(erase, (erase_5 + 1) // 2)\n            erase -= erase_3\n            replace -= erase_3 * 2\n            \n            erase_2 = min(erase, erase_3)\n            erase -= erase_2\n            replace -= erase_2 * 2\n            \n            return reduce + max(missing_types, replace)", "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        if len(password) < 6:\n            return 6 - len(password)\n        \n        if len(password) > 20:\n            return len(password) - 20\n        \n        lower = False\n        upper = False\n        digit = False\n        \n        for c in password:\n            if c.islower():\n                lower = True\n            elif c.isupper():\n                upper = True\n            elif c.isdigit():\n                digit = True\n        \n        if not lower or not upper or not digit:\n            return 3\n        \n        return 0"], ["class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        while n > 0:\n            n //= 5\n            ans += n\n        return ans", "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ans = 0\n        while n:\n            ans += n // 5\n            n //= 5\n        return ans", "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        while n > 0:\n            ans += n // 5\n            n //= 5\n        return ans", "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        while n > 0:\n            ans += n // 5\n            n //= 5\n        return ans", "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        while n > 0:\n            ans += n // 5\n            n //= 5\n        return ans\n"], ["class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        row = 0\n        goingDown = False\n        \n        for char in s:\n            rows[row] += char\n            if row == 0 or row == numRows - 1:\n                goingDown = not goingDown\n            row += 1 if goingDown else -1\n        \n        return ''.join(rows)", "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        row = 0\n        goingDown = False\n        \n        for char in s:\n            rows[row] += char\n            if row == 0 or row == numRows - 1:\n                goingDown = not goingDown\n            row += 1 if goingDown else -1\n        \n        return ''.join(rows)", "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        row = 0\n        goingDown = False\n        \n        for char in s:\n            rows[row] += char\n            if row == 0 or row == numRows - 1:\n                goingDown = not goingDown\n            row += 1 if goingDown else -1\n        \n        return ''.join(rows)", "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        row = 0\n        step = 1\n        \n        for char in s:\n            rows[row] += char\n            if row == 0:\n                step = 1\n            elif row == numRows - 1:\n                step = -1\n            row += step\n        \n        return ''.join(rows)", "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        row = 0\n        step = 1\n        \n        for char in s:\n            rows[row] += char\n            if row == 0:\n                step = 1\n            elif row == numRows - 1:\n                step = -1\n            row += step\n        \n        return ''.join(rows)"], ["class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        left_max = 0\n        right_max = 0\n        water = 0\n        while left < right:\n            if height[left] < height[right]:\n                if height[left] >= left_max:\n                    left_max = height[left]\n                else:\n                    water += left_max - height[left]\n                left += 1\n            else:\n                if height[right] >= right_max:\n                    right_max = height[right]\n                else:\n                    water += right_max - height[right]\n                right -= 1\n        return water", "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(height)\n        left_max = [0] * n\n        right_max = [0] * n\n        \n        left_max[0] = height[0]\n        for i in range(1, n):\n            left_max[i] = max(left_max[i - 1], height[i])\n        \n        right_max[n - 1] = height[n - 1]\n        for i in range(n - 2, -1, -1):\n            right_max[i] = max(right_max[i + 1], height[i])\n        \n        ans = 0\n        for i in range(n):\n            ans += min(left_max[i], right_max[i]) - height[i]\n        \n        return ans\n", "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(height)\n        lmax = [0] * n\n        rmax = [0] * n\n        \n        lmax[0] = height[0]\n        for i in range(1, n):\n            lmax[i] = max(lmax[i - 1], height[i])\n        \n        rmax[n - 1] = height[n - 1]\n        for i in range(n - 2, -1, -1):\n            rmax[i] = max(rmax[i + 1], height[i])\n        \n        ans = 0\n        for i in range(n):\n            ans += min(lmax[i], rmax[i]) - height[i]\n        \n        return ans\n", "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(height)\n        left = [0] * n\n        right = [0] * n\n        \n        left[0] = height[0]\n        for i in range(1, n):\n            left[i] = max(left[i - 1], height[i])\n        \n        right[n - 1] = height[n - 1]\n        for i in range(n - 2, -1, -1):\n            right[i] = max(right[i + 1], height[i])\n        \n        ans = 0\n        for i in range(n):\n            ans += min(left[i], right[i]) - height[i]\n        \n        return ans", "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(height)\n        left = [0] * n\n        right = [0] * n\n        \n        left[0] = height[0]\n        for i in range(1, n):\n            left[i] = max(left[i - 1], height[i])\n        \n        right[n - 1] = height[n - 1]\n        for i in range(n - 2, -1, -1):\n            right[i] = max(right[i + 1], height[i])\n        \n        ans = 0\n        for i in range(n):\n            ans += min(left[i], right[i]) - height[i]\n        \n        return ans\n"], ["class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            index = abs(nums[i]) - 1\n            nums[index] = -abs(nums[index])\n        \n        return [i + 1 for i in range(n) if nums[i] > 0]\n", "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            index = abs(nums[i]) - 1\n            nums[index] = -abs(nums[index])\n        \n        return [i + 1 for i in range(n) if nums[i] > 0]\n", "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            idx = abs(nums[i]) - 1\n            nums[idx] = -abs(nums[idx])\n        \n        return [i + 1 for i in range(n) if nums[i] > 0]\n", "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            index = abs(nums[i]) - 1\n            nums[index] = -abs(nums[index])\n        \n        return [i + 1 for i in range(n) if nums[i] > 0]\n", "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            index = abs(nums[i]) - 1\n            nums[index] = -abs(nums[index])\n        \n        return [i + 1 for i in range(n) if nums[i] > 0]\n"], ["class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        ans = [0] * n\n        \n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if nums[j] < nums[i]:\n                    ans[i] += 1\n        return ans\n", "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        ans = [0] * n\n        \n        for i in range(n - 1, -1, -1):\n            ans[i] = self.insert(nums[i], i, ans)\n        \n        return ans\n    \n    def insert(self, num, idx, ans):\n        \n        count = 0\n        for i in range(idx):\n            if nums[i] < num:\n                count += 1\n        \n        return count", "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        ans = [0] * n\n        \n        for i in range(n - 1, -1, -1):\n            j = i + 1\n            while j < n and nums[i] > nums[j]:\n                ans[i] += 1\n                j += 1\n        \n        return ans\n", "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        ans = [0] * n\n        \n        for i in range(n - 1, -1, -1):\n            ans[i] = self.mergeSort(nums, i)\n        \n        return ans\n    \n    def mergeSort(self, nums, end):\n        if end <= 0:\n            return 0\n        \n        mid = end // 2\n        left = self.mergeSort(nums, mid)\n        right = self.mergeSort(nums, end - mid - 1)\n        \n        return self.merge(nums, mid, end - mid - 1, left, right)\n    \n    def merge(self, nums, mid, end, left, right):\n        i, j, k = 0, 0, 0\n        \n        while i < mid and j < end:\n            if nums[i] <= nums[mid + 1 + j]:\n                nums[k + i + j] = nums[i]\n                k += 1\n                i += 1\n            else:\n                nums[k + i + j] = nums[mid + 1 + j]\n                k += 1\n                j += 1\n                right += mid - i\n        \n        while i < mid:\n            nums[k + i + j] = nums[i]\n            k += 1\n            i += 1\n        \n        while j < end:\n            nums[k + i + j] = nums[mid + 1 + j]\n            k += 1\n            j += 1\n        \n        return left + right", "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        for i in range(len(nums)):\n            ans.append(sum(nums[i + 1:] < nums[i]))\n        return ans"], ["class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = 0\n        last, second_last = -math.inf, -math.inf\n        for start, end in intervals:\n            if start > second_last:\n                ans += 2\n                last, second_last = end, end - 1\n            elif start > last:\n                ans += 1\n                last = end\n        return ans", "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        \n        ans = 0\n        \n        last = -1\n        second_last = -1\n        \n        for interval in intervals:\n            start, end = interval\n            \n            if last < start:\n                ans += 2\n                last = end\n                second_last = end - 1\n                \n            elif second_last < start:\n                ans += 1\n                second_last = last\n                last = end\n                \n        return ans\n", "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        \n        ans = 0\n        last, second_last = -1, -1\n        \n        for start, end in intervals:\n            if last < start:\n                ans += 2\n                last, second_last = end, end - 1\n            elif second_last < start:\n                ans += 1\n                second_last = last\n                last = end\n        \n        return ans", "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        \n        ans = 0\n        last, second_last = -1, -1\n        \n        for start, end in intervals:\n            if last < start:\n                last, second_last = end, end - 1\n                ans += 2\n            elif second_last < start:\n                second_last = last\n                last = end\n                ans += 1\n        \n        return ans", "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        \n        ans = 0\n        last = None\n        for start, end in intervals:\n            if last is None or last < start:\n                ans += 2\n                last = end\n            else:\n                ans += 1\n                last = max(last, end)\n        return ans"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            ans = {}\n            i = 0\n            while i < len(formula):\n                if formula[i] == '(':\n                    j = i\n                    count = 0\n                    while formula[j] != ')':\n                        j += 1\n                    subans, subcount = parse(formula[i + 1:j])\n                    count += subcount\n                    i = j + 1\n                    while i < len(formula) and formula[i].isdigit():\n                        count = count * 10 + int(formula[i])\n                        i += 1\n                    for key in subans:\n                        ans[key] = ans.get(key, 0) + subans[key] * count\n                elif formula[i].isupper():\n                    j = i + 1\n                    while j < len(formula) and formula[j].islower():\n                        j += 1\n                    name = formula[i:j]\n                    count = 0\n                    while j < len(formula) and formula[j].isdigit():\n                        count = count * 10 + int(formula[j])\n                        j += 1\n                    ans[name] = ans.get(name, 0) + count\n                    i = j\n            return ans\n        \n        ans = parse(formula)\n        return ''.join(name + (str(count) if count > 1 else '') for name, count in sorted(ans.items()))\n", "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            stack = []\n            for c in formula:\n                if c == '(':\n                    stack.append(c)\n                elif c == ')':\n                    sub = []\n                    while stack[-1] != '(':\n                        sub.append(stack.pop())\n                    stack.pop()\n                    sub.reverse()\n                    count = 0\n                    while stack and stack[-1].isdigit():\n                        count = count * 10 + int(stack.pop())\n                    if count == 0:\n                        count = 1\n                    sub = [(x[0], x[1] * count) for x in sub]\n                    stack.extend(sub)\n                elif c.isalpha():\n                    if stack and stack[-1].isdigit():\n                        stack.append(c)\n                    else:\n                        stack.append(c.lower())\n                elif c.isdigit():\n                    stack.append(int(c))\n            return stack\n        \n        stack = parse(formula)\n        stack.reverse()\n        \n        res = []\n        while stack:\n            c = stack.pop()\n            if c.isalpha():\n                res.append(c)\n                while stack and stack[-1].isdigit():\n                    res[-1] += str(stack.pop())\n            else:\n                count = 0\n                while stack and stack[-1].isdigit():\n                    count = count * 10 + int(stack.pop())\n                if count == 0:\n                    count = 1\n                res[-1] += str(count)\n        res.sort()\n        return ''.join(res)", "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            i = 0\n            n = len(formula)\n            res = {}\n            while i < n:\n                if formula[i] == '(':\n                    i += 1\n                    sub_res, j = parse(formula[i:])\n                    i += j\n                    i += 1\n                    res = merge(res, sub_res)\n                elif formula[i] == ')':\n                    return res, i\n                else:\n                    name = ''\n                    while i < n and formula[i].islower():\n                        name += formula[i]\n                        i += 1\n                    if i < n and formula[i].isdigit():\n                        count = ''\n                        while i < n and formula[i].isdigit():\n                            count += formula[i]\n                            i += 1\n                        res[name] = res.get(name, 0) + int(count)\n                    else:\n                        res[name] = res.get(name, 0) + 1\n            return res, i\n        \n        def merge(res1, res2):\n            for name in res2:\n                res1[name] = res1.get(name, 0) + res2[name]\n            return res1\n        \n        res, _ = parse(formula)\n        res = sorted(res.items())\n        return ''.join(name + (str(count) if count > 1 else '') for name, count in res)\n", "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            i = 0\n            d = {}\n            while i < len(formula):\n                if formula[i] == '(':\n                    i += 1\n                    sub, i = parse(formula[i:])\n                    j = i\n                    while j < len(formula) and formula[j].isdigit():\n                        j += 1\n                    count = int(formula[i:j]) if j > i else 1\n                    for atom in sub:\n                        d[atom] = d.get(atom, 0) + count * sub[atom]\n                    i = j\n                elif formula[i] == ')':\n                    return d, i + 1\n                else:\n                    j = i + 1\n                    while j < len(formula) and formula[j].islower():\n                        j += 1\n                    atom = formula[i:j]\n                    i = j\n                    j = i\n                    while j < len(formula) and formula[j].isdigit():\n                        j += 1\n                    count = int(formula[i:j]) if j > i else 1\n                    d[atom] = d.get(atom, 0) + count\n                    i = j\n            return d\n        \n        d = parse(formula)\n        return ''.join(atom + (str(count) if count > 1 else '') for atom, count in sorted(d.items()))\n", "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            ans = {}\n            i = 0\n            while i < len(formula):\n                if formula[i] == ')':\n                    break\n                elif formula[i] == '(':\n                    j = i + 1\n                    count = 0\n                    while j < len(formula) and formula[j].isdigit():\n                        count = count * 10 + int(formula[j])\n                        j += 1\n                    if count == 0:\n                        count = 1\n                    subans = parse(formula[i + 1:j])\n                    for atom, cnt in subans.items():\n                        ans[atom] = ans.get(atom, 0) + cnt * count\n                    i = j\n                else:\n                    j = i + 1\n                    while j < len(formula) and formula[j].islower():\n                        j += 1\n                    atom = formula[i:j]\n                    count = 0\n                    while j < len(formula) and formula[j].isdigit():\n                        count = count * 10 + int(formula[j])\n                        j += 1\n                    if count == 0:\n                        count = 1\n                    ans[atom] = ans.get(atom, 0) + count\n                    i = j\n            return ans\n        \n        ans = parse(formula)\n        return ''.join(atom + (str(cnt) if cnt > 1 else '') for atom, cnt in sorted(ans.items()))\n"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1", "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n % 4 != 0 or n <= 0:\n            return False\n        return self.isPowerOfFour(n / 4)", "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n > 0 and n & (n - 1) == 0 and n & 0x55555555 == n\n", "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n > 0 and n & (n - 1) == 0 and n & 0x55555555 == n", "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n > 0 and n & (n - 1) == 0 and n & 0x55555555 != 0"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        def backtrack(S = '', left = 0, right = 0):\n            if len(S) == 2 * n:\n                ans.append(S)\n                return\n            if left < n:\n                backtrack(S+'(', left+1, right)\n            if right < left:\n                backtrack(S+')', left, right+1)\n        backtrack()\n        return ans\n", "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(s, left, right):\n            if len(s) == 2 * n:\n                ans.append(s)\n                return\n            if left < n:\n                backtrack(s + '(', left + 1, right)\n            if right < left:\n                backtrack(s + ')', left, right + 1)\n        \n        ans = []\n        backtrack('', 0, 0)\n        return ans", "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(s='', left=0, right=0):\n            if len(s) == 2 * n:\n                ans.append(s)\n                return\n            if left < n:\n                backtrack(s+'(', left+1, right)\n            if right < left:\n                backtrack(s+')', left, right+1)\n                \n        ans = []\n        backtrack()\n        return ans\n", "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        def backtrack(S = '', left = 0, right = 0):\n            if len(S) == 2 * n:\n                ans.append(S)\n                return\n            if left < n:\n                backtrack(S+'(', left+1, right)\n            if right < left:\n                backtrack(S+')', left, right+1)\n        backtrack()\n        return ans\n", "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right):\n            if right >= left >= 0:\n                if not right:\n                    ans.append(p)\n                else:\n                    generate(p + '(', left - 1, right)\n                    generate(p + ')', left, right - 1)\n        \n        ans = []\n        generate('', n, n)\n        return ans"], ["class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        i = 0\n        x = 1\n        while x <= n:\n            if i < len(nums) and nums[i] <= x:\n                x += nums[i]\n                i += 1\n            else:\n                x *= 2\n                ans += 1\n        return ans", "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        miss = 1\n        added = 0\n        i = 0\n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                added += 1\n        return added", "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        i = 0\n        x = 1\n        while x <= n:\n            if i < len(nums) and nums[i] <= x:\n                x += nums[i]\n                i += 1\n            else:\n                x *= 2\n                ans += 1\n        return ans", "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        i = 1\n        patches = 0\n        while i <= n:\n            if nums and i >= nums[0]:\n                i += nums.pop(0)\n            else:\n                i *= 2\n                patches += 1\n        return patches", "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        i = 0\n        x = 1\n        while x <= n:\n            if i < len(nums) and nums[i] <= x:\n                x += nums[i]\n                i += 1\n            else:\n                x *= 2\n                ans += 1\n        return ans"], ["class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [0] * n\n        ans = 0\n        for i in range(1, n):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = dp[i - 2] + 2\n                elif i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == '(':\n                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]\n                ans = max(ans, dp[i])\n        return ans\n", "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = [-1]\n        max_len = 0\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len", "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [0] * n\n        ans = 0\n        for i in range(1, n):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = dp[i - 2] + 2\n                elif i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == '(':\n                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]\n                ans = max(ans, dp[i])\n        return ans\n", "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [0] * n\n        ans = 0\n        for i in range(1, n):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = dp[i - 2] + 2\n                elif i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == '(':\n                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]\n                ans = max(ans, dp[i])\n        return ans\n", "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [0] * n\n        ans = 0\n        for i in range(1, n):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = dp[i - 2] + 2\n                elif i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == '(':\n                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]\n                ans = max(ans, dp[i])\n        return ans\n"], ["class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        result = \"\"\n        \n        # if either one is negative (only one can be negative)\n        if numerator < 0 or denominator < 0:\n            result += \"-\"\n        \n        # convert to positive\n        a = abs(numerator)\n        b = abs(denominator)\n        \n        # get the integer result\n        result += str(a // b)\n        \n        # get the fractional result\n        a %= b\n        if a == 0:\n            return result\n        \n        result += \".\"\n        \n        # build the map from the remainder to index\n        remainder_map = {}\n        while a != 0 and a not in remainder_map:\n            remainder_map[a] = len(result)\n            a *= 10\n            result += str(a // b)\n            a %= b\n        \n        # if the remainder is repeating, insert parentheses\n        if a in remainder_map:\n            index = remainder_map[a]\n            result = result[:index] + \"(\" + result[index:] + \")\"\n        \n        return result", "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        result = \"\"\n        \n        # If either one is negative (only one number can be negative)\n        if numerator < 0 or denominator < 0:\n            result += \"-\"\n        \n        # Convert to Long for easier calculation\n        numerator, denominator = abs(numerator), abs(denominator)\n        \n        # Calculate the integer part\n        result += str(numerator / denominator)\n        \n        # Calculate the fractional part\n        remainder = numerator % denominator\n        if remainder == 0:\n            return result\n        \n        result += \".\"\n        \n        # Map to store the remainder and index of its first occurrence\n        remainder_map = {}\n        \n        # Calculate the fractional part until the remainder repeats\n        while remainder != 0:\n            if remainder in remainder_map:\n                # Insert parentheses for repeating part\n                result = result[:remainder_map[remainder]] + \"(\" + result[remainder_map[remainder]:] + \")\"\n                break\n            \n            remainder_map[remainder] = len(result)\n            remainder *= 10\n            result += str(remainder / denominator)\n            remainder %= denominator\n        \n        return result", "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        result = \"\"\n        \n        # if either one is negative (only one number can be negative,\n        # because x^-y = 1/x^y)\n        if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0):\n            result += \"-\"\n        \n        # convert to integers to avoid floating point errors\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        # get the integer part\n        result += str(numerator // denominator)\n        \n        # get the fractional part\n        remainder = numerator % denominator\n        if remainder == 0:\n            return result\n        \n        result += \".\"\n        \n        # keep track of the seen remainders\n        seen = {}\n        while remainder != 0:\n            # if we have seen this remainder before, we have a cycle\n            if remainder in seen:\n                # insert the (...) part\n                result = result[:seen[remainder]] + \"(\" + result[seen[remainder]:] + \")\"\n                break\n            \n            # mark this remainder as seen\n            seen[remainder] = len(result)\n            \n            # update the remainder\n            remainder *= 10\n            result += str(remainder // denominator)\n            remainder %= denominator\n        \n        return result", "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        if numerator == 0:\n            return \"0\"\n        \n        result = \"\"\n        \n        # If either one is negative (only one can be negative)\n        if numerator < 0 or denominator < 0:\n            result += \"-\"\n        \n        # Convert to Long for Java and int for Python\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        # Integral part\n        result += str(numerator / denominator)\n        remainder = numerator % denominator\n        \n        # No decimal point for integer result\n        if remainder == 0:\n            return result\n        \n        # Decimal point\n        result += \".\"\n        \n        # Fractional part\n        seen = {}\n        while remainder != 0:\n            # If remainder is already seen, there is a cycle\n            if remainder in seen:\n                # Insert parentheses to indicate the start of the cycle\n                result = result[:seen[remainder]] + \"(\" + result[seen[remainder]:] + \")\"\n                break\n            \n            # Record the position of the current remainder\n            seen[remainder] = len(result)\n            \n            # Update the remainder for the next iteration\n            remainder *= 10\n            result += str(remainder / denominator)\n            remainder %= denominator\n        \n        return result", "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        if numerator == 0:\n            return \"0\"\n        \n        result = \"\"\n        \n        # if either one is negative (only one number can be negative,\n        # because x and y can't both be negative),\n        # then the result should be negative\n        if (numerator < 0) ^ (denominator < 0):  # use xor operator\n            result += \"-\"\n        \n        # remove the sign of numbers\n        a, b = abs(numerator), abs(denominator)\n        \n        # deal with the integer part\n        result += str(a // b)\n        \n        # if the remainder is zero, we can return the result directly\n        remainder = a % b\n        if remainder == 0:\n            return result\n        \n        # deal with the decimal part\n        result += \".\"\n        dic = {}\n        while remainder != 0:\n            # if the remainder has been seen before,\n            # which means that there is a repeating fraction\n            if remainder in dic:\n                result = result[:dic[remainder]] + \"(\" + result[dic[remainder]:] + \")\"\n                break\n            \n            # record the index of the character just before the decimal point\n            dic[remainder] = len(result)\n            \n            # update the remainder\n            remainder *= 10\n            result += str(remainder // b)\n            remainder %= b\n        \n        return result"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key = lambda x: (x[0], -x[1]))\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)", "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key = lambda x: (x[0], -x[1]))\n        \n        dp = []\n        for _, h in envelopes:\n            idx = bisect.bisect_left(dp, h)\n            if idx == len(dp):\n                dp.append(h)\n            else:\n                dp[idx] = h\n        return len(dp)", "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key = lambda x: (x[0], -x[1]))\n        dp = [1] * len(envelopes)\n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n", "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        dp = [1] * len(envelopes)\n        \n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)\n", "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key = lambda x: (x[0], -x[1]))\n        dp = []\n        for w, h in envelopes:\n            idx = bisect.bisect_left(dp, h)\n            if idx == len(dp):\n                dp.append(h)\n            else:\n                dp[idx] = h\n        return len(dp)"], ["class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row = [False] * m\n        col = [False] * n\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row[i] = True\n                    col[j] = True\n        \n        for i in range(m):\n            for j in range(n):\n                if row[i] or col[j]:\n                    matrix[i][j] = 0", "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row = set()\n        col = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row.add(i)\n                    col.add(j)\n        \n        for i in range(m):\n            for j in range(n):\n                if i in row or j in col:\n                    matrix[i][j] = 0", "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row = set()\n        col = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row.add(i)\n                    col.add(j)\n        \n        for i in range(m):\n            for j in range(n):\n                if i in row or j in col:\n                    matrix[i][j] = 0\n        \n        return matrix\n", "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row = set()\n        col = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row.add(i)\n                    col.add(j)\n        \n        for i in range(m):\n            for j in range(n):\n                if i in row or j in col:\n                    matrix[i][j] = 0", "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row = set()\n        col = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row.add(i)\n                    col.add(j)\n        \n        for i in range(m):\n            for j in range(n):\n                if i in row or j in col:\n                    matrix[i][j] = 0"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))\n", "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))", "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))\n", "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))", "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))\n"], ["class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n:\n            return -1\n        avg = total / n\n        ans = 0\n        cur = 0\n        for m in machines:\n            cur += m - avg\n            ans = max(ans, abs(cur), m - avg)\n        return ans", "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        target = total / n\n        ans = 0\n        left = 0\n        for m in machines:\n            left += m - target\n            ans = max(ans, abs(left), m - target)\n        return ans", "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        avg = total // n\n        ans = 0\n        left = 0\n        for i in range(n):\n            left += machines[i] - avg\n            ans = max(ans, abs(left), machines[i] - avg)\n        return ans", "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        \n        avg = total / n\n        ans = 0\n        cur = 0\n        for m in machines:\n            cur += m - avg\n            ans = max(ans, abs(cur), m - avg)\n        return ans", "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        if total % len(machines) != 0:\n            return -1\n        \n        avg = total / len(machines)\n        \n        ans = 0\n        \n        for i in range(len(machines)):\n            if machines[i] > avg:\n                ans += machines[i] - avg\n                machines[i] = avg\n                \n            if i > 0:\n                machines[i - 1] += machines[i]\n                ans = max(ans, machines[i])\n                \n        return ans"], ["class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x // i, n) for i in range(1, m + 1))\n        \n        left, right = 1, m * n\n        while left < right:\n            mid = (left + right) // 2\n            if count(mid) >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(mid):\n            return sum(min(mid // i, n) for i in range(1, m + 1))\n        \n        left, right = 1, m * n\n        while left < right:\n            mid = (left + right) // 2\n            if count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x // i, n) for i in range(1, m + 1))\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l", "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(mid):\n            return sum(min(mid // i, n) for i in range(1, m + 1))\n        \n        left, right = 1, m * n\n        while left < right:\n            mid = (left + right) // 2\n            if count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(mid):\n            return sum(min(mid / i, n) for i in range(1, m + 1))\n        \n        left, right = 1, m * n\n        while left < right:\n            mid = (left + right) / 2\n            if count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        heights = [0] * cols\n        max_area = 0\n        \n        for row in range(rows):\n            for col in range(cols):\n                if matrix[row][col] == '1':\n                    heights[col] += 1\n                else:\n                    heights[col] = 0\n            \n            stack = []\n            for col in range(cols):\n                while stack and heights[col] < heights[stack[-1]]:\n                    height = heights[stack.pop()]\n                    width = col if not stack else col - stack[-1] - 1\n                    max_area = max(max_area, height * width)\n                stack.append(col)\n            \n            while stack:\n                height = heights[stack.pop()]\n                width = cols if not stack else cols - stack[-1] - 1\n                max_area = max(max_area, height * width)\n        \n        return max_area", "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = [0] * n\n        right = [n] * n\n        height = [0] * n\n        \n        ans = 0\n        \n        for i in range(m):\n            cur_left, cur_right = 0, n\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n                \n                left[j] = max(left[j], cur_left)\n                \n                if matrix[i][j] == '1':\n                    cur_right = j\n                \n                right[j] = min(right[j], cur_right)\n                \n                ans = max(ans, (right[j] - left[j]) * height[j])\n                \n        return ans", "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            \n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[i] < heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        \n        while stack:\n            height = heights[stack.pop()]\n            width = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        return max_area\n", "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        rows, cols = len(matrix), len(matrix[0])\n        left = [0] * cols\n        right = [cols] * cols\n        height = [0] * cols\n        \n        ans = 0\n        \n        for row in matrix:\n            cur_left, cur_right = 0, cols\n            for i in range(cols):\n                if row[i] == '1':\n                    left[i] = max(left[i], cur_left)\n                else:\n                    left[i] = 0\n                    cur_left = i + 1\n            for i in range(cols - 1, -1, -1):\n                if row[i] == '1':\n                    right[i] = min(right[i], cur_right)\n                else:\n                    right[i] = cols\n                    cur_right = i\n            for i in range(cols):\n                height[i] = height[i] + 1 if row[i] == '1' else 0\n                ans = max(ans, height[i] * (right[i] - left[i]))\n        return ans", "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = [0] * n\n        right = [n] * n\n        height = [0] * n\n        \n        ans = 0\n        \n        for i in range(m):\n            cur_left, cur_right = 0, n\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n                \n                left[j] = max(left[j], cur_left)\n                \n                while cur_right - 1 >= 0 and matrix[i][cur_right - 1] == '1':\n                    cur_right -= 1\n                right[j] = min(right[j], cur_right)\n                \n                ans = max(ans, height[j] * (right[j] - left[j]))\n                \n        return ans"], ["class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = [[]]\n        for num in nums:\n            ans += [curr + [num] for curr in ans]\n        return ans\n", "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        n = len(nums)\n        for i in range(1 << n):\n            temp = []\n            for j in range(n):\n                if i & (1 << j):\n                    temp.append(nums[j])\n            ans.append(temp)\n        return ans", "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        n = len(nums)\n        for i in range(2 ** n):\n            temp = []\n            for j in range(n):\n                if i & (1 << j):\n                    temp.append(nums[j])\n            ans.append(temp)\n        return ans\n", "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        \n        def dfs(i, path):\n            if i >= len(nums):\n                res.append(path)\n                return\n            dfs(i + 1, path + [nums[i]])\n            dfs(i + 1, path)\n        \n        dfs(0, [])\n        return res", "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        n = len(nums)\n        for i in range(2 ** n):\n            temp = []\n            for j in range(n):\n                if i & (1 << j):\n                    temp.append(nums[j])\n            ans.append(temp)\n        return ans\n"], ["class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            elif nums[mid] < nums[r]:\n                r = mid\n            else:\n                r -= 1\n        return nums[l]\n", "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            elif nums[mid] < nums[r]:\n                r = mid\n            else:\n                r -= 1\n        return nums[l]\n", "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            elif nums[mid] < nums[r]:\n                r = mid\n            else:\n                r -= 1\n        return nums[l]\n", "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left]", "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        \n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            elif nums[mid] < nums[r]:\n                r = mid\n            else:\n                r -= 1\n        return nums[l]\n"], ["class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        if not s:\n            return False\n        \n        # Check for sign\n        if s[0] in '+-':\n            s = s[1:]\n        \n        # Check for digits\n        if not s or not s[0].isdigit():\n            return False\n        \n        # Check for decimal point\n        if '.' in s:\n            parts = s.split('.')\n            if len(parts) > 2:\n                return False\n            s = ''.join(parts)\n        \n        # Check for exponent\n        if 'e' in s or 'E' in s:\n            parts = s.split('e')\n            if len(parts) > 2:\n                return False\n            s = ''.join(parts)\n            \n            # Check for sign in exponent\n            if s[-1] in '+-':\n                s = s[:-1]\n            \n            # Check for digits in exponent\n            if not s or not s[-1].isdigit():\n                return False\n        \n        # Check for remaining characters\n        if s and not s.isdigit():\n            return False\n        \n        return True", "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        \n        if 'e' in s:\n            s = s.split('e')\n            if len(s) != 2:\n                return False\n            \n            if not s[0].isdigit() and not (s[0][0] == '-' and s[0][1:].isdigit()):\n                return False\n            \n            if not s[1].isdigit() and not (s[1][0] == '-' and s[1][1:].isdigit()):\n                return False\n            \n            return True\n        \n        if '.' in s:\n            s = s.split('.')\n            if len(s) != 2:\n                return False\n            \n            if not s[0].isdigit() and not (s[0][0] == '-' and s[0][1:].isdigit()):\n                return False\n            \n            if not s[1].isdigit() and not (s[1][0] == '-' and s[1][1:].isdigit()):\n                return False\n            \n            return True\n        \n        if not s.isdigit() and not (s[0] == '-' and s[1:].isdigit()):\n            return False\n        \n        return True", "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        \n        if not s:\n            return False\n        \n        if s[0] in '+-':\n            s = s[1:]\n        \n        e_index = s.find('e')\n        if e_index != -1:\n            s = s[:e_index]\n            \n        dot_index = s.find('.')\n        if dot_index != -1:\n            s = s[:dot_index] + s[dot_index + 1:]\n        \n        return s.isdigit()", "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        \n        if not s:\n            return False\n        \n        if 'e' in s or 'E' in s:\n            s1, s2 = s.split('e')\n            s1, s2 = s1.strip(), s2.strip()\n            \n            if not s1 or not s2:\n                return False\n            \n            if not s1.isdigit() and not (s1.startswith('-') or s1.startswith('+')):\n                return False\n            \n            if not s2.isdigit() and not (s2.startswith('-') or s2.startswith('+')):\n                return False\n            \n            return True\n        \n        if '.' in s:\n            s1, s2 = s.split('.')\n            s1, s2 = s1.strip(), s2.strip()\n            \n            if not s1 and not s2:\n                return False\n            \n            if s1 and not s1.isdigit() and not (s1.startswith('-') or s1.startswith('+')):\n                return False\n            \n            if s2 and not s2.isdigit() and not (s2.startswith('-') or s2.startswith('+')):\n                return False\n            \n            return True\n        \n        if not s.isdigit() and not (s.startswith('-') or s.startswith('+')):\n            return False\n        \n        return True", "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        \n        if not s:\n            return False\n        \n        if 'e' in s or 'E' in s:\n            s = s.split('e')\n            s = s[0] + 'E' + s[1]\n            \n        if 'E' in s:\n            s = s.split('E')\n            if len(s) != 2:\n                return False\n            \n            if not s[0] or not s[1]:\n                return False\n            \n            if not s[0].isdigit() and not s[0].isalpha():\n                return False\n            \n            if not s[1].isdigit():\n                return False\n            \n            return True\n        \n        if '.' in s:\n            s = s.split('.')\n            if len(s) != 2:\n                return False\n            \n            if not s[0] and not s[1]:\n                return False\n            \n            if not s[0].isdigit() and not s[0].isalpha():\n                return False\n            \n            if not s[1].isdigit():\n                return False\n            \n            return True\n        \n        if not s.isdigit() and not s.isalpha():\n            return False\n        \n        return True"], ["class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = {\n            1: \"I\",\n            5: \"V\",\n            10: \"X\",\n            50: \"L\",\n            100: \"C\",\n            500: \"D\",\n            1000: \"M\"\n        }\n        \n        def helper(num):\n            if num in roman:\n                return roman[num]\n            \n            for key in sorted(roman.keys(), reverse=True):\n                if num >= key:\n                    return roman[key] + helper(num - key)\n                \n        return helper(num)", "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = ''\n        \n        while num >= 1000:\n            roman += 'M'\n            num -= 1000\n        \n        if num >= 900:\n            roman += 'CM'\n            num -= 900\n        \n        if num >= 500:\n            roman += 'D'\n            num -= 500\n        \n        if num >= 400:\n            roman += 'CD'\n            num -= 400\n        \n        while num >= 100:\n            roman += 'C'\n            num -= 100\n        \n        if num >= 90:\n            roman += 'XC'\n            num -= 90\n        \n        if num >= 50:\n            roman += 'L'\n            num -= 50\n        \n        if num >= 40:\n            roman += 'XL'\n            num -= 40\n        \n        while num >= 10:\n            roman += 'X'\n            num -= 10\n        \n        if num >= 9:\n            roman += 'IX'\n            num -= 9\n        \n        if num >= 5:\n            roman += 'V'\n            num -= 5\n        \n        if num >= 4:\n            roman += 'IV'\n            num -= 4\n        \n        while num >= 1:\n            roman += 'I'\n            num -= 1\n        \n        return roman\n", "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = \"\"\n        \n        while num >= 1000:\n            roman += \"M\"\n            num -= 1000\n        \n        if num >= 900:\n            roman += \"CM\"\n            num -= 900\n        \n        if num >= 500:\n            roman += \"D\"\n            num -= 500\n        \n        if num >= 400:\n            roman += \"CD\"\n            num -= 400\n        \n        while num >= 100:\n            roman += \"C\"\n            num -= 100\n        \n        if num >= 90:\n            roman += \"XC\"\n            num -= 90\n        \n        if num >= 50:\n            roman += \"L\"\n            num -= 50\n        \n        if num >= 40:\n            roman += \"XL\"\n            num -= 40\n        \n        while num >= 10:\n            roman += \"X\"\n            num -= 10\n        \n        if num >= 9:\n            roman += \"IX\"\n            num -= 9\n        \n        if num >= 5:\n            roman += \"V\"\n            num -= 5\n        \n        if num >= 4:\n            roman += \"IV\"\n            num -= 4\n        \n        while num >= 1:\n            roman += \"I\"\n            num -= 1\n        \n        return roman", "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = \"\"\n        \n        while num >= 1000:\n            roman += \"M\"\n            num -= 1000\n        \n        if num >= 900:\n            roman += \"CM\"\n            num -= 900\n        \n        if num >= 500:\n            roman += \"D\"\n            num -= 500\n        \n        if num >= 400:\n            roman += \"CD\"\n            num -= 400\n        \n        while num >= 100:\n            roman += \"C\"\n            num -= 100\n        \n        if num >= 90:\n            roman += \"XC\"\n            num -= 90\n        \n        if num >= 50:\n            roman += \"L\"\n            num -= 50\n        \n        if num >= 40:\n            roman += \"XL\"\n            num -= 40\n        \n        while num >= 10:\n            roman += \"X\"\n            num -= 10\n        \n        if num >= 9:\n            roman += \"IX\"\n            num -= 9\n        \n        if num >= 5:\n            roman += \"V\"\n            num -= 5\n        \n        if num >= 4:\n            roman += \"IV\"\n            num -= 4\n        \n        while num >= 1:\n            roman += \"I\"\n            num -= 1\n        \n        return roman\n", "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = ''\n        \n        while num >= 1000:\n            roman += 'M'\n            num -= 1000\n        \n        if num >= 900:\n            roman += 'CM'\n            num -= 900\n        \n        if num >= 500:\n            roman += 'D'\n            num -= 500\n        \n        if num >= 400:\n            roman += 'CD'\n            num -= 400\n        \n        while num >= 100:\n            roman += 'C'\n            num -= 100\n        \n        if num >= 90:\n            roman += 'XC'\n            num -= 90\n        \n        if num >= 50:\n            roman += 'L'\n            num -= 50\n        \n        if num >= 40:\n            roman += 'XL'\n            num -= 40\n        \n        while num >= 10:\n            roman += 'X'\n            num -= 10\n        \n        if num >= 9:\n            roman += 'IX'\n            num -= 9\n        \n        if num >= 5:\n            roman += 'V'\n            num -= 5\n        \n        if num >= 4:\n            roman += 'IV'\n            num -= 4\n        \n        while num >= 1:\n            roman += 'I'\n            num -= 1\n        \n        return roman"], ["class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        s = sorted(s)\n        t = sorted(t)\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                return t[i]\n        \n        return t[-1]\n", "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        s = sorted(s)\n        t = sorted(t)\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                return t[i]\n        return t[-1]\n", "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        s = sorted(s)\n        t = sorted(t)\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                return t[i]\n        \n        return t[-1]\n", "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        s = sorted(s)\n        t = sorted(t)\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                return t[i]\n        return t[-1]\n", "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        s = sorted(s)\n        t = sorted(t)\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                return t[i]\n        return t[-1]\n"], ["class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n                if board[row][i] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)", "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, val):\n            for i in range(9):\n                if board[row][i] == val:\n                    return False\n                if board[i][col] == val:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == val:\n                    return False\n            return True\n        \n        def solve():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for val in '123456789':\n                            if isValid(i, j, val):\n                                board[i][j] = val\n                                if solve():\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve()", "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, val):\n            for i in range(9):\n                if board[row][i] == val:\n                    return False\n                if board[i][col] == val:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == val:\n                    return False\n            return True\n        \n        def solve(board):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        for val in range(1, 10):\n                            if isValid(board, row, col, str(val)):\n                                board[row][col] = str(val)\n                                if solve(board):\n                                    return True\n                                board[row][col] = '.'\n                        return False\n            return True\n        \n        solve(board)", "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, val):\n            for i in range(9):\n                if board[row][i] == val:\n                    return False\n            for i in range(9):\n                if board[i][col] == val:\n                    return False\n            row0 = (row // 3) * 3\n            col0 = (col // 3) * 3\n            for i in range(3):\n                for j in range(3):\n                    if board[row0 + i][col0 + j] == val:\n                        return False\n            return True\n        \n        def dfs(pos):\n            if pos == len(empty):\n                return True\n            row, col = empty[pos]\n            for val in '123456789':\n                if isValid(row, col, val):\n                    board[row][col] = val\n                    if dfs(pos + 1):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        empty = []\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    empty.append((i, j))\n        dfs(0)", "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        for i in range(2, num):\n            if i * i == num:\n                return True\n        \n        return False\n", "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        for i in range(1, num):\n            if i * i == num:\n                return True\n        return False\n", "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        l = 1\n        r = num\n        \n        while l <= r:\n            mid = (l + r) // 2\n            \n            if mid * mid == num:\n                return True\n            elif mid * mid > num:\n                r = mid - 1\n            else:\n                l = mid + 1\n        \n        return False\n", "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i <= num:\n            if i * i == num:\n                return True\n            i += 1\n        return False\n", "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        l = 1\n        r = num\n        while l <= r:\n            mid = (l + r) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return False\n"], ["class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans\n", "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans\n", "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans\n", "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans\n", "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans\n"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        for i in range(1, n):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[n-i:]) and self.isScramble(s1[i:], s2[:n-i]):\n                return True\n        return False\n", "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False", "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False", "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False", "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        for i in range(1, n):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[n-i:]) and self.isScramble(s1[i:], s2[:n-i]):\n                return True\n        return False"], ["class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)\n", "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split(\"/\"):\n            if p == \"..\":\n                if stack:\n                    stack.pop()\n            elif p and p != \".\":\n                stack.append(p)\n        return \"/\" + \"/\".join(stack)\n", "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split(\"/\"):\n            if p == \"..\":\n                if stack:\n                    stack.pop()\n            elif p and p != \".\":\n                stack.append(p)\n        return \"/\" + \"/\".join(stack)\n", "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split(\"/\"):\n            if p == \"..\":\n                if stack:\n                    stack.pop()\n            elif p and p != \".\":\n                stack.append(p)\n        return \"/\" + \"/\".join(stack)", "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)\n"], ["class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"], ["class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        countS, countT = {}, {}\n        \n        for i in range(len(s)):\n            countS[s[i]] = 1 + countS.get(s[i], 0)\n            countT[t[i]] = 1 + countT.get(t[i], 0)\n            \n        for c in countS:\n            if countS[c] != countT.get(c, 0):\n                return False\n            \n        return True\n", "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n                \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n                \n        if s_dict == t_dict:\n            return True\n        else:\n            return False\n", "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        countS, countT = {}, {}\n        \n        for i in range(len(s)):\n            countS[s[i]] = 1 + countS.get(s[i], 0)\n            countT[t[i]] = 1 + countT.get(t[i], 0)\n            \n        for c in countS:\n            if countS[c] != countT.get(c, 0):\n                return False\n        return True\n", "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n                \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n                \n        if s_dict == t_dict:\n            return True\n        else:\n            return False\n", "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        return sorted(s) == sorted(t)\n"], ["class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    if not self.isValid(board, i, j, board[i][j]):\n                        return False\n        return True\n    \n    def isValid(self, board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num and i != col:\n                return False\n            if board[i][col] == num and i != row:\n                return False\n            if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num and (3 * (row // 3) + i // 3) != row and (3 * (col // 3) + i % 3) != col:\n                return False\n        return True", "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # Check rows\n        for row in board:\n            if not self.isValidRow(row):\n                return False\n        \n        # Check columns\n        for col in zip(*board):\n            if not self.isValidRow(col):\n                return False\n        \n        # Check 3x3 sub-boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                sub_box = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValidRow(sub_box):\n                    return False\n        \n        return True\n    \n    def isValidRow(self, row):\n        nums = [num for num in row if num != '.']\n        return len(set(nums)) == len(nums)\n", "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # Check rows\n        for row in board:\n            if not self.isValidRow(row):\n                return False\n        \n        # Check columns\n        for col in zip(*board):\n            if not self.isValidRow(col):\n                return False\n        \n        # Check 3x3 sub-boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                sub_box = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValidRow(sub_box):\n                    return False\n        \n        return True\n    \n    def isValidRow(self, row):\n        seen = set()\n        for num in row:\n            if num != '.' and num in seen:\n                return False\n            seen.add(num)\n        return True", "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    if not self.isValid(board, i, j, board[i][j]):\n                        return False\n        return True\n    \n    def isValid(self, board, row, col, num):\n        for i in range(9):\n            if board[i][col] == num and i != row:\n                return False\n            if board[row][i] == num and i != col:\n                return False\n            if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num and (3 * (row // 3) + i // 3) != row and (3 * (col // 3) + i % 3) != col:\n                return False\n        return True", "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    continue\n                for k in range(9):\n                    if k != j and board[i][k] == board[i][j]:\n                        return False\n                    if k != i and board[k][j] == board[i][j]:\n                        return False\n                for k in range(3):\n                    for l in range(3):\n                        if (i // 3) * 3 + k != i and (j // 3) * 3 + l != j and board[(i // 3) * 3 + k][(j // 3) * 3 + l] == board[i][j]:\n                            return False\n        return True"], ["class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans\n", "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans", "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans\n", "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans\n", "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans\n"], ["class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return ' '.join(s.split()[::-1])\n", "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return ' '.join(s.split()[::-1])\n", "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return ' '.join(s.split()[::-1])\n", "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return ' '.join(reversed(s.split()))\n", "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return ' '.join(s.split()[::-1])"], ["class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(len(columnTitle)):\n            ans = ans * 26 + (ord(columnTitle[i]) - ord('A') + 1)\n        return ans\n", "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i, c in enumerate(reversed(columnTitle)):\n            ans += (ord(c) - ord('A') + 1) * 26 ** i\n        return ans\n", "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i, c in enumerate(reversed(columnTitle)):\n            ans += (ord(c) - ord('A') + 1) * (26 ** i)\n        return ans", "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(len(columnTitle)):\n            ans = ans * 26 + (ord(columnTitle[i]) - ord('A') + 1)\n        return ans\n", "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(len(columnTitle)):\n            ans = ans * 26 + ord(columnTitle[i]) - ord('A') + 1\n        return ans\n"], ["class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)", "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)", "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)\n", "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)", "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(ratings)\n        candies = [1] * n\n        \n        # Traverse from left to right, and for each child, compare its rating with the previous child's rating.\n        # If the current child has a higher rating, and the number of candies assigned to the previous child is less than or equal to the number of candies assigned to the current child,\n        # increment the number of candies assigned to the current child by 1.\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        # Traverse from right to left, and for each child, compare its rating with the next child's rating.\n        # If the current child has a higher rating, and the number of candies assigned to the next child is less than or equal to the number of candies assigned to the current child,\n        # increment the number of candies assigned to the current child by 1.\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        # Return the sum of the number of candies assigned to each child.\n        return sum(candies)"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] not in d:\n                if s[i] in d.values():\n                    return False\n                d[pattern[i]] = s[i]\n            else:\n                if d[pattern[i]] != s[i]:\n                    return False\n        return True\n", "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        char_to_word = {}\n        word_to_char = {}\n        \n        for char, word in zip(pattern, words):\n            if char in char_to_word and char_to_word[char] != word:\n                return False\n            if word in word_to_char and word_to_char[word] != char:\n                return False\n            \n            char_to_word[char] = word\n            word_to_char[word] = char\n        \n        return True", "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        char_to_word = {}\n        word_to_char = {}\n        \n        for char, word in zip(pattern, words):\n            if char in char_to_word and char_to_word[char] != word:\n                return False\n            if word in word_to_char and word_to_char[word] != char:\n                return False\n            \n            char_to_word[char] = word\n            word_to_char[word] = char\n        \n        return True\n", "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        char_to_word = {}\n        word_to_char = {}\n        \n        for char, word in zip(pattern, words):\n            if char in char_to_word and char_to_word[char] != word:\n                return False\n            if word in word_to_char and word_to_char[word] != char:\n                return False\n            \n            char_to_word[char] = word\n            word_to_char[word] = char\n        \n        return True\n", "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        char_to_word = {}\n        word_to_char = {}\n        \n        for char, word in zip(pattern, words):\n            if char in char_to_word and char_to_word[char] != word:\n                return False\n            if word in word_to_char and word_to_char[word] != char:\n                return False\n            \n            char_to_word[char] = word\n            word_to_char[word] = char\n        \n        return True"], ["class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output\n", "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        ans = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i + 1:]):\n                ans.append([nums[i]] + j)\n        return ans", "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i + 1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res\n", "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(start, end):\n            if start == end:\n                res.append(nums[:])\n            else:\n                for i in range(start, end):\n                    nums[start], nums[i] = nums[i], nums[start]\n                    backtrack(start + 1, end)\n                    nums[start], nums[i] = nums[i], nums[start]\n        \n        res = []\n        backtrack(0, len(nums))\n        return res\n", "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i + 1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res\n"], ["class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        i = 0\n        j = n - 1\n        \n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] > target:\n                j -= 1\n            else:\n                i += 1\n        \n        return False", "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        l = 0\n        r = m * n - 1\n        \n        while l <= r:\n            mid = (l + r) // 2\n            row = mid // n\n            col = mid % n\n            \n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return False\n", "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        i = 0\n        j = n - 1\n        \n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] > target:\n                j -= 1\n            else:\n                i += 1\n        \n        return False", "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        l = 0\n        r = m * n - 1\n        \n        while l <= r:\n            mid = (l + r) // 2\n            mid_val = matrix[mid // n][mid % n]\n            \n            if mid_val == target:\n                return True\n            elif mid_val < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return False\n", "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m * n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            row = mid // n\n            col = mid % n\n            \n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"], ["# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list.", "# Definition for singly-linked list."], ["class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        return int(\"\".join([\"1\" if i == \"0\" else \"0\" for i in bin(num)[2:]]), 2)", "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        return int(bin(num)[2:].replace('1', '2').replace('0', '1').replace('2', '0'), 2)", "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        return num ^ (2 ** (len(bin(num)) - 2) - 1)", "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        return int(bin(num)[2:].replace('1', '2').replace('0', '1').replace('2', '0'), 2)", "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        return int(bin(num)[2:].replace('1', '2').replace('0', '1').replace('2', '0'), 2)"], ["class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        ans = 0\n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n                ans += dp[i]\n        return ans\n", "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if nums[i] + nums[i + 1] == nums[j] + nums[j - 1]:\n                    ans += 1\n        return ans\n", "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if nums[j] - nums[j - 1] == nums[j - 1] - nums[j - 2]:\n                    ans += 1\n        return ans\n", "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if nums[j] - nums[j - 1] == nums[j - 1] - nums[j - 2]:\n                    ans += 1\n        return ans", "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if nums[j] - nums[j - 1] == nums[j - 1] - nums[j - 2]:\n                    ans += 1\n        return ans"], ["class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        i = 0\n        while i < len(words):\n            j = i + 1\n            while j < len(words) and len(words[i]) + len(words[j]) + j - i - 1 <= maxWidth:\n                j += 1\n            line = words[i]\n            if j == len(words):\n                line += \" \" * (maxWidth - len(line))\n            else:\n                spaces = maxWidth - len(line)\n                if j - i - 1 == 0:\n                    line += \" \" * spaces\n                else:\n                    spaces_per_word = spaces // (j - i - 1)\n                    extra_spaces = spaces % (j - i - 1)\n                    for k in range(i + 1, j):\n                        line += \" \" * (spaces_per_word + (1 if k - i - 1 < extra_spaces else 0)) + words[k]\n            ans.append(line)\n            i = j\n        return ans", "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        i = 0\n        while i < len(words):\n            j = i + 1\n            while j < len(words) and len(words[i]) + len(words[j]) + j - i <= maxWidth:\n                j += 1\n            if j - i == 1:\n                ans.append(words[i] + \" \" * (maxWidth - len(words[i])))\n            else:\n                n = maxWidth - sum(len(w) for w in words[i:j])\n                if j == len(words):\n                    ans.append(words[i] + \" \" * n)\n                else:\n                    ans.append(words[i] + \" \" * (n // (j - i - 1)) + \" \" * (n % (j - i - 1)))\n            i = j\n        return ans\n", "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        i = 0\n        while i < len(words):\n            line = []\n            line_len = 0\n            while i < len(words) and line_len + len(words[i]) <= maxWidth:\n                line.append(words[i])\n                line_len += len(words[i]) + 1\n                i += 1\n            line_len -= 1\n            if i == len(words):\n                ans.append(' '.join(line).ljust(maxWidth))\n            else:\n                spaces = maxWidth - line_len\n                if len(line) == 1:\n                    ans.append(line[0].ljust(maxWidth))\n                else:\n                    spaces_per_word = spaces // (len(line) - 1)\n                    extra_spaces = spaces % (len(line) - 1)\n                    line = ' ' * spaces_per_word.join(line)\n                    line = line[:-spaces_per_word] + ' ' * extra_spaces + line[-spaces_per_word:]\n                    ans.append(line)\n        return ans\n", "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        i = 0\n        while i < len(words):\n            j = i + 1\n            while j < len(words) and len(words[j]) + len(words[j - 1]) + 1 <= maxWidth:\n                j += 1\n            if j == len(words):\n                ans.append(self.leftJustify(words[i:], maxWidth))\n                break\n            else:\n                ans.append(self.justify(words[i:j], maxWidth))\n            i = j\n        return ans\n    \n    def justify(self, words, maxWidth):\n        if len(words) == 1:\n            return self.leftJustify(words, maxWidth)\n        n = len(words)\n        total_len = sum(len(word) for word in words)\n        spaces = maxWidth - total_len\n        num_spaces = n - 1\n        space_width = spaces // num_spaces\n        extra_spaces = spaces % num_spaces\n        line = words[0]\n        for i in range(1, n):\n            line += ' ' * space_width\n            if extra_spaces > 0:\n                line += ' '\n                extra_spaces -= 1\n            line += words[i]\n        return line\n    \n    def leftJustify(self, words, maxWidth):\n        line = words[0]\n        for i in range(1, len(words)):\n            line += ' ' + words[i]\n        line += ' ' * (maxWidth - len(line))\n        return line\n", "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(words):\n            line = []\n            line_len = 0\n            while i < len(words) and line_len + len(words[i]) <= maxWidth:\n                line.append(words[i])\n                line_len += len(words[i]) + 1\n                i += 1\n            line_len -= 1\n            if i == len(words):\n                res.append(' '.join(line) + ' ' * (maxWidth - line_len))\n            else:\n                if len(line) == 1:\n                    res.append(line[0] + ' ' * (maxWidth - line_len))\n                else:\n                    spaces = maxWidth - line_len\n                    spaces_between = spaces // (len(line) - 1)\n                    extra_spaces = spaces % (len(line) - 1)\n                    line = ' ' * spaces_between.join(line)\n                    line = line[:maxWidth]\n                    if extra_spaces > 0:\n                        line = line[:-extra_spaces] + ' ' * extra_spaces\n                    res.append(line)\n        return res"], ["# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node.", "# Definition for a binary tree node."], ["class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(height) - 1\n        res = 0\n        while l < r:\n            res = max(res, min(height[l], height[r]) * (r - l))\n            if height[l] < height[r]:\n                l += 1\n            else:\n                r -= 1\n        return res", "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        i, j = 0, len(height) - 1\n        ans = 0\n        while i < j:\n            ans = max(ans, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return ans\n", "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(height)\n        i = 0\n        j = n - 1\n        max_area = 0\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area", "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area", "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(height)\n        i = 0\n        j = n - 1\n        ans = 0\n        while i < j:\n            ans = max(ans, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return ans"], ["class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words = set(words)\n        def dfs(word):\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words and suffix in words:\n                    return True\n                if prefix in words and dfs(suffix):\n                    return True\n            return False\n        \n        ans = []\n        for word in words:\n            if dfs(word):\n                ans.append(word)\n        return ans", "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words = set(words)\n        def dfs(word):\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words and suffix in words:\n                    return True\n                if prefix in words and dfs(suffix):\n                    return True\n                if suffix in words and dfs(prefix):\n                    return True\n            return False\n        \n        ans = []\n        for word in words:\n            if dfs(word):\n                ans.append(word)\n        return ans", "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words = set(words)\n        def dfs(word):\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words and suffix in words:\n                    return True\n                if prefix in words and dfs(suffix):\n                    return True\n                if suffix in words and dfs(prefix):\n                    return True\n            return False\n        \n        ans = []\n        for word in words:\n            if dfs(word):\n                ans.append(word)\n        return ans", "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words = set(words)\n        def dfs(word):\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words and suffix in words:\n                    return True\n                if prefix in words and dfs(suffix):\n                    return True\n            return False\n        return [word for word in words if dfs(word)]", "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words = set(words)\n        def dfs(word):\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words and suffix in words:\n                    return True\n                if prefix in words and dfs(suffix):\n                    return True\n            return False\n        \n        ans = []\n        for word in words:\n            if dfs(word):\n                ans.append(word)\n        return ans"], ["class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        is_negative = num < 0\n        num = abs(num)\n        \n        result = []\n        while num > 0:\n            result.append(str(num % 7))\n            num //= 7\n        \n        if is_negative:\n            result.append(\"-\")\n        \n        return \"\".join(reversed(result))\n", "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        is_negative = num < 0\n        num = abs(num)\n        \n        result = \"\"\n        while num > 0:\n            result = str(num % 7) + result\n            num //= 7\n        \n        if is_negative:\n            result = \"-\" + result\n        \n        return result", "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        ans = \"\"\n        is_negative = num < 0\n        num = abs(num)\n        \n        while num > 0:\n            ans = str(num % 7) + ans\n            num //= 7\n        \n        if is_negative:\n            ans = \"-\" + ans\n        \n        return ans\n", "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        is_negative = num < 0\n        num = abs(num)\n        \n        result = \"\"\n        while num > 0:\n            result = str(num % 7) + result\n            num //= 7\n        \n        if is_negative:\n            result = \"-\" + result\n        \n        return result", "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        is_negative = num < 0\n        num = abs(num)\n        \n        result = \"\"\n        while num > 0:\n            result = str(num % 7) + result\n            num //= 7\n        \n        if is_negative:\n            result = \"-\" + result\n        \n        return result"], ["class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0", "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0", "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0", "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0", "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0"], ["class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                return 1\n            res = 0\n            for q in range(n):\n                if q not in queens and p - q not in xy_dif and p + q not in xy_sum:\n                    res += dfs(queens + [q], xy_dif + [p - q], xy_sum + [p + q])\n            return res\n        return dfs([], [], [])", "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                return 1\n            res = 0\n            for q in range(n):\n                if q not in queens and p - q not in xy_dif and p + q not in xy_sum:\n                    res += dfs(queens + [q], xy_dif + [p - q], xy_sum + [p + q])\n            return res\n        return dfs([], [], [])", "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                res.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p - q not in xy_dif and p + q not in xy_sum:\n                    dfs(queens + [q], xy_dif + [p - q], xy_sum + [p + q])\n        res = []\n        dfs([], [], [])\n        return len(res)", "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(row, cols, pie, na):\n            if row == n:\n                return 1\n            \n            res = 0\n            \n            bits = (~(cols | pie | na)) & ((1 << n) - 1)\n            \n            while bits:\n                p = bits & -bits\n                res += dfs(row + 1, cols | p, (pie | p) << 1, (na | p) >> 1)\n                bits &= bits - 1\n            \n            return res\n        \n        return dfs(0, 0, 0, 0)", "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                return 1\n            ans = 0\n            for q in range(n):\n                if q not in queens and p - q not in xy_dif and p + q not in xy_sum:\n                    ans += dfs(queens + [q], xy_dif + [p - q], xy_sum + [p + q])\n            return ans\n        return dfs([], [], [])\n"], ["class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def backtrack(row, cols, diag, anti_diag, path, res):\n            if row == n:\n                res.append(path)\n                return\n            \n            for col in range(n):\n                diag_index = row - col\n                anti_diag_index = row + col\n                if col in cols or diag_index in diag or anti_diag_index in anti_diag:\n                    continue\n                cols.add(col)\n                diag.add(diag_index)\n                anti_diag.add(anti_diag_index)\n                path.append('.' * col + 'Q' + '.' * (n - col - 1))\n                backtrack(row + 1, cols, diag, anti_diag, path, res)\n                cols.remove(col)\n                diag.remove(diag_index)\n                anti_diag.remove(anti_diag_index)\n                path.pop()\n        \n        res = []\n        cols = set()\n        diag = set()\n        anti_diag = set()\n        backtrack(0, cols, diag, anti_diag, [], res)\n        return res\n", "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def backtrack(row):\n            if row == n:\n                board_copy = [''.join(row) for row in board]\n                solutions.append(board_copy)\n                return\n            for col in range(n):\n                if is_valid(row, col):\n                    board[row][col] = 'Q'\n                    backtrack(row + 1)\n                    board[row][col] = '.'\n        \n        def is_valid(row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        board = [['.'] * n for _ in range(n)]\n        solutions = []\n        backtrack(0)\n        return solutions", "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def backtrack(row, cols, diag, anti_diag, path, res):\n            if row == n:\n                res.append(path)\n                return\n            \n            for col in range(n):\n                cur_diag = row - col\n                cur_anti_diag = row + col\n                if col in cols or cur_diag in diag or cur_anti_diag in anti_diag:\n                    continue\n                cols.add(col)\n                diag.add(cur_diag)\n                anti_diag.add(cur_anti_diag)\n                backtrack(row + 1, cols, diag, anti_diag, path + [col], res)\n                cols.remove(col)\n                diag.remove(cur_diag)\n                anti_diag.remove(cur_anti_diag)\n        \n        res = []\n        backtrack(0, set(), set(), set(), [], res)\n        return res\n", "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def backtrack(row, cols, diag, anti_diag, path, res):\n            if row == n:\n                res.append(path)\n                return\n            \n            for col in range(n):\n                curr_diag = row - col\n                curr_anti_diag = row + col\n                \n                if col in cols or curr_diag in diag or curr_anti_diag in anti_diag:\n                    continue\n                \n                cols.add(col)\n                diag.add(curr_diag)\n                anti_diag.add(curr_anti_diag)\n                \n                backtrack(row + 1, cols, diag, anti_diag, path + [col], res)\n                \n                cols.remove(col)\n                diag.remove(curr_diag)\n                anti_diag.remove(curr_anti_diag)\n                \n        res = []\n        backtrack(0, set(), set(), set(), [], res)\n        \n        return [[\".\" * i + \"Q\" + \".\" * (n - i - 1) for i in sol] for sol in res]", "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def backtrack(row):\n            if row == n:\n                board_copy = [''.join(row) for row in board]\n                solutions.append(board_copy)\n                return\n            for col in range(n):\n                if is_valid(row, col):\n                    board[row][col] = 'Q'\n                    backtrack(row + 1)\n                    board[row][col] = '.'\n        \n        def is_valid(row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        board = [['.' for _ in range(n)] for _ in range(n)]\n        solutions = []\n        backtrack(0)\n        return solutions\n"], ["class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False\n", "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False\n", "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        m = len(board)\n        n = len(board[0])\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:\n                return False\n            \n            temp = board[i][j]\n            board[i][j] = '#'\n            \n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            \n            board[i][j] = temp\n            \n            return res\n        \n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0):\n                    return True\n        \n        return False", "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False", "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        m = len(board)\n        n = len(board[0])\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:\n                return False\n            \n            temp = board[i][j]\n            board[i][j] = '#'\n            \n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            \n            board[i][j] = temp\n            \n            return res\n        \n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0):\n                    return True\n        \n        return False\n"], ["class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        while m > 0 and n > 0:\n            if nums1[m - 1] >= nums2[n - 1]:\n                nums1[m + n - 1] = nums1[m - 1]\n                m -= 1\n            else:\n                nums1[m + n - 1] = nums2[n - 1]\n                n -= 1\n        \n        if n > 0:\n            nums1[:n] = nums2[:n]", "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        \n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1", "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        \n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1", "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        \n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1", "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        \n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1"], ["class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        if len(nums) < 3:\n            return max(nums)\n        nums.remove(max(nums))\n        nums.remove(max(nums))\n        return max(nums)\n", "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        return nums[-3]\n", "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        nums.sort()\n        \n        if len(nums) < 3:\n            return nums[-1]\n        \n        return nums[-3]\n", "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        a = sorted(set(nums))\n        return a[-3] if len(a) >= 3 else a[-1]\n", "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]\n"]]